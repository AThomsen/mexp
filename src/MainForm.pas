{-----------------------------------------------------------------------------
This file is part of MEXP.

    MEXP is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MEXP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MEXP.  If not, see <http://www.gnu.org/licenses/>.

The Initial Developer of the Original Code is Anders Thomsen [mail at andersthomsen dot dk]

Contributions by:
  hopefully lots of people :-)
-----------------------------------------------------------------------------}

{.$define MEXPBuilding}
{.$define ScanInMainThread} // use for debugging. Disable in release builds

unit MainForm;

interface

uses
//QS_Eng;
	Windows, Messages, SysUtils, Classes, Graphics, Controls,  Forms,
	FileCtrl, Menus, ExtCtrls, waipc,
	wampmsg, shellapi, ShlObj, MEXPtypes,
	QStrings,
	StdCtrls,
	addgroupU,
	ComCtrls, ImgList, inuptbox2U,
	ActiveX, jvChangeNotify, Registry,
	VirtualTrees,
	BMDThread, JvComputerInfoEx, WApanel, WinampScrollVert,
	math, Gauges, RecHashTable,
	Id3tags, TagEditor, ColorConv, QStringList,
	snap, WAVfile,
	MpegAudio, MpegPlus,
  OggVorbis, WMAfile, Monkey, ApeTag, SpecialPanel, MyMemoryStream,
	MexpIniFile, ExPopupList, JvComponent, JvSearchFiles, Dialogs, jpeg, pngImage, GR32, GR32_Transforms, OptimizedCode, MyTBits,
  StringFunctions, VirtualTreesEx, JvComponentBase, syncobjs, MyId3v2Base, JvID3v2Types;

type
	// from Platfrom SDK
  PKBDLLHOOKSTRUCT = ^TKBDLLHOOKSTRUCT;
  TKBDLLHOOKSTRUCT = record
		vkCode,
    scanCode,
    flags,
    time:        DWORD;
    dwExtraInfo: Pointer;
  end;

type
	ExtendedFileInfoStruct = packed record
  	filename: PChar;
  	metadata: PChar;
  	ret: PChar;
  	retlen: Integer
	end;

type
	BasicFileInfoStruct = packed record
	  filename: PChar;
  	quickCheck: Integer; // set to 0 to always get, 1 for quick, 2 for default (if 2, quickCheck will be set to 0 if quick wasnot used)

	  // filled in by winamp
  	length: Integer;
  	title: Pointer;
  	titlelen: Integer;
	end;

	TMainForm = class(TForm)
    Configmenu: TPopupMenu;
    Generalconfiguration1: TMenuItem;
    filespopup: TPopupMenu;
		Play1: TMenuItem;
    Addtoplaylist1: TMenuItem;
    N3: TMenuItem;
		Addalltoplaylist1: TMenuItem;
    N4: TMenuItem;
		aot: TMenuItem;
    Deletefilefromharddisk1: TMenuItem;
    N6: TMenuItem;
    Selectall1: TMenuItem;
		Removeallfilters1: TMenuItem;
    Icon1: TImage;
    lss: TPopupMenu;
    SaveDialog1: TSaveDialog;
		OpenDlg: TOpenDialog;
    treepop: TPopupMenu;
    Playallsongsinthisfolder1: TMenuItem;
    Addlocation1: TMenuItem;
    plboxpopup: TPopupMenu;
    Deleteplaylist1: TMenuItem;
		Newplaylist1: TMenuItem;
    N5: TMenuItem;
    LoadinWinamp1: TMenuItem;
    N7: TMenuItem;
    Deleteselecteddatabase1: TMenuItem;
		Enqueallsongsinthisfolder1: TMenuItem;
    Updatetree1: TMenuItem;
    Collapseall1: TMenuItem;
    Expandall1: TMenuItem;
		N8: TMenuItem;
    tabelpanel: TSpecialPanel;
    tabelpanellow: TSpecialPanel;
		filterbar: TWApanel;
    searchlabel: TLabel;
    f0: TEdit;
    treepanel: TSpecialPanel;
    treepanellow: TSpecialPanel;
    Panel1: TWApanel;
    AllButton: TLabel;
		CollapseButton: TLabel;
    EnqueueinWinamp1: TMenuItem;
		SelecttherootofthecurrentdatabaseCtrlR1: TMenuItem;
		RenameQuicklist1: TMenuItem;
    CopyToMyMusic1: TMenuItem;
    N10: TMenuItem;
		SavetoHTML1: TMenuItem;
    SaveDialog2: TSaveDialog;
		N11: TMenuItem;
		Propertiesfor1: TMenuItem;
    qlsongspop: TPopupMenu;
    MoveUp1: TMenuItem;
    MoveDown1: TMenuItem;
    Delete1: TMenuItem;
    N12: TMenuItem;
    Sort1: TMenuItem;
    Shuffle1: TMenuItem;
		PlayAll: TMenuItem;
		filtertimer: TTimer;
    grouplabel: TLabel;
    groupmenu: TPopupMenu;
    Savetoplaylist1: TMenuItem;
    Addselectedtonewplaylist2: TMenuItem;
		Addselectedtoexistingplaylist1: TMenuItem;
    Addalltonewplaylist1: TMenuItem;
    Addalltoexistingplaylist1: TMenuItem;
    UpdateID3tag1: TMenuItem;
    gmenuitem1: TMenuItem;
		pbar: TGauge;
    ViewModeMenuItem: TMenuItem;
    Showmedia1: TMenuItem;
		columnpopup: TPopupMenu;
		slidertimer: TTimer;
		continuousPlay1: TMenuItem;
    TopListPop: TPopupMenu;
		Playedtimes1: TMenuItem;
    Resetcounter1: TMenuItem;
    N1: TMenuItem;
    StartSearch1: TMenuItem;
		autoresettabel: TTimer;
		Rename1: TMenuItem;
    global: TPopupMenu;
		DeleteWinampPlaylist1: TMenuItem;
    Preferences1: TMenuItem;
    Clearfilter1: TMenuItem;
    Selecttherootofthecurrentdatabase1: TMenuItem;
    Mainlistfocused1: TMenuItem;
    TreeFocused1: TMenuItem;
    PlaylistFocused1: TMenuItem;
    QuicklistselectorFocused1: TMenuItem;
		QuicklistsongsFocused1: TMenuItem;
		Selectnoneshowalldatabases1: TMenuItem;
    Refresh1: TMenuItem;
		N2: TMenuItem;
    N9: TMenuItem;
    autoresettree: TTimer;
    Winplaypop: TPopupMenu;
		Moveup2: TMenuItem;
		Movedown2: TMenuItem;
    Delete2: TMenuItem;
    N13: TMenuItem;
    Sort2: TMenuItem;
    Shuffle2: TMenuItem;
    Byfilename1: TMenuItem;
    ByTitle1: TMenuItem;
    Bypathandfilename1: TMenuItem;
    Play2: TMenuItem;
    N14: TMenuItem;
    Refresh2: TMenuItem;
    N15: TMenuItem;
    Refresh3: TMenuItem;
    N16: TMenuItem;
    Refresh4: TMenuItem;
		sliderenable: TTimer;
    DblClickoptions1: TMenuItem;
    menuitembblclick1: TMenuItem;
    Play11: TMenuItem;
    Enqueue1: TMenuItem;
		Punchin1: TMenuItem;
		Punchinandplay1: TMenuItem;
    TreeStimer: TTimer;
    SaveasQuicklist1: TMenuItem;
    TreeExchangeAristAlbum: TMenuItem;
    Tagging1: TMenuItem;
		Edittag1: TMenuItem;
		Scanforduplicates1: TMenuItem;
    ToggleExpanded1: TMenuItem;
		Resetallfiles1: TMenuItem;
    Tags1: TMenuItem;
		Changetracknumberto1231: TMenuItem;
    Organizefiles1: TMenuItem;
    sliderr: TSpecialPanel;
		TreeImgs: TImageList;
    N17: TMenuItem;
    treeplbar: TWApanel;
    plabel1: TLabel;
    MinimizeQ1: TLabel;
		plconbar: TWApanel;
    MinimizeQ2: TLabel;
    WPbar: TWApanel;
    Label1: TLabel;
		MinimizeWinplay: TLabel;
    ClearButton: TLabel;
		TabelScrollV: TWinampScrollVert;
		TreeScrollV: TWinampScrollVert;
		WinPlayScrollV: TWinampScrollVert;
    TabelBar: TWApanel;
    tabel: TVirtualStringTreeEx;
    Winplaylist: TVirtualStringTreeEx;
    playlistbox: TVirtualStringTreeEx;
    plCon: TVirtualStringTreeEx;
    TabelScrollH: TWinampScrollVert;
		PlaylistboxScrollV: TWinampScrollVert;
    plconScrollV: TWinampScrollVert;
    PLCONlabel: TLabel;
    tree: TVirtualStringTreeEx;
    TreeScrollH: TWinampScrollVert;
    EditTagNew: TMenuItem;
    Addplaylist1: TMenuItem;
    Enqueue2: TMenuItem;
		Enqueueandplay1: TMenuItem;
    Punchin2: TMenuItem;
    Punchin3: TMenuItem;
		Findindatabase1: TMenuItem;
    JvDeviceChanged1: TJvComputerInfoEx;
    ClearPopup: TPopupMenu;
		Clearall1: TMenuItem;
    Clearallbutplaying1: TMenuItem;
    Cleardupes1: TMenuItem;
		ClearSelected1: TMenuItem;
    Cropselected1: TMenuItem;
    N20: TMenuItem;
    Deletefromplaylist1: TMenuItem;
    Deleteplaylist2: TMenuItem;
		N22: TMenuItem;
    Undo1: TMenuItem;
    Edittag2: TMenuItem;
		DirSpyTimer: TTimer;
    Punchinandplay2: TMenuItem;
    ToggleKill1: TMenuItem;
		AutoscanThread: TBMDThread;
    Ignoreduplicates1: TMenuItem;
		Closewinamp1: TMenuItem;
    Editcolumn1: TMenuItem;
    Undo2: TMenuItem;
    Doubleclickoptions1: TMenuItem;
    Addentirelistandplayselected1: TMenuItem;
		Playselectedsong1: TMenuItem;
    Enqueselectedsong1: TMenuItem;
		Punchinselected1: TMenuItem;
    Switch1: TMenuItem;
    ArtistTitle1: TMenuItem;
    ArtistAlbum1: TMenuItem;
    AlbumTitle1: TMenuItem;
    File1: TMenuItem;
		WriteId3v11: TMenuItem;
    WriteId3v21: TMenuItem;
		N19: TMenuItem;
		Onlyshowaviablefiles1: TMenuItem;
    Organizefiles2: TMenuItem;
    Cuttag1: TMenuItem;
    N23: TMenuItem;
    mniWriteAllSupportedTags: TMenuItem;
    CDDB1: TMenuItem;
    DuplicateWizard1: TMenuItem;
    Compilation1: TMenuItem;
    Help1: TMenuItem;
    Winamp1: TMenuItem;
    ToggleWinamp1: TMenuItem;
    TogglePlaylist1: TMenuItem;
    ToggleEqulizer1: TMenuItem;
    ShowWinampPreferences1: TMenuItem;
    StartVISplugin1: TMenuItem;
    WPbarLow: TWApanel;
		FileInfoLabel: TLabel;
		winplaylistTimeLabel: TLabel;
		Scanforchanges1: TMenuItem;
    Editcolumnsequal1: TMenuItem;
		EditColumnSequalTimer: TTimer;
		ScanThread: TBMDThread;
    TabelAddtoquicklist1: TMenuItem;
    WinplaylistAddToQuicklist: TMenuItem;
    Partymode1: TMenuItem;
    AutosetKillafterplay1: TMenuItem;
    Previous1: TMenuItem;
    Play3: TMenuItem;
    Pause1: TMenuItem;
    Stop1: TMenuItem;
		Next1: TMenuItem;
    WinplaylistCurrentTimeLabel: TLabel;
    showMainFormTimer: TTimer;
    Databases1: TMenuItem;
    N24: TMenuItem;
    Playallsongsinselecteddatabase1: TMenuItem;
    Playallsongs1: TMenuItem;
    N25: TMenuItem;
    WPcolumnPopup: TPopupMenu;
    WinPlayScrollH: TWinampScrollVert;
    EnqueueDequeue1: TMenuItem;
    SaveDatabase1: TMenuItem;
    SkinFileFind: TJvSearchFiles;
    FileFind1: TJvSearchFiles;
    QuickListFF: TJvSearchFiles;
    DragFF: TJvSearchFiles;
    CreateFileListFF: TJvSearchFiles;
    FilesInSubdirCountFF: TJvSearchFiles;
    SpyFF: TJvSearchFiles;
    coverFF: TJvSearchFiles;
    coverThread: TBMDThread;
    ToggleMinibrowser1: TMenuItem;
    N26: TMenuItem;
    Removefromdatabase1: TMenuItem;
    Removeselectedfromdatabase1: TMenuItem;
    Selected1: TMenuItem;
    All1: TMenuItem;
    Savelist1: TMenuItem;
    All2: TMenuItem;
    SavetoHTMLimportablebyExcel1: TMenuItem;
    Addtoexistingplaylist1: TMenuItem;
    Addtonewplaylist1: TMenuItem;
    Selected2: TMenuItem;
    Addtoexistingplaylist2: TMenuItem;
    Addtonewplaylist2: TMenuItem;
    Icon2: TImage;
    Punchin4: TMenuItem;
    N18: TMenuItem;
    Explorer1: TMenuItem;
    Openinexplorer1: TMenuItem;
    tabelImages: TImageList;
    NextPopUp: TPopupMenu;
    StopPopup: TPopupMenu;
    PlayPopUp: TPopupMenu;
    PrevPopUp: TPopupMenu;
    Next2: TMenuItem;
    Fastforward5seconds1: TMenuItem;
    Endoflist1: TMenuItem;
    NextinMainlistAltClick1: TMenuItem;
    StopClick1: TMenuItem;
    StopwithFadeout1: TMenuItem;
    Stopaftercurrent1: TMenuItem;
    Playrestaart1: TMenuItem;
    OpenlocationShiftClick1: TMenuItem;
    OpenfileCtrlClick1: TMenuItem;
    PreviousClick1: TMenuItem;
    Revind5seconds1: TMenuItem;
    Startoflist1: TMenuItem;
    PreviousinMainlistAltClick1: TMenuItem;
    Repairquicklist1: TMenuItem;
    Shuffleselected1: TMenuItem;
    Enabled1: TMenuItem;
    N27: TMenuItem;
    frommainlist1: TMenuItem;
    randomfromcurrentdatabase1: TMenuItem;
    randomfromallavailabledatabases1: TMenuItem;
    randomfrommainlist1: TMenuItem;
    ToggleVideo1: TMenuItem;
    test1: TMenuItem;
    Rating1: TMenuItem;
    Notrated1: TMenuItem;
    N1Bad1: TMenuItem;
    N28: TMenuItem;
    N31: TMenuItem;
    N41: TMenuItem;
    N51: TMenuItem;
    lblMainListCount: TLabel;
    TimerUpdateLblMainlistCount: TTimer;
    imagesMenu: TImageList;
    Options1: TMenuItem;
    RemoveAutoScannedflag1: TMenuItem;
    Groups1: TMenuItem;
    N30: TMenuItem;
    Files1: TMenuItem;
    Trimtag1: TMenuItem;
    CDDBlookup1: TMenuItem;
    CoverLoadThread: TBMDThread;
    xml1: TMenuItem;
    N21: TMenuItem;
    Enqueue3: TMenuItem;
    Showcovers1: TMenuItem;
    TreeDropPopup: TPopupMenu;
    Add1: TMenuItem;
    Remove1: TMenuItem;
    Set1: TMenuItem;
    N29: TMenuItem;
    Cancel1: TMenuItem;
    N32: TMenuItem;
    Reloadcover1: TMenuItem;
    timTreeSelectionChanged: TTimer;
    test2: TMenuItem;
    Selectnone1: TMenuItem;
    LowerSmallPanel: TWApanel;
    imgLstCheckIcons: TImageList;
//    procedure searchChange(Sender: TObject);
		procedure Filenames1Click(Sender: TObject);
//    procedure Button3Click(Sender: TObject);
		procedure FormCreate(Sender: TObject);
		procedure CreateParams( var Params: TCreateParams ); override;
//    procedure exitbutClick(Sender: TObject);
    procedure Image1MouseDown(Sender: TObject; Button: TMouseButton;
			Shift: TShiftState; X, Y: Integer);
		procedure minimizeClick(Sender: TObject);
    procedure minibarDblClick(Sender: TObject);
		procedure configClick(Sender: TObject);
    procedure TabelDblClick(Sender: TObject);
		procedure slidertimerTimer(Sender: TObject);
    procedure sliderMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure sliderMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
//    procedure Exit1Click(Sender: TObject);
		procedure FormShow(Sender: TObject);
    procedure Generalconfiguration1Click(Sender: TObject);
    procedure Play1Click(Sender: TObject);
    procedure voldwnClick(Sender: TObject);
    procedure Addselected1Click(Sender: TObject);
		procedure Addall1Click(Sender: TObject);
		procedure Showplaylist1Click(Sender: TObject);
    procedure TabelMouseDown(Sender: TObject; Button: TMouseButton;
			Shift: TShiftState; X, Y: Integer);
		procedure WndProc(var Msg : TMessage); override;
		procedure HandleRemoteCall(const Msg: TMessage);
		procedure HandlePartyMode(const Msg: TMessage);
		Procedure HandleSkinSave;
    procedure ToggleSystrayIcon(toggle: Boolean);
    procedure SetSystrayIconToolTip(s: String);
		procedure nxtMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure prevMouseDown(Sender: TObject; Button: TMouseButton;
			Shift: TShiftState; X, Y: Integer);
    procedure FormResize(Sender: TObject);
		procedure PlayMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure StopMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure filtertimerTimer(Sender: TObject);
    procedure f0Change(Sender: TObject);
    procedure BitBtn1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure BitBtn4MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure aotClick(Sender: TObject);
		procedure SaveselectedinPlaylist1Click(Sender: TObject);
    procedure Deletefilefromharddisk1Click(Sender: TObject);
		procedure Selectall1Click(Sender: TObject);
    procedure Removeallfilters1Click(Sender: TObject);
    procedure FormActivate(Sender: TObject);
		procedure TabelKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
		procedure FormClose(Sender: TObject; var Action: TCloseAction);
		procedure lssPopup(Sender: TObject);
		procedure SearchInClick(Sender: TObject);
    procedure savess(Sender: TObject);
		procedure delss(Sender: TObject);
		procedure loadss(Sender: TObject);
    procedure n(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure BitBtn6MouseDown(Sender: TObject; Button: TMouseButton;
			Shift: TShiftState; X, Y: Integer);
    procedure Addselectedtonewplaylist1Click(Sender: TObject);
    procedure Playallsongsinthisfolder1Click(Sender: TObject);
		procedure treeMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Addlocation1Click(Sender: TObject);
    procedure filespopupPopup(Sender: TObject);
//    procedure Addto1Click(Sender: TObject);
		procedure plboxpopupPopup(Sender: TObject);
    procedure LoadinWinamp1Click(Sender: TObject);
    procedure playlistboxDblClick(Sender: TObject);
    procedure Deleteplaylist1Click(Sender: TObject);
    procedure Newplaylist1Click(Sender: TObject);
		procedure treepopPopup(Sender: TObject);
		procedure Deleteselecteddatabase1Click(Sender: TObject);
		procedure plconKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure Enqueallsongsinthisfolder1Click(Sender: TObject);
    procedure Updatetree1Click(Sender: TObject);
		procedure Collapseall1Click(Sender: TObject);
    procedure Expandall1Click(Sender: TObject);
		procedure Label1Click(Sender: TObject);
    procedure CollapseButtonClick(Sender: TObject);
    procedure AllButtonClick(Sender: TObject);
		procedure EnqueueinWinamp1Click(Sender: TObject);
    procedure treeKeyDown(Sender: TObject; var Key: Word;
     Shift: TShiftState);
    procedure playlistboxKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure f0KeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure treeKeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
		procedure treeEnter(Sender: TObject);
    procedure RenameQuicklist1Click(Sender: TObject);
    procedure CopyToMyMusic(Sender: TObject);
		procedure ShowTreewindow1Click(Sender: TObject);
    procedure MinimizeQ2Click(Sender: TObject);
    procedure SavetoHTML1Click(Sender: TObject);
    procedure CDEvents1AfterArrival(Sender: TObject);
    procedure Propertiesfor1Click(Sender: TObject);
    procedure plconDblClick(Sender: TObject);
		procedure Sort1Click(Sender: TObject);
    procedure Shuffle1Click(Sender: TObject);
    procedure MoveDown1Click(Sender: TObject);
		procedure MoveUp1Click(Sender: TObject);
    procedure Delete1Click(Sender: TObject);
    procedure imgrightMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure imgrightMouseUp(Sender: TObject; Button: TMouseButton;
			Shift: TShiftState; X, Y: Integer);
    procedure imgrightMouseMove(Sender: TObject; Shift: TShiftState; X,
			Y: Integer);
		procedure imgrightClick(Sender: TObject);
//		procedure Copyallfilestoadirectory1Click(Sender: TObject);
    procedure Playall1Click(Sender: TObject);
    procedure FormCanResize(Sender: TObject; var NewWidth,
			NewHeight: Integer; var Resize: Boolean);
		procedure Addalltoexistingplaylist1Click(Sender: TObject);
    procedure Addalltonewplaylist1Click(Sender: TObject);
    procedure UpdateID3tag1Click(Sender: TObject);
		procedure groupmenuPopup(Sender: TObject);
    procedure gmenuitem1Click(Sender: TObject);
		procedure gmenuitemInvertClick(Sender: TObject);
		procedure gmenuitemAndGroupClick(Sender: TObject);
    procedure grouplabelMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure Configgroups1Click(Sender: TObject);
    procedure MinimizeQ1Click(Sender: TObject);
    procedure winplaylistDblClick(Sender: TObject);
    procedure Showmedia1Click(Sender: TObject);
    procedure ShowArtistAlbum1Click(Sender: TObject);
		procedure columnpopupPopup(Sender: TObject);
		procedure columnpopupmenuClick(Sender: TObject);
    procedure WPcolumnpopupmenuClick(Sender: TObject);
		procedure ToggleAutoResizeColumnToFit(Sender: TObject);
		procedure ToggleHideInfoShownInTree(Sender: TObject);
    procedure MinimizeWinplayClick(Sender: TObject);
		procedure winplaylistKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure PopupMenu1Popup(Sender: TObject);
    procedure continuousPlay1Click(Sender: TObject);
    procedure Resetcounter1Click(Sender: TObject);
    procedure TopListPopPopup(Sender: TObject);
    procedure SelecttherootofthecurrentdatabaseCtrlR1Click(
			Sender: TObject);
    procedure StartSearch1Click(Sender: TObject);
		procedure autoresettabelTimer(Sender: TObject);
    procedure Rename1Click(Sender: TObject);
    procedure ConfigmenuPopup(Sender: TObject);
    procedure Mainlistfocused1Click(Sender: TObject);
    procedure TreeFocused1Click(Sender: TObject);
    procedure PlaylistFocused1Click(Sender: TObject);
		procedure QuicklistselectorFocused1Click(Sender: TObject);
    procedure QuicklistsongsFocused1Click(Sender: TObject);
    procedure Selectnoneshowalldatabases1Click(Sender: TObject);
		procedure CDEvents1AfterRemove(Sender: TObject;
			FirstDriveLetter: Char);
		procedure Refresh1Click(Sender: TObject);
		procedure autoresettreeTimer(Sender: TObject);
    procedure Delete2Click(Sender: TObject);
		procedure Moveup2Click(Sender: TObject);
    procedure Movedown2Click(Sender: TObject);
		procedure ByTitle1Click(Sender: TObject);
    procedure Byfilename1Click(Sender: TObject);
    procedure Bypathandfilename1Click(Sender: TObject);
    procedure Shuffle2Click(Sender: TObject);
		procedure max1Click(Sender: TObject);
    procedure jklMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Refresh2Click(Sender: TObject);
    procedure Refresh3Click(Sender: TObject);
		procedure sliderenableTimer(Sender: TObject);
    procedure filterbarMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Panel1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure plabel1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure plabel2MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure menuitembblclick1Click(Sender: TObject);
		procedure TreeStimerTimer(Sender: TObject);
    procedure SaveasQuicklist1Click(Sender: TObject);
    procedure TreeExchangeAristAlbumClick(Sender: TObject);
		procedure Edittag1Click(Sender: TObject);
		procedure Scanforduplicates1Click(Sender: TObject);
		procedure SortList1Click(Sender: TObject);
    procedure ToggleExpanded1Click(Sender: TObject);
    procedure Resetallfiles1Click(Sender: TObject);
		procedure sliderrMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure sliderrMouseMove(Sender: TObject; Shift: TShiftState; X,
			Y: Integer);
		procedure sliderrMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Changetracknumberto1231Click(Sender: TObject);
		procedure Organizefiles1Click(Sender: TObject);
    procedure Help1Click(Sender: TObject);
		procedure tabelInitNode(Sender: TBaseVirtualTree; ParentNode,
			Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates);
    procedure tabelGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
			Column: TColumnIndex; TextType: TVSTTextType; var Text: WideString);
 		procedure tabelPaintText(Sender: TBaseVirtualTree;
			const Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
      TextType: TVSTTextType);
    procedure treeInitNode(Sender: TBaseVirtualTree; ParentNode,
      Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates);
    procedure treeGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; TextType: TVSTTextType; var Text: WideString);
		procedure treeGetImageIndex(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
			var Ghosted: Boolean; var Index: Integer);
    procedure treePaintText(Sender: TBaseVirtualTree;
			const Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
			TextType: TVSTTextType);
		procedure treeIncrementalSearch(Sender: TBaseVirtualTree;
			Node: PVirtualNode; const Text: WideString; var Result: Integer);
    procedure treeEditing(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; var Allowed: Boolean);
		procedure treeNewText(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; Text: WideString);
		procedure WinPlayListGetText(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
			var Text: WideString);
    procedure WinPlayListPaintText(Sender: TBaseVirtualTree;
			const Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
      TextType: TVSTTextType);
		procedure FormDragOver(Sender, Source: TObject; X, Y: Integer;
      State: TDragState; var Accept: Boolean);
    procedure WinPlayListDragOver(Sender: TBaseVirtualTree;
			Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint;
      Mode: TDropMode; var Effect: Integer; var Accept: Boolean);
		procedure WinPlayListDragDrop(Sender: TBaseVirtualTree;
			Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
			Shift: TShiftState; Pt: TPoint; var Effect: Integer;
      Mode: TDropMode);
		procedure searchlabelClick(Sender: TObject);
    procedure treeDragAllowed(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; var Allowed: Boolean);
    procedure plconGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
			Column: TColumnIndex; TextType: TVSTTextType; var Text: WideString);
    procedure tabelCompareNodes(Sender: TBaseVirtualTree; Node1,
      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
    procedure treeCompareNodes(Sender: TBaseVirtualTree; Node1,
      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
		procedure treeSaveNode(Node: PVirtualNode; Stream: TStream; sortedCoverImgs: TList);
		procedure treeLoadNode(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Stream: TStream);
    procedure plconDragDrop(Sender: TBaseVirtualTree; Source: TObject;
			DataObject: IDataObject; Formats: TFormatArray; Shift: TShiftState;
      Pt: TPoint; var Effect: Integer; Mode: TDropMode);
    procedure plconDragAllowed(Sender: TBaseVirtualTree;
			Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
    procedure plconDragOver(Sender: TBaseVirtualTree; Source: TObject;
      Shift: TShiftState; State: TDragState; Pt: TPoint; Mode: TDropMode;
      var Effect: Integer; var Accept: Boolean);
    procedure treeDragOver(Sender: TBaseVirtualTree; Source: TObject;
      Shift: TShiftState; State: TDragState; Pt: TPoint; Mode: TDropMode;
			var Effect: Integer; var Accept: Boolean);
		procedure WinPlayListDragAllowed(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
		procedure treeDragDrop(Sender: TBaseVirtualTree; Source: TObject;
      DataObject: IDataObject; Formats: TFormatArray; Shift: TShiftState;
			Pt: TPoint; var Effect: Integer; Mode: TDropMode);
    procedure FormPaint(Sender: TObject);
//    procedure WinPlayListBeforePaint(Sender: TBaseVirtualTree;
//      Canvas: TCanvas);
//    procedure WinPlayListAfterPaint(Sender: TBaseVirtualTree;
//      Canvas: TCanvas);
    procedure playlistboxGetText(Sender: TBaseVirtualTree;
			Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
			var Text: WideString);
    procedure plconGetPopupMenu(Sender: TBaseVirtualTree;
			Node: PVirtualNode; Column: TColumnIndex; const P: TPoint;
			var AskParent: Boolean; var PopupMenu: TPopupMenu);
    procedure treeplbarMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure treeplbarMouseMove(Sender: TObject; Shift: TShiftState; X,
			Y: Integer);
		procedure treeplbarMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure plconbarMouseMove(Sender: TObject; Shift: TShiftState; X,
			Y: Integer);
		procedure plconbarMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure tabelDrawHeader(Sender: TVTHeader; Canvas: TCanvas;
      Column: TVirtualTreeColumn; R: TRect; Hover, Pressed: Boolean);
    procedure WPbarMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure WPbarMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure tabelpanellowCanResize(Sender: TObject; var NewWidth,
			NewHeight: Integer; var Resize: Boolean);
//		procedure QuitTimerTimer(Sender: TObject);
    procedure playlistboxDragAllowed(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
		procedure playlistboxChange(Sender: TBaseVirtualTree;
			Node: PVirtualNode);
    procedure tabelScroll(Sender: TBaseVirtualTree; DeltaX,
			DeltaY: Integer);
    procedure TabelScrollVScroll(Sender: TObject; SBcode, Param: Integer);
		procedure tabelResize(Sender: TObject);
    procedure TreeScrollVScroll(Sender: TObject; SBcode, Param: Integer);
		procedure treeScroll(Sender: TBaseVirtualTree; DeltaX,
      DeltaY: Integer);
    procedure WinPlayScrollVScroll(Sender: TObject; SBcode,
      Param: Integer);
		procedure WinPlayListScroll(Sender: TBaseVirtualTree; DeltaX,
			DeltaY: Integer);
		procedure TabelBarMouseMove(Sender: TObject; Shift: TShiftState; X,
			Y: Integer);
		procedure treeChange(Sender: TBaseVirtualTree; Node: PVirtualNode);
    procedure filterbarResize(Sender: TObject);
		procedure TabelBarMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure treepanelCanResize(Sender: TObject; var NewWidth,
      NewHeight: Integer; var Resize: Boolean);
    procedure TabelScrollHScroll(Sender: TObject; SBcode, Param: Integer);
		procedure tabelHeaderMouseUp(Sender: TVTHeader; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure PlaylistboxScrollVScroll(Sender: TObject; SBcode,
      Param: Integer);
		procedure plconScrollVScroll(Sender: TObject; SBcode, Param: Integer);
    procedure PLCONlabelMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure PLCONlabelMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure PLCONlabelMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure playlistboxDragOver(Sender: TBaseVirtualTree;
			Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint;
			Mode: TDropMode; var Effect: Integer; var Accept: Boolean);
		procedure playlistboxDragDrop(Sender: TBaseVirtualTree;
      Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
      Shift: TShiftState; Pt: TPoint; var Effect: Integer;
      Mode: TDropMode);
		procedure TreeScrollHScroll(Sender: TObject; SBcode, Param: Integer);
    procedure tabelDragOver(Sender: TBaseVirtualTree; Source: TObject;
      Shift: TShiftState; State: TDragState; Pt: TPoint; Mode: TDropMode;
			var Effect: Integer; var Accept: Boolean);
    procedure tabelDragDrop(Sender: TBaseVirtualTree; Source: TObject;
      DataObject: IDataObject; Formats: TFormatArray; Shift: TShiftState;
			Pt: TPoint; var Effect: Integer; Mode: TDropMode);
		procedure playlistboxCompareNodes(Sender: TBaseVirtualTree; Node1,
			Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
		procedure plConCompareNodes(Sender: TBaseVirtualTree; Node1,
      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
    procedure FormKeyPress(Sender: TObject; var Key: Char);
		procedure EditTagNewClick(Sender: TObject);
//    procedure tabelAfterCellPaint(Sender: TBaseVirtualTree;
//      Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
//			CellRect: TRect);
//    procedure GroupTing11Click(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure StopCoverThread;
//    procedure tabelGetUserClipboardFormats(Sender: TBaseVirtualTree;
//      var Formats: TFormatArray);
    procedure tabelRenderOLEData(Sender: TBaseVirtualTree;
			const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
      ForClipboard: Boolean; var Result: HRESULT);
{    procedure WinplaylistRenderOLEData(Sender: TBaseVirtualTree;
			const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
			ForClipboard: Boolean; var Result: HRESULT);
    procedure treeRenderOLEData(Sender: TBaseVirtualTree;
			const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
      ForClipboard: Boolean; var Result: HRESULT);
    procedure plConRenderOLEData(Sender: TBaseVirtualTree;
			const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
      ForClipboard: Boolean; var Result: HRESULT);
		procedure playlistboxRenderOLEData(Sender: TBaseVirtualTree;
      const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
      ForClipboard: Boolean; var Result: HRESULT);  }
    procedure tabelHeaderDraw(Sender: TVTHeader; Canvas: TCanvas;
      Column: TVirtualTreeColumn; R: TRect; Hover, Pressed: Boolean;
			DropMark: TVTDropMarkMode);
    procedure WinplaylistFreeNode(Sender: TBaseVirtualTree;
      Node: PVirtualNode);
    procedure playlistboxFreeNode(Sender: TBaseVirtualTree;
      Node: PVirtualNode);
    procedure plConFreeNode(Sender: TBaseVirtualTree; Node: PVirtualNode);
		procedure tabelGetUserClipboardFormats(Sender: TBaseVirtualTree;
      var Formats: TFormatEtcArray);
		procedure treeUpdating(Sender: TBaseVirtualTree;
			State: TVTUpdateState);
		procedure playlistboxScroll(Sender: TBaseVirtualTree; DeltaX,
      DeltaY: Integer);
		procedure plConScroll(Sender: TBaseVirtualTree; DeltaX,
			DeltaY: Integer);
		procedure treeAfterPaint(Sender: TBaseVirtualTree;
			TargetCanvas: TCanvas);
		procedure treeCollapsed(Sender: TBaseVirtualTree; Node: PVirtualNode);
    procedure tabelHeaderClick(Sender: TVTHeader; Column: TColumnIndex;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
		procedure Addplaylist1Click(Sender: TObject);
    procedure Enqueueandplay1Click(Sender: TObject);
		procedure Punchin3Click(Sender: TObject);
		procedure Punchinandplay2Click(Sender: TObject);
    procedure Findindatabase1Click(Sender: TObject);
    procedure JvDeviceChanged1DeviceArrived(Sender: TObject; Drive: Char);
    procedure JvDeviceChanged1DeviceRemoveCompleted(Sender: TObject;
      Drive: Char);
    procedure Clearall1Click(Sender: TObject);
		procedure Clearallbutplaying1Click(Sender: TObject);
		procedure ClearButtonMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure ClearSelected1Click(Sender: TObject);
    procedure Cropselected1Click(Sender: TObject);
		procedure Deletefromplaylist1Click(Sender: TObject);
    procedure Deleteplaylist2Click(Sender: TObject);
    procedure Cleardupes1Click(Sender: TObject);
		procedure Undo1Click(Sender: TObject);
		procedure WinplaypopPopup(Sender: TObject);
    procedure WinplaylistCompareNodes(Sender: TBaseVirtualTree; Node1,
      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
    procedure Edittag2Click(Sender: TObject);
		procedure DirSpyTimerTimer(Sender: TObject);
		procedure ToggleKill1Click(Sender: TObject);
		procedure AutoscanThreadExecute(Sender: TObject;
			Thread: TBMDExecuteThread; var Data: Pointer);
		procedure Ignoreduplicates1Click(Sender: TObject);
    procedure Closewinamp1Click(Sender: TObject);
    procedure Editcolumn1Click(Sender: TObject);
    procedure tabelNewText(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; NewText: WideString);
		procedure tabelEditing(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; var Allowed: Boolean);
		procedure threadShowMoveOptions(Sender: TBMDThread;
			Thread: TBMDExecuteThread; var Data: Pointer);
		procedure threadShowMoveError(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
		procedure treeFreeNode(Sender: TBaseVirtualTree; Node: PVirtualNode);
		procedure Undo2Click(Sender: TObject);
		procedure Addentirelistandplayselected1Click(Sender: TObject);
		procedure qlsongspopPopup(Sender: TObject);
		procedure ArtistTitle1Click(Sender: TObject);
    procedure ArtistAlbum1Click(Sender: TObject);
		procedure AlbumTitle1Click(Sender: TObject);
		procedure WriteId3v11Click(Sender: TObject);
    procedure WriteId3v21Click(Sender: TObject);
		procedure Onlyshowaviablefiles1Click(Sender: TObject);
    procedure f0KeyPress(Sender: TObject; var Key: Char);
    procedure Organizefiles2Click(Sender: TObject);
    procedure Cuttag1Click(Sender: TObject);
		procedure CDDB1Click(Sender: TObject);
		procedure FormShortCut(var Msg: TWMKey; var Handled: Boolean);
//    procedure ApplicationEvents1Message(var Msg: tagMSG;
//      var Handled: Boolean);
    procedure DuplicateWizard1Click(Sender: TObject);
    procedure Compilation1Click(Sender: TObject);
    procedure ToggleWinamp1Click(Sender: TObject);
		procedure TogglePlaylist1Click(Sender: TObject);
    procedure ToggleEqulizer1Click(Sender: TObject);
    procedure ShowWinampPreferences1Click(Sender: TObject);
    procedure StartVISplugin1Click(Sender: TObject);
    procedure WPbarLowResize(Sender: TObject);
		procedure Scanforchanges1Click(Sender: TObject);
		procedure RunAfterScanForChanges(Sender: TObject);
		procedure Editcolumnsequal1Click(Sender: TObject);
		procedure EditColumnSequalTimerTimer(Sender: TObject);
		procedure playlistboxPaintText(Sender: TBaseVirtualTree;
			const TargetCanvas: TCanvas; Node: PVirtualNode;
			Column: TColumnIndex; TextType: TVSTTextType);
    procedure plConPaintText(Sender: TBaseVirtualTree;
			const TargetCanvas: TCanvas; Node: PVirtualNode;
			Column: TColumnIndex; TextType: TVSTTextType);
		procedure ScanThreadExecute(Sender: TObject; Thread: TBMDExecuteThread;
      var Data: Pointer);
    procedure ScanThreadShowUsePlaylistDialog(Sender: TBMDThread;
			Thread: TBMDExecuteThread; var Data: Pointer);
    procedure ThreadShowMessage(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
		procedure DoBeforeScanSynced(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
		procedure DoAfterScanSynced(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
		procedure TreeScrollHGetImage(Sender: TObject; Horizontal: Boolean;
			index: Integer; out bitmap: TBitmap);
		procedure imglowerleftMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure FormMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,
			Y: Integer);
    procedure FormDblClick(Sender: TObject);

    procedure WriteSelectedTagsToFiles(id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmaOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption);

		procedure volbarPaint(Sender: TObject; Canvas: TCanvas);
		procedure sliderrPaint(Sender: TObject; Canvas: TCanvas);

    procedure prepareCurPlayText(paint, update: boolean);

    procedure FormMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
		procedure Partymode1Click(Sender: TObject);
		procedure AutosetKillafterplay1Click(Sender: TObject);
		procedure Previous1Click(Sender: TObject);
    procedure Play3Click(Sender: TObject);
    procedure Pause1Click(Sender: TObject);
    procedure Next1Click(Sender: TObject);
		procedure Stop1Click(Sender: TObject);
    procedure WinplaylistCurrentTimeLabelMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure treeFocusChanging(Sender: TBaseVirtualTree; OldNode,
			NewNode: PVirtualNode; OldColumn, NewColumn: TColumnIndex;
      var Allowed: Boolean);
    procedure treeChecked(Sender: TBaseVirtualTree; Node: PVirtualNode);
    procedure treeDblClick(Sender: TObject);
    procedure showMainFormTimerTimer(Sender: TObject);
		procedure WinplaylistResize(Sender: TObject);
    procedure Playallsongs1Click(Sender: TObject);
    procedure Playallsongsinselecteddatabase1Click(Sender: TObject);
    procedure plabel1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure plabel1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure treeKeyPress(Sender: TObject; var Key: Char);
    procedure WinplaylistHeaderDragged(Sender: TVTHeader;
      Column: TColumnIndex; OldPosition: Integer);
    procedure WPcolumnPopupPopup(Sender: TObject);
    procedure WinPlayScrollHScroll(Sender: TObject; SBcode,
      Param: Integer);
    procedure WinplaylistHeaderMouseUp(Sender: TVTHeader;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure EnqueueDequeue1Click(Sender: TObject);
    procedure LowerSmallPanelPaint(Sender: TObject; Canvas: TCanvas);
    procedure SaveDatabase1Click(Sender: TObject);
    procedure FileFind1Abort(Sender: TObject);
    procedure FileFind1FindFile(Sender: TObject; const AName: String);
    procedure coverThreadExecute(Sender: TObject;
      Thread: TBMDExecuteThread; var Data: Pointer);
    procedure ToggleMinibrowser1Click(Sender: TObject);
    procedure Removefromdatabase1Click(Sender: TObject);
    procedure Removeselectedfromdatabase1Click(Sender: TObject);
    procedure ScanShowScanMessage(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
    procedure UpdateTopImage(Sender: TBMDThread; Thread: TBMDExecuteThread);
    procedure removeFromTabel(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
{$ifdef MEXPBuilding}
		procedure N17Click(Sender: TObject);
{$endif MEXPBuilding}
    procedure Addtonewplaylist2Click(Sender: TObject);
    procedure Addtonewplaylist1Click(Sender: TObject);
    procedure Addtoexistingplaylist2Click(Sender: TObject);
    procedure Addtoexistingplaylist1Click(Sender: TObject);
    procedure SavetoHTMLimportablebyExcel1Click(Sender: TObject);
    procedure Punchin4Click(Sender: TObject);
    procedure tabelDragAllowed(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
    procedure Explorer1Click(Sender: TObject);
    procedure Openinexplorer1Click(Sender: TObject);
    procedure tabelGetImageIndex(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
      var Ghosted: Boolean; var ImageIndex: Integer);
    procedure PreviousClick1Click(Sender: TObject);
    procedure Revind5seconds1Click(Sender: TObject);
    procedure Startoflist1Click(Sender: TObject);
    procedure PreviousinMainlistAltClick1Click(Sender: TObject);
    procedure Playrestaart1Click(Sender: TObject);
    procedure OpenlocationShiftClick1Click(Sender: TObject);
    procedure OpenfileCtrlClick1Click(Sender: TObject);
    procedure StopClick1Click(Sender: TObject);
    procedure StopwithFadeout1Click(Sender: TObject);
    procedure Stopaftercurrent1Click(Sender: TObject);
    procedure Next2Click(Sender: TObject);
    procedure Fastforward5seconds1Click(Sender: TObject);
    procedure Endoflist1Click(Sender: TObject);
    procedure NextinMainlistAltClick1Click(Sender: TObject);
    procedure tabelGetPopupMenu(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex; const P: TPoint;
      var AskParent: Boolean; var PopupMenu: TPopupMenu);
    procedure tabelMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure tabelFocusChanging(Sender: TBaseVirtualTree; OldNode,
      NewNode: PVirtualNode; OldColumn, NewColumn: TColumnIndex;
      var Allowed: Boolean);
    procedure globalPopup(Sender: TObject);
    procedure Repairquicklist1Click(Sender: TObject);
    procedure Shuffleselected1Click(Sender: TObject);
    procedure WinplaylistHeaderClick(Sender: TVTHeader;
      Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
      Y: Integer);
    procedure frommainlist1Click(Sender: TObject);
    procedure randomfromcurrentdatabase1Click(Sender: TObject);
    procedure randomfromallavailabledatabases1Click(Sender: TObject);
    procedure randomfrommainlist1Click(Sender: TObject);
    procedure ToggleVideo1Click(Sender: TObject);
    procedure AskGroupDialog(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
    procedure tabelBeforeItemErase(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
      var ItemColor: TColor; var EraseAction: TItemEraseAction);
    procedure treeBeforeItemErase(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
      var ItemColor: TColor; var EraseAction: TItemEraseAction);
    procedure playlistboxBeforeItemErase(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
      var ItemColor: TColor; var EraseAction: TItemEraseAction);
    procedure plConBeforeItemErase(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
      var ItemColor: TColor; var EraseAction: TItemEraseAction);
    procedure WinplaylistBeforeItemErase(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
      var ItemColor: TColor; var EraseAction: TItemEraseAction);
    procedure test1Click(Sender: TObject);
    procedure WinplaylistBeforePaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas);
    procedure tabelBeforePaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas);
    procedure tabelAfterCellPaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
      CellRect: TRect);
    procedure tabelHotChange(Sender: TBaseVirtualTree; OldNode,
      NewNode: PVirtualNode);
    procedure tabelMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure WinplaylistAfterCellPaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
      CellRect: TRect);
    procedure WinplaylistHotChange(Sender: TBaseVirtualTree; OldNode,
      NewNode: PVirtualNode);
    procedure WinplaylistMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure WinplaylistMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure tabelHeaderMouseMove(Sender: TVTHeader; Shift: TShiftState;
      X, Y: Integer);
    procedure WinplaylistHeaderMouseMove(Sender: TVTHeader;
      Shift: TShiftState; X, Y: Integer);
    procedure TabelScrollHMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure Notrated1Click(Sender: TObject);
    procedure tabelChange(Sender: TBaseVirtualTree; Node: PVirtualNode);
    procedure TimerUpdateLblMainlistCountTimer(Sender: TObject);
    procedure RemoveAutoScannedflag1Click(Sender: TObject);
    procedure Groups1SubItemClick(Sender: TObject);
    procedure mniWriteAllSupportedTagsClick(Sender: TObject);
    procedure TabelScrollVMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure Trimtag1Click(Sender: TObject);
    procedure CDDBlookup1Click(Sender: TObject);
    procedure treeBeforePaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas);
    procedure playlistboxBeforePaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas);
    procedure plConBeforePaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas);
    procedure ClearPopupPopup(Sender: TObject);
    procedure WinPlayScrollHMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure WPbarLowMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure winplaylistTimeLabelMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure WinplaylistCurrentTimeLabelMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure FileInfoLabelMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure Label1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure ClearButtonMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure MinimizeWinplayMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure WinPlayScrollVMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure treeMeasureItem(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; var NodeHeight: Integer);
    procedure treeAfterCellPaint(Sender: TBaseVirtualTree;
      TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
      CellRect: TRect);
    procedure CoverLoadThreadExecute(Sender: TObject;
      Thread: TBMDExecuteThread; var Data: Pointer);
    procedure CoverLoaded(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
    procedure AfterAutoScanThread(Sender: TBMDThread;
      Thread: TBMDExecuteThread; var Data: Pointer);
    procedure Enqueue3Click(Sender: TObject);
    procedure Showcovers1Click(Sender: TObject);
    procedure treeGetNodeWidth(Sender: TBaseVirtualTree;
      HintCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
      var NodeWidth: Integer);
    procedure Set1Click(Sender: TObject);
    procedure Add1Click(Sender: TObject);
    procedure Remove1Click(Sender: TObject);
    procedure Cancel1Click(Sender: TObject);
    procedure TreeDropPopupPopup(Sender: TObject);
    procedure Reloadcover1Click(Sender: TObject);
    procedure tabelGetHint(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; var LineBreakStyle: TVTTooltipLineBreakStyle;
      var HintText: WideString);
    procedure treeGetHint(Sender: TBaseVirtualTree; Node: PVirtualNode;
      Column: TColumnIndex; var LineBreakStyle: TVTTooltipLineBreakStyle;
      var HintText: WideString);
    procedure timTreeSelectionChangedTimer(Sender: TObject);
    procedure WinplaylistGetHint(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex;
      var LineBreakStyle: TVTTooltipLineBreakStyle;
      var HintText: WideString);
    procedure Selectnone1Click(Sender: TObject);
    procedure test2Click(Sender: TObject);
    procedure treeChecking(Sender: TBaseVirtualTree; Node: PVirtualNode;
      var NewState: TCheckState; var Allowed: Boolean);
    procedure tabelFocusChanged(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex);
    procedure WinplaylistFocusChanged(Sender: TBaseVirtualTree;
      Node: PVirtualNode; Column: TColumnIndex);

private
 { Private declarations }
	  fCoverImgs: TList;
    fTreeCoverWidth: integer;
    fTreeCoverHeight: integer;
    fTreeCoverBorder: integer;
    fCoverRecRW, fCoverImgsRW: TMultiReadExclusiveWriteSynchronizer;	//fCoverImgsRW is the list when the count is either read or changed
    fCoverLoadPriority: Cardinal;

    fTreeDropMenuClosed: Boolean;

 		tabelMouseRightMouseButtonDown: Boolean;

		TopImagePainting: Boolean;

		ScrollBarImgs: array[1..12] of TBitmap;
		FWriteToFileTestPlaying: Boolean;
		FWriteToFileTestPlayingCode: Integer;
		FWriteToFileTestPlayingTime: Cardinal;

    ChangedDirsToAutoScan: TStrings;
    ChangedDirsToAutoScanLock: TCriticalSection;

		tabelCurrentColumn:integer;
		tabelEditting, SequelTabelEditting:boolean;
		TopImageBuffer:TBitmap;
		TempCanvas: TBitmap;
		TopImageText : String;
    FoldPosi : LongInt;
    FcurPlay : String;
    FThumbTrackVisible: Boolean;

    FHotNodeBoldRating: array[0..1] of Boolean;
    FHotRatingNode: array[0..1] of PVirtualNode;
    FHotNoteRatingValue: array[0..1] of byte;
    FStarFontSize: array[0..2] of Integer;	//tabel, winplaylist, tree

    WinampPlaylistFiles:TThreeStrings;

		TimeViewMode: Byte;
		WinPlayListTimeUntilPlayingNode, WinPlayListTimeTotal: int64;
		CurrentPlayingIndex: Cardinal;

		CurrentPlayPos : Integer;	//bruges i doSliderTimerTimer
		PlayingSongPlayCountIncreased: Boolean; 	//bruges i doSliderTimerTimer

    //Skin database colors
    FSkinDbColors: Array[0..11] of TColor;

		//skin billeder:
		imgLowerRight: TBitmap;
		imglowerleft: TBitmap;
		imgLower: TBitmap;

		iUpLeft: TBitmap;
		iUpLeftShade: TBitmap;
		iUpRight: TBitmap;
		iUpRightShade: TBitmap;
		iUp: TBitmap;
		iUpShade: TBitmap;
		iUpBlank: TBitmap;

		iArc: TBitmap;
		iArcShade: TBitmap;

		imgLeft: TBitmap;
		imgRight: TBitmap;

		imgVolSliderBtn: TBitmap;

		imgSlider: TBitmap;
		imgSliderBtn: TBitmap;

		imgRepeat: TBitmap;
		imgShuffle: TBitmap;

		imgConfig: TBitmap;

		PositionSliderBuffer: TBitmap;

		TimeAtAutoFocusPlayingNodeInWinplaylist: Cardinal;

//    procedure MySaveToTree(tree: TVirtualStringTree; Str: TStream);

		procedure ReleaseAndDisposeCoverRecs(deleteThumbnail, removeFromTree: boolean);
    procedure DisposeCoverRec(cr: PCoverRec; deleteThumbnail: boolean);
    procedure UnloadCoverRec(cr: PCoverRec; deleteThumbnail: boolean);

    function CanLoadCoverThumbnail(cr: PCoverRec): boolean;
    function LoadCoverThumbnail(cr: PCoverRec): boolean;

		procedure PlayWinamp;

    procedure OnTreeSelectionChanged;
    function GetTreeText(tree: TVirtualStringTree; Node: PVirtualNode):WideString;

//    procedure FixCoverImgsList;
    procedure DrawStars(sender: TVirtualStringTreeEx; TargetCanvas: TCanvas; Node: PVirtualNode; CellRect: TRect; rec: PRec);
    procedure ToggleDummies(Tree: TBaseVirtualTree);
		Procedure WMEraseBkGnd( Var msg: TWMEraseBkGnd ); message WM_ERASEBKGND;
		procedure doPaintForm(clientWidth: Integer; clientHeight: Integer);
		function CheckPopUpMenuFromKey(Sender: TObject; PopupMenu: TPopUpMenu; var Key: Word; Shift: TShiftState):Boolean;
		procedure FillAddToSubMenu(parentMI: TMenuItem);
		procedure AddToMIClicked(Sender: TObject);
		Function GetWinplayPlaying:PVirtualNode;
		procedure doSliderTimerTimer(playingNode:PVirtualNode);
		procedure UpdateCurrentTimeLabel(const UsePercent: Boolean; const Percent: Double=0);
		Procedure TreeFilter;
    Procedure updwinplaylist;
    Procedure doUpdwinplaylist(count:cardinal);
    Procedure doUpdwinplaylistMEXPControlPlaylist(count:cardinal);
		function  globalshortcuthandle(key:Word; shift:Tshiftstate):boolean;
    Procedure createcolumns;
		procedure updateplaylistbox;
		procedure updateplaylist;
		procedure ApplyFilter(ScrollToTop: Boolean = true);
    procedure SetFilterFlags;
		Procedure Checkdrives(CheckIfPlaylistsExists :boolean);
    procedure UpdateTreeExistsFlag(checkIfPlaylistsExists :boolean);
    Function TabelSelCount : Integer;
    Procedure MakeFtreePath;

    Function FilterRec(Rec:Prec; onlyFilterTree:boolean=false):boolean;
    function TextInFields(rec: prec; const s:String): boolean;
    function PosTextInListNorm(rec:PRec):boolean;
    function PosTextInListAdd(rec:Prec):boolean;
    function PosTextInListExclude(rec:Prec):boolean;
    function PosTextInListWholeWord(rec:PRec):boolean;

    Function WinplaylistChanged(const realPlayFilename: String=''):Boolean;
    procedure CleanDoubles;
		procedure PaintSlider(percent:double; Visible, SliderVisible:Boolean; keepCurrentPosition:boolean=false);
    procedure RemoveConplay;
    function QuicklistExists(const name: String):Boolean;
		function HasSupportedExtension(const fn:String; SupportedAudioFiles:Boolean; audioFiles:Boolean; playlists:boolean):boolean;
		Function doGetDropFiles(Sender: TBaseVirtualTree;
						 Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
						 Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode; const FilenamesList:TStringList):Boolean;

    Function GetDropFiles(Sender: TBaseVirtualTree;
						 Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
             Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode; const plstRecList:TList):Boolean;

  procedure RemoveRecsFromDB(list: TList);
  procedure SortCoverImgs;
  function findRightFile(fn: String):pointer;
  procedure ShuffleWinplay(onlySelected: boolean=false);

	procedure updateTopImageBuffer;
  procedure FixRatingPainting(tree: TVirtualStringTree);
	function canCopyToMyMusic:boolean;

  procedure WaitForAutoScan;

	procedure AutoResizeAllColumnsToFit;
	procedure ProcessTextLength(const canvas: TCanvas; const rec: PRec; const ColumnTags: array of Integer; var TextLengths: array of Integer; const ColumnTagsLength, CharWidth: Integer);

  procedure UpdateLblMainListCount;
	procedure UpdateWinplaylistTimeLabel;
	procedure PaintPlayingTimeLabel(const extraTime: int64);
	procedure PaintFileInfoLabel;

	procedure SwitchMaximized;

	procedure WindowShadeClicked;

	procedure RepaintTopImage;

	procedure CMMenuClosed( var msg: TWMMenuSelect );    message CM_MENUCLOSED;

	procedure WinplaylistFocusPlayingNode;

  Function GetDatabaseColor(dbindex: integer): TColor;

	public
		{ Public declarations }
		TabelSelTextColor, TreeSelTextColor, Winplayingcolor, WinKillcolor, F0TExtColor, PlaylistboxSelTextColor, plconSelTextColor, winplaylistSelTextColor, CaptionStatusTextColor, TimerColor : TColor;
		TabelOddRowColor, TreeOddRowColor, WinplaylistOddRowColor, QuicklistOddRowColor, QuicklistContentOddRowColor: TColor;
    FSkinMainlistColorStarBright, FSkinMainlistColorStarDark, FSkinWinplaylistColorStarBright, FSkinWinplaylistColorStarDark,
    	FSkinTreeColorStarBright, FSkinTreeColorStarDark: TColor;
		ShuffleImgPos, RepeatImgPos, VolbarImgPos, ConfigImgPos: TPoint;
		VolbarWidth: integer;
		PosSliderLrgPos, PosSliderSmallPos: TPoint;
		PosSliderLrgStopFromEnd, PosSliderSmallStopFromEnd: Integer;
		PrevRect, PlayRect, PauseRect, StopRect, NextRect: TRect;
		MouseDownSpot : TPoint;
		Capturing, WinplayCanUndo, RepeatEnabled, ShuffleEnabled, ConfigImageShown : boolean;
		fFiltertree,filterstrings, FilterPL,fOnlyPL, fOldOnlyPL, fInvertGroups2, FInvertGroupsChecked, FGroupSelectedInTree, fAndGroups, appactivated, AutoScanInProcess, QueSpyScan : Boolean;
    SafeToAutoScanCount: Integer;
    FPaintedVolume: single;

		FTreePath, FNorm, FAdd, Fsubst, FwholeWord:TQ_StringList;

    FArtistFilter, FAlbumFilter, FFilePathFilter, FGenreFilter : TMyTBits;

    FDeleteGroupsFromTagList, FIgnoreGroupList, FUseGroupInsteadList: TQ_StringList;
		WinplayUndoList, Fplaylist, fileUndoList : TList;

    WinampPlaylistJustChangedByMEXP: Boolean;
    WinampPlaylistJustChangedByMEXPrealPos: integer;

    TabelColumnsVisible: array of Boolean;

    FCurrentBackgroundImage: String;

    SliderTimerRunning: integer;
    FFilters: array of Boolean;

    FCurPlayText: String;
    FCurPlayRect: TRect;
    FCurPlayBitmap: TBitmap;
    FCurPlayXPos: DWord;
    FCurPlayScrolling: boolean;

    WinplaylistClickTime, MLClickTime: DWord;

		PartyModePassword: String;

    PartyModeHasHiddenWinamp: boolean;

    Resizing: boolean;	//is the MainForm resizing?

		deltaPlaylist, WinampPlaylistRealCount:integer;

    WPColumnArr : array of TColSave;
    WPRegularTextColumn: TColumnIndex;

    FMLSortedCol,FMLSortedCol1 : integer;
    FWPSortedCol,FWPSortedCol1 : integer;

    procedure SetTreeCoverSize(width, height, border: integer);

		Procedure LoadLanguageGUI;

		procedure SetMainFormVisible(show: Boolean);

    procedure WaitForSliderTimer(SetSliderTimerRunning: Boolean=true);

    procedure CopyFromRealWinampPlaylist;

    procedure ApplyTabelColumnsVisible;
    Procedure UpdateCustomFieldName(index: Integer);

    procedure SetWinplayColumns(forceUpdate: Boolean);
    procedure SaveWinPlayColumns;
    procedure SortWinplayColumnsToRightPosition;
    procedure CalculateWinplayTextColumn;

    procedure WinplayEnqueue(Node: PVirtualNode);
    procedure WinplayDequeue(Node: PVirtualNode);
    procedure ValidateWinplayEnqueue;

    procedure AdjustWinplaylistSongNoColumnWidth;
    procedure AdjustWinplaylistEnqueueNoColumnWidth(callAdjustWinplaySongNoColumnWidth: boolean = true);

    Function CheckConPlay(checkNext:boolean=false):boolean; //retunerer om den har ndret noget i winplaylist

		procedure DisablePartyMode;
		procedure EnablePartyMode(pass: String);
		procedure DisableTaskSwitch(enabled: Boolean);
		function GetMonitorRect(const form: TCustomForm):TRect;
		procedure forceRepaint(control:TControl);
		procedure WinampPlaylistBtnClicked;
		Function isPlayingInWinamp(const fn:string):Boolean;
		procedure KillDirSpys;
		procedure CreateDirSpys;
		procedure DirSpyTrigger(Sender: TObject; Dir: string; Actions: TJvChangeActions);
		function OkToAutoScan(const filename:string; CheckReclist:boolean=true):boolean;
		function FilenameIncomplete(const filename:string):boolean;
    Procedure RecListToTabel(BeginEndUpdate, LockReclist:boolean);
		procedure MoveAddRecListToReclist;
		procedure InitDB;
		Procedure TabelToRecList;
    procedure FixAudioTypesSortOrder;
    procedure CopyAudioType(fromIndex, toIndex: Integer);
    procedure RemoveAudioType(index: Integer);
		Function ShowAform:Boolean;
		Procedure WinPlaySave(PlayPos:integer=-1);
		Function GetWinplayFilename(PL:Pointer):string;
    procedure CheckBrainPlay;
		Function ValidateWinplaylist(playPos:integer; const playingNode: PVirtualNode=nil):integer;
		Function doValidateWinplaylist(playPos:integer; var files:TThreeStrings; playingNode: PVirtualNode=nil):integer;
		Procedure WinPlaySaveToFile(const Filename:String;Run:Boolean=false; PlayPos:integer=-1);
		procedure InsertFileToWinampPlaylist(const fn:String);
		function GetKill: Byte;
		function PlConToWinPlaylist(const pPC:Pointer; const targetNode:PVirtualNode; const IM:TVTNodeAttachMode):PVirtualNode;
		procedure StopAndPlayFirst;
		procedure WinampPlaylistPlaySong(const index: Integer); overload;
		procedure WinampPlaylistPlaySong(const aNode: PVirtualNode); overload;
		Function plCOnAdd(p:pointer):PVirtualNode;
    Function plCONInsert(p:pointer; Node :PvirtualNode; IM:TVTNodeAttachMode):PVirtualNode;
    Function plCONInsertFname(const fName:String; Node :PvirtualNode; IM:TVTNodeAttachMode; FindInDB:Boolean=true):PVirtualNode;
    Function AllowedToAddMoreSongsToPlaylist: Boolean;
		Function WinplayAdd(rec: PRec; kill:byte; checkDupes:boolean=true):PVirtualNode;
		Function WinplayInsert(rec: PRec; Node :PvirtualNode; IM:TVTNodeAttachMode; kill:byte; checkDupes:boolean=true):PVirtualNode;
    Function WinplayFindRef(rec: PRec):PVirtualNode;
		Function WinplayInsertFname(const fName:String; Node :PvirtualNode; IM:TVTNodeAttachMode; kill:byte; FindInDB:Boolean=true; checkDupes:boolean=true):PVirtualNode;
		Function GetRec(const node:PVirtualNode):PRec;
		Procedure SetRec(const node:PVirtualNode; const p:pointer);
    Function CutBS(const s:String):String;
//    Function FilterNodeTreeOnly(const RP:Pointer):boolean;
    Function GetFTextP(const rec:PRec; const Field:integer):String; overload;
    Procedure GetFTextP(const rec:PRec; const Field:integer; var result:WideString); overload;
    Function GetScanPath(const P:Pointer):String;
    //SET metoder, husk bde at gennemlbe reclist og AddReclist!
    Function GetArtistID(const artist:string):integer;
    Function SameArtistAndArtistSortOrder(const rec: PRec): Boolean;
    Function SetArtist(const rec:PRec; const artist:string):integer;  overload;
    Function SetArtist(const rec:PRec; const artist, artistSortOrder:string):integer; overload;
    Function SetArtistSortOrder(const rec:PRec; const artistSortOrder:string):integer;
    Function GetAlbumID(const s:string):integer;
    Function SetFpath(const s:string):integer;

    Function SetPartOfSetFromString(var PartOfSet: Byte; const value: String): Boolean; overload;
    Function SetPartOfSetFromString(rec: PRec; const value: String): Boolean; overload;

    Procedure SetPartOfSet(var PartOfSet: Byte; value: Byte); overload;
    Procedure SetPartOfSet(rec: PRec; value: Byte); overload;

    Procedure SetTotalParts(var PartOfSet: Byte; value: Byte); overload;
    Procedure SetTotalParts(rec: PRec; value: Byte); overload;

    Function GetPartOfSet(PartOfSet: Byte): Byte;	overload;
    Function GetPartOfSet(rec: PRec): Byte; overload;

    Function GetTotalParts(PartOfSet: Byte): Byte;	overload;
    Function GetTotalParts(rec: PRec): Byte; overload;

    function GetPartsString(part, totalParts: Integer): String; overload;
    function GetPartsString(rec: Prec): String; overload;
    function GetPartsString(bt: byte): String; overload;

    //EO SET metoder
    procedure CleanLists;
    Function LocateDBname(const name:string):integer;
    procedure AfterTagChanged;
		Function ReadID3(Thread: TBMDExecuteThread; repairVBR: Boolean; const ScanPath, filename:string; master:integer; var audioType:byte; var addQuality:word; var artist, ArtistSortOrder, title, Album, Comment : string; var PartOfSet, rating: Byte; var year, Track, TotalTracks, kbps, Channels: integer; var duration : Cardinal; var Flags:TRecFlags; var Fsize:Cardinal; var CRC:LongWord; var freq:integer; {var CreateTime:TDateTime;} var LastWriteTime:Integer; calculateCRC: boolean; out coverRec: PCoverRec; NewRec:PRec=nil; changeGroups:boolean=true; filenames:TQ_StringList=nil; playlistFiles:PPlaylistFiles = nil): boolean; overload;
		Function ReadID3(Thread: TBMDExecuteThread; const filename:String; const scanPath:String; master:integer; DBindex:integer; Rec:PRec; changeGroups:boolean=true; filenames:TQ_StringList=nil):boolean; overload;
    Function SetCustomFieldData(rec: PRec; FieldIndex: Integer; const Data: String): Boolean;
//    procedure ProcessId3v2Pictures(const filename: string; artist, album: integer; id3v2: TMyID3Controller);
//    function CoverCrcExists(crc: LongWord): boolean;
//    function FindCoverRec(artist, album, dbindex: integer): PCoverRec;
    procedure AddCoverRecToList(cr: PCoverRec; recToAssignToSourceRec: PRec);
//		procedure AddCoverFromTagToDatabase(artist, album: integer; image:TStream; mime: string; crc: LongWord);
//    Procedure UpdateScanLabel(master:integer; const  s:string);
    Function GetAudioType(const filename:String; var index:byte):boolean;
    procedure SaveTree(tree: TVirtualStringTree; Stream: TStream);
    procedure LoadTree(tree: TVirtualStringTree; Stream: TStream);
		Procedure Updatetree(skipCheckDrives: boolean);
		procedure UpdateTreeGroups;
//    Procedure updatelocationnames;
		Function  Getkey(name : string) : Integer;
		procedure SetSlidersAndPanelFonts;
		Procedure LoadSkin(const index: Integer; OldIndex: Integer = -1);
  	Function LoadSkinProperties(const skinFileName: String; var Author, AuthorURL, CorrespondTo, CorrespondToURL, Comments: String): Boolean;
		Procedure CheckAutoSkin;
		function SupportedSkinFileVersion(fv: Word):Boolean;
    procedure CheckBackgroundImage;
		Procedure SaveFontColorSettings(index: Integer);
		Procedure LoadFontColorSettings(index: Integer);
		Function GetFontColorSettingsFile(index: Integer): String;
		Procedure loadSettings;
    Procedure LoadColumnSettings;
		Procedure saveSettings(ReleaseResources: Boolean);
		procedure TrayIconClicked(forceToggle: boolean = false);
		function IsWinampMinimized: boolean;
    function FormPlacementValid(formRect: TRect):Boolean;
    function IsWinampVisible: boolean;
		procedure Scan(master:integer; name:string; parentThread: TBMDExecuteThread; onlyNew: Boolean; calculateCRC: boolean; repairVBR: Boolean; UpdateTreeAndTabel:boolean);
    Procedure StopScanning;
		procedure WMNCHitTest(var M: TWMNCHitTest); message wm_NCHitTest;
		Procedure Savedatabase(ReleaseResources: Boolean);
    procedure SaveAllNoRelease(onlySaveDB: Boolean);
		procedure SaveToDBS(Fstr:Tstream; Index:integer);
		procedure LoadToDBS(Fstr:Tstream; Index:integer; Version:integer; storeValues:boolean=true);
		Function LoadDB(Location:Integer; BeginEndUpdate:Boolean=TRUE):boolean;
    function HashedRecListIndexOf(rec: Prec): integer;
		Procedure ShowHideNodes;
    Procedure DoShowHideNodes(skipRecListToTabel: boolean);
		Procedure UnloadAndSaveAll(ReleaseResources: Boolean; BeginEndUpdate:Boolean);
		Procedure LoadAllDBs;
		function InputBoxx(const ACaption, APrompt: string; var Value: string; passwordField: Boolean = false): Boolean;
		Procedure ShowMessageX(APrompt: string); overload;
    Procedure ShowMessageX(APrompt: string; Align : TAlignment); overload;
    Procedure showProcessDlg(APrompt: string; maximum:integer;  ShowCancelButton:boolean; var form:TInputbox2);
		Function YesNoBoxx(const ACaption, APrompt, YesText, NoText: string; focused:integer): Boolean;
    Function YesNoBox3Btn(const ACaption, APrompt, but1, but2, but3: string; focused:integer): integer;
    Function RenameDialog(const ACaption, source:String; var target:string):TrenameReturn;
    Function GetDefaultTreeStructureIndex: Integer;
    Function GetPreDefinedTreeStructureFromIndex(index: Integer):PTreeStructure;
    Function GetTreeStructureFromIndex(index: Integer):PTreeStructure;
    Procedure setTreeViewModeMenuItem(SelectedIndex: Integer);
    Function GetPLboxFname(aNode:PVirtualNode):String;
    procedure doTabelCompareNodes(rec1, rec2:PRec; Column:integer; var Result: integer);
    procedure doWinplaylistCompareNodes(p1, p2:pointer; Column:integer; var Result: integer);
    Procedure UpdateVScroll(aScroll:TWinampScrollVert; aTree:TVirtualStringTree);
    Procedure UpdateHScroll(aScroll:TWinampScrollVert; aTree:TVirtualStringTree);
		Procedure UpdateTreeBounds(aTree:TBaseVirtualTree);
		procedure ResizeWinplaylistColumns(adjustEnqueueNoColumn: boolean=true);
    Procedure AdjustNodeHeight(aTree:TVirtualStringTree);
    Procedure SetRatingStarFontSize(sender: TVirtualStringTree);
    function GetTreeIndex(tree: TVirtualStringTree): Integer;
    Procedure CheckAllPositions;
    Procedure SavePLfromTabel;
		Procedure SuggestFromFilename(const Scanpath : String; const Filename : String; var Artist : String; var Title : String; var Album : String; var Track : Integer; const filenames:TQ_StringList; CheckIfValueIsCroppedFromFileName: Boolean; playlistFiles: PPlaylistFiles);
    Function GetGenreID(s:String):integer;
		Procedure CleanThisString(var S:String; doEverything:Boolean=false);
		Function CleanString(const s:String; doEverything:Boolean=false):String;
		function SetVolume(percent:single):Boolean;	//retunerer true hvis volumen er ndret
    function GetVolume:single;
//    Procedure ReleaseRec(const rec:Prec; deleteFromPlaylists:boolean); overload;
//    Procedure ReleaseRec(recs: TListSorted; deleteFromPlaylists:boolean; disposeAfterRelease: boolean); overload;
    Procedure ReleaseRecs(deleteFromPlaylists:boolean; disposeAfterRelease: boolean); overload;
		function FindInReclist(const fn:String):pointer;
		Procedure UpdateSearchBools;
		function GetYearAlbum(const rec: Prec): String;
		function getFileName(const S:string; includeExt:boolean=true):String;
		function getFilePath(const S:string):String; overload;
    function getFilePath(const p:pointer):String; overload;
		function getFileExt(const s:string):String;
    Function hasGenre(genreIndex:cardinal; p:pointer):boolean;
    Function HasGroup(const g:array of byte; groupIndex:integer):boolean;	overload;
    Function HasGroup(rec: PRec; groupIndex:integer):boolean;	Overload;
    function GroupFilter(rec: Prec; includeGroupsSelectedInTree: boolean):Boolean;
		Procedure DisposeRec(rec: Prec);
    Procedure DisposeCustomFieldEntryData(entry: TCustomFieldEntry);
    procedure RemoveCustomFieldEntry(rec: PRec; FieldIndex: Integer; FieldIsBeingDeleted: Boolean);
    Function UsePlaylistForTrackInfo(fname:string):boolean;   overload;
    Function UsePlaylistForTrackInfo(Ppl:pointer):boolean;    overload;
		Function GetPlayListRec(const fname:string):pointer;
		procedure ApplyPattern(var pattern: String; const artist, album, title, track, track0, year, artist1, album1, group, genre, pos, tpos: String);
		function CreateFilename(root, fname:string; appendRoot:boolean; overwrite:boolean=true):string;
		function FilenameFromPattern(p:pointer; pattern, rootPath:string):string; overload;
		function FilenameFromPattern(p:pointer; pattern, filename, ext, path:string):string; overload;
		function FilenameFromPattern(pattern, artist, album, title, track, year, group, genre, pos, tpos, filename, ext, path:string):string; overload;
		function FixFilename(const fname:string):string;
		function GetWinplaylistText(const aNode: PVirtualNode; const p: Pointer): String;
    Function UpdatePLcache(PplRecP:pointer; refresh:boolean=false):Boolean;
    Procedure RemoveFromPLcache(PplRecP:pointer; rec:Prec; updatePlaylistFile:boolean); //hvis rec er nil slettes alle refs
		procedure UpdateHashedReclist;
    Procedure AddToFPlaylist(TR:PTreeRec);
		procedure getDragRecs(aTree: TBaseVirtualTree; recs:TList);

    procedure UpdateRecValues(rec: PRec; values: TtagValues; updateTags: boolean); overload;
{main}procedure UpdateRecValues(rec: PRec; values: TtagValues; var errMsg: String; id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmaOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption); overload;
    procedure UpdateRecValues(rec: PRec; values: TtagValues; var errMsg: String; updateTags: boolean); overload;
		procedure UpdateRecValues(recs: TList; values: TtagValues; progressFormCaption: String; allowCancel:boolean; updateTags:boolean); overload;
//    procedure UpdateRecValues(recs: TList; values: TtagValues; progressFormCaption: String; allowCancel:boolean; id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmaOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption); overload;
    Function UpdateRecValues(recs: TList; valuesList: TList; rollbackValuesList: TList; progressBoxCaption: String; showCancelButton: boolean; updateTags:boolean): UpdateRecValuesResult; overload;
    Function UpdateRecValues(recs: TList; valuesList: TList; rollbackValuesList: TList; progressBoxCaption: String; showCancelButton: boolean; id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmaOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption): UpdateRecValuesResult; overload;

    Function GetDefaultUpdateTags: boolean;
    Function GetDefaultUpdateRecTagOption(updateTags: boolean; tagIdx: integer): UpdateRecTagOption;

    Function GetId3v2RatingFrameIndex(const FId3v2: TMyID3Controller): Integer; overload;
    Function GetId3v2RatingFrameIndex(const FId3v2: TMyID3Controller; var rating: byte): Integer; overload;
    Procedure SaveId3v2Rating(const FId3v2: TMyID3Controller; rating: byte);

    Function GetApeRatingTagIndex(const FApe: TApetag): Integer; overload;
    Function GetApeRatingTagIndex(const FApe: TApetag; var rating: byte): Integer; overload;
    Procedure SaveApeRating(const FApe: TApetag; rating: byte);

    Function GetOggRatingTagIndex(const FOgg: TOggVorbis; var rating: byte): Integer; overload;
    Function GetOggRatingTagIndex(const FOgg: TOggVorbis): Integer; overload;
    Procedure SaveOggRating(const FOgg: TOggVorbis; rating: byte);

    Function GetWMARatingTagIndex(const FWMA: TWMAFile): Integer; overload;
    Function GetWMARatingTagIndex(const FWMA: TWMAFile; var rating: byte): Integer; overload;
    Procedure SaveWMARating(const FWMA: TWMAFile; rating: byte);

  	Procedure SaveId3v2PrivateFrame(const FId3v2: TMyID3Controller; const rec: PRec);
		procedure SaveAPEprivateFrame(const FApe: TApeTag; const p: Pointer; saveGroups: Boolean =true);
		procedure SaveWMAprivateFrame(const FWMA: TWMAFILE; const p: Pointer; saveGroups: Boolean =true);
		procedure SaveOGGprivateFrame(const FOgg: TOggVorbis; const p: Pointer; saveGroups: Boolean =true);
		procedure AllRenderOLEData(Sender: TBaseVirtualTree;
                                       const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
                                       ForClipboard: Boolean; var Result: HRESULT);
    procedure SaveWinplayUndo;
		procedure doSaveWinplayUndo(list:Tlist);
    procedure WinplayUndo;
//    Procedure SetDirExists(index:integer; name:string);
		procedure restoreAOT;
		procedure disableAOT;

		Procedure UpdateSizesTreePanel(Obj : TObject);

		procedure BeginWriteToFile(pr: Pointer);
		procedure EndWriteToFile(pr: Pointer);

    function createOpUndo(opType:TopType; oldName, newName:String):pointer;
    procedure saveOpUndos(undoList:Tlist; fname:string);

    function LoadString(Fstr:TStream; length:integer):String;

    function showOpenDialog(title, defaultFile, initDir, filter:string; var filename:string):boolean;

    function ValidNode(aTree:TVirtualStringTree; Node:pointer):boolean;

    Function DirInAutoScanList(dir:string):boolean;
		function GetHint(rec: PRec):string;

		Function RefreshSkinArray: Integer; //retunerer index p valgte skin
		Function GetCurrentSkinFilename: String;

		function HasMexpPrivateFrame(FId3v2:TMyID3Controller; deleteFrame:boolean=false): boolean;

		function GetV2GenreString(p:pointer; version :TJvID3Version):String;

    function NodeBelongsToTree(Node: PVirtualNode; tree: TVirtualStringTree; flatList: Boolean):Boolean;

    function GetTrackString(rec: pointer): String; overload;
    function GetTrackString(track, totalTracks: Integer): String; overload;
    function GetTrackNo(const s: String): String;
    function GetTrackNoInt(s: String): Integer;
    function GetTotalTracks(const s: String): String;
    function GetTotalTracksInt(s: String): Integer;

    function Id3v1EqualsId3v2(const Fid3v1: TID3v1Tag; const FId3v2: TMyId3Controller): Boolean;

    function GetProxySettingsFromWinamp(var address: String; var port: Integer; var username: String; var password: String): Boolean;

    Procedure WriteStringToStream(const s: String; stream: TStream); overload;

//    procedure WriteString(Str: TStream; const s: String); overload;
//    procedure WriteString(Str: TStream; const p: PChar); overload;

    procedure ChangeGroupName(group: PGroupRec; newName: string);
end;

type
		TDirExistsThread = class(TThread)
	private
  	Fname:string;
   	Fpath:string;
   	FDbIndex:integer;
  	Procedure SetDirExists;
	protected
   	procedure Execute; override;
  public
   	constructor Create(name, path: string; DbIndex: integer);
	end;

Const
//	COVER_WIDTH = 200;
//  COVER_HEIGHT = 100;

  WM_UPDATE_TREE = WM_USER + 10;  // WParam = SkipCheckDrives

  StaticRecSizeWithoutCRC = 56;
  StaticRecSizeWithCRC = 60;

	ARROWUP = ' 5 ';
	ARROWDOWN = ' 6 ';

  DROPEFFECT_NONE   = 0;
  DROPEFFECT_COPY   = 1;
  DROPEFFECT_MOVE   = 2;
	DROPEFFECT_LINK   = 4;

	WH_KEYBOARD_LL=13;

	SmallWindowLimit = 440;
	WindowShadeHeight = 14;

//	VolumeBarWidth = 126;

var
	MainFormInstance: TMainForm;
	wasminimized, oldshowwin, rez, colrez, doneclear, DBinitiated : boolean;
	DBs:Array of Trec2;
	UpdTimer : DWord;
  WakeCoverThread: THandle;

	StatusText: array[1..3] of String;
implementation

uses prefernces, defs, delfiles, dbprefe, TagCutterUnit,
	 groupsunit, DubWiz, OrganizeFiles, NetDirTest, renameUnit, UndoListU, AskUsePlaylist, cddbUnit,
   LanguageConstants;

var
  coltabelcount :Integer;
  TreeS:String;
  curf:integer;
  filters:TQ_StringList;
  colsizing, dontfilter, rezborder, rez2, TreeScrollbarsNeedsUpdate:boolean;
  pm, p, c, normalsize, normalPos:Tpoint;
  beforemaximizepos : TRect;
  listpanelheight: integer;
  wpanelheight, SliderXpos, sliderMouseDownX:integer;
  slidermax: Int64;
  OLDsmChecked:boolean;
  winmaximized, winmaximizedBeforeParty, LoadingDBs:boolean;
  rowDragStart : integer;
  fTreeFilter: array of array of TTreeFilterRec;
  PartyHookId: HHOOK;
  PartyHookSet, AotBeforeParty: Boolean;

{$R *.DFM}

{procedure WriteString(Str: TStream; const s: String); overload;
const bt: byte = 255;
var
  size: integer;
begin
  size := length(s);
  if size > 65535 then size := 65535;

  if size < 255 then
  	Str.Write(size, 1)
  else
	begin
    Str.Write(bt, 1);
    Str.Write(size, 2)
  end;

  if size > 0 then
  	Str.Write(s[1], size)
end;

procedure WriteString(Str: TStream; const p: PChar); overload;
const bt: byte = 255;
var
  Size: integer;
begin
  Size := Q_PStrLen(p);

  if size > 65535 then size := 65535;

  if size < 255 then
  	Str.Write(size, 1)
  else
	begin
    Str.Write(bt, 1);
    Str.Write(size, 2)
  end;

  if size > 0 then
  	str.Write(p^, Size)
end;   }

procedure WriteString(Str: TStream; const s: String); overload;
var
  size: word;
begin
  size := Word(Min(65535, length(s)));
	Str.Write(size, 2);

  if size > 0 then
  	Str.Write(s[1], size)
end;

procedure WriteString(Str: TStream; const p: PChar); overload;
var
  Size: word;
begin
  Size := Word(Min(65535, Q_PStrLen(p)));
  Str.Write(size, 2);

  if size > 0 then
  	str.Write(p^, Size)
end;

function sortStringsByLength(List: TQ_StringList; Index1, Index2: Integer): Integer;
begin
	result := length(list.strings[index2]) - length(list.strings[index1])
end;

{function TMainForm.FindFilenameInSortedReclist(const S: string; var Index: Integer): Boolean;
//Ikke til at kalde direkte! brug FindInReclist i stedet
var
  L, H, I, C: Integer;
  pc: PChar;
begin
	Result := False;
  pc := PChar(s);
  L := 0;
	H := fSortedRecList.Count - 1;
  while L <= H do
  begin
    I := (L + H) shr 1;
		C := Q_PCompText(PPointerPCharRec(fSortedRecList.List^[i]).pc, pc);
    if C < 0 then
    	L := I + 1
    else
    begin
      H := I - 1;
      if C = 0 then
        Result := True
    end;
  end;
  Index := L;
end;      }

function TMainForm.HashedRecListIndexOf(rec: Prec): integer;
begin
	if not fHashedRecList.FindRec(rec, result) then
  	result := -1
end;

Procedure TMainForm.WriteStringToStream(const s: String; stream: TStream);
begin
	if length(s) > 0 then
  	stream.Write(s[1], length(s))
end;

procedure TMainForm.ApplyPattern(var pattern: String; const artist, album, title, track, track0, year, artist1, album1, group, genre, pos, tpos: String);
Function ReplaceTexts(const text: string): String;
begin
	result := Q_ReplaceText(text, '%artist%', artist);
	result := Q_ReplaceText(result, '%album%', album);
	result := Q_ReplaceText(result, '%title%', title);
	result := Q_ReplaceText(result, '%track%', track);
	result := Q_ReplaceText(result, '%track0%', track0);
	result := Q_ReplaceText(result, '%year%', year);
	result := Q_ReplaceText(result, '%artist1%', artist1);
	result := Q_ReplaceText(result, '%album1%', album1);
	result := Q_ReplaceText(result, '%group%', group);
  result := Q_ReplaceText(result, '%genre%', genre);
  result := Q_ReplaceText(result, '%pos%', pos);
  result := Q_ReplaceText(result, '%tpos%', tpos);

	//fjerner mellemrum mellem ' ? '
	result := Q_ReplaceText(result, ' ?', '?');
	result := Q_ReplaceText(result, '? ', '?');
	result := Q_ReplaceText(result, '?- ', '?');
	result := Q_ReplaceText(result, ' -?', '?');
	result := Q_ReplaceText(result, '?-', '?');
	result := Q_ReplaceText(result, '-?', '?');
	result := Q_ReplaceText(result, '?. ', '?');
	result := Q_ReplaceText(result, '?.', '?');
	result := Q_ReplaceText(result, ' .?', '?');
	result := Q_ReplaceText(result, '\?\', '\');

  Q_DeleteStr(result, '(?)');
  Q_DeleteStr(result, '[?]');
  Q_DeleteStr(result, '?');
end;

function FindChar(const text: String; charToFind: char; start, stop: integer): Integer;
var
	n, i: integer;          //Variable "n" keeps count of "<>"-sections.
begin
	n := 0;
  result := -1;
  for i:=start to stop do
  begin
    if text[i] = '<' then
      inc(n)
    else
    if text[i] = '>' then
      dec(n)
    else
    if (text[i] = charToFind) and (n = 0) then
    begin
      result := i;
      break
    end
  end;
end;

function ResolveCondition(const text: string): String;
var
	j: integer;
  part1, part2: String;
begin
	//Find OR
  j := Q_PosText(' OR ', text);
  if j > 0 then
  begin
	  //Get first part of the expression
	    part1 := Q_CopyRange(text, 1, j-1);
	    part1 := ResolveCondition(part1);

	    //Get second part of the expression
      part2 := Q_CopyFrom(text,j+4);
      part2 := ResolveCondition(part2);

      if (Length(part1) > 0) or (Length(part2) > 0) then
        result := 'TRUE'
      else
        result := ''
  end
  else
  begin
	  //Find AND
	  j := Q_PosText(' AND ', text);
	  if j > 0 then
	  begin
    //Get first part of the expression
    part1 := Q_CopyRange(text, 1, j-1);
    part1 := ResolveCondition(part1);

    //Get second part of the expression
    part2 := Q_CopyFrom(text,j+5);
    part2 := ResolveCondition(part2);

    if (Length(part1) > 0) and (Length(part2) > 0) then
    	result := 'TRUE'
    else
    	result := ''
    end
    else
    begin
      //Find operator
      j := Q_PosStr('!=', text);
      if j > 0 then
      begin
        if ReplaceTexts(Q_CopyRange(text, 1, j-1)) <> ReplaceTexts(Q_CopyFrom(text, j+2)) then
          result := 'TRUE'
        else
          result := ''
      end
      else
      begin
        j := Q_PosStr('=', text);
        if j > 0 then
        begin
          if ReplaceTexts(Q_CopyRange(text, 1, j-1)) = ReplaceTexts(Q_CopyFrom(text, j+1)) then
            result := 'TRUE'
          else
            result := ''
        end
        else
          result := ReplaceTexts(text)
      end
    end
  end
end;

Function Parse(const text: String): String;
var
	start, stop, i, m, o : integer;
  condition, ifValue, elseValue: string;
begin
	result := '';
  start := 1;
  while start <= length(text) do
  begin
  	if text[start] = '<' then
    begin
	    m := 0;

      //Search for '>'
      stop := -1;
		  for i := start+1 to length(text) do
      begin
      	if text[i] = '<' then
        	inc(m)
        else
        if text[i] = '>' then
        	if m = 0 then
          begin
          	stop := i;
            break;
          end
          else
          	dec(m)
      end;

      if stop > start then
      begin
        //	< -- > is found. Search for '?'
        m := Q_StrScan(text, '?', start);
        if m > 0 then
        begin
          //Get condition
          condition := Trim(Q_CopyRange(text, start+1, m-1));
          condition := ResolveCondition(condition);

          //Search for '|' between m and k. '|' will be stored in variable "o" if found
          o := FindChar(text, '|', m+1, stop-1);

          //Check if '|' is found. Otherwise there is no "ELSE" value.
          if o >= 0 then
          begin
            ifValue := Q_CopyRange(text, m+1, o-1);
            elseValue := Q_CopyRange(text, o+1, stop-1)
          end
          else
          begin
            ifValue := Q_CopyRange(text, m+1, stop-1);
            elseValue := ''
          end;

          ifValue := Parse(ifValue);
          elseValue := Parse(elseValue);

          if Length(Trim(condition)) > 0 then
            result := result + ifValue
          else
            result := result + elseValue;

          start := stop+1;
        end
        else
        begin
          // 	< -- > is found. '?' is not found!
          result := result + text[start];
	        inc(start)
        end
      end
      else
      begin
		  	result := result + text[start];
        inc(start)
      end
    end
    else
    begin
      result := result + text[start];
      inc(start)
    end
  end
end;

begin
	//%artist%\%album%\<%pos% ? CD %pos%|Album one\>%track0%. %title%

  pattern := Parse(pattern);

	pattern := Q_ReplaceText(pattern, '%artist%', artist);
	pattern := Q_ReplaceText(pattern, '%album%', album);
	pattern := Q_ReplaceText(pattern, '%title%', title);
	pattern := Q_ReplaceText(pattern, '%track%', track);
	pattern := Q_ReplaceText(pattern, '%track0%', track0);
	pattern := Q_ReplaceText(pattern, '%year%', year);
	pattern := Q_ReplaceText(pattern, '%artist1%', artist1);
	pattern := Q_ReplaceText(pattern, '%album1%', album1);
	pattern := Q_ReplaceText(pattern, '%group%', group);
  pattern := Q_ReplaceText(pattern, '%genre%', genre);
  pattern := Q_ReplaceText(pattern, '%pos%', pos);
  pattern := Q_ReplaceText(pattern, '%tpos%', tpos);

	//fjerner mellemrum mellem ' ? '
	pattern := Q_ReplaceText(pattern, ' ?', '?');
	pattern := Q_ReplaceText(pattern, '? ', '?');
	pattern := Q_ReplaceText(pattern, '?- ', '?');
	pattern := Q_ReplaceText(pattern, ' -?', '?');
	pattern := Q_ReplaceText(pattern, '?-', '?');
	pattern := Q_ReplaceText(pattern, '-?', '?');
	pattern := Q_ReplaceText(pattern, '?. ', '?');
	pattern := Q_ReplaceText(pattern, '?.', '?');
	pattern := Q_ReplaceText(pattern, ' .?', '?');
	pattern := Q_ReplaceText(pattern, '\?\', '\');

	pattern := Q_ReplaceText(pattern, '(?)', '');
	pattern := Q_ReplaceText(pattern, '[?]', '');

	pattern := Q_ReplaceText(pattern, '?', '');
end;

function TMainForm.FilenameFromPattern(p:pointer; pattern, rootPath:string):string; //overload;
var      ext, filename:string;
begin
     //har den trailing '\' er der tale om et bibliotek
     if (length(pattern)>1) and (pattern[length(pattern)] = '\') then
     begin   //bibliotek
          ext := '';
          filename := getFtextP(p, fFname)
     end else
     begin //fil
          ext := getFileExt(getFtextP(p, fFname));
          filename := ''
     end;
		 result := FilenameFromPattern(pattern, getFtextP(p, fArtist), getFtextP(p, falbum), getFtextP(p, fTitle), getFtextP(p, fTrack), getFtextP(p, fYear), getFtextP(p, fGroups), GetFTextP(p, FGenre), GetFTextP(p, FPartOfSet), GetFTextP(p, FTotalParts), filename, ext, rootPath)
end;

function TMainForm.FilenameFromPattern(p:pointer; pattern, filename, ext, path:string):string; //overload;
begin
		 result := FilenameFromPattern(pattern, getFtextP(p, fArtist), getFtextP(p, falbum), getFtextP(p, fTitle), getFtextP(p, fTrack), getFtextP(p, fYear), getFtextP(p, fGroups), GetFTextP(p, FGenre), GetFTextP(p, FPartOfSet), GetFTextP(p, FTotalParts), filename, ext, path)
end;

function TMainForm.FilenameFromPattern(pattern, artist, album, title, track, year, group, genre, pos, tpos, filename, ext, path:string):string; //overload
{ usage:
 Leave ext empty if no filename to be appended
 If the filename is known, and only the directory is to be found, leave the ext empty
}
var track0, artist1, album1 : string;
    leadingBS:Boolean;
begin
		 leadingBS := (length(pattern)>0) and (pattern[1]='\');

     if (length(pattern)>1) and (pattern[1] = '\') then
        Q_CutLeft(pattern, 1);
     if (length(path)>1) and (path[length(path)] <> '\') then
        path := path + '\';
     if (length(filename)=0) and (length(ext)>1) and (ext[1] <> '.') then
        ext := '.' + ext;

		 artist := FixFilename(artist);
		 if length(artist) = 0 then artist := '?';

		 album := FixFilename(album);
		 if length(album) = 0 then album := '?';

		 title := FixFilename(title);
		 if length(title) = 0 then title := '?';

		 track := FixFilename(track);
		 if length(track) = 0 then track := '?';

		 year := FixFilename(year);
		 if length(year) = 0 then year := '?';

		 group := FixFilename(group);
		 if length(group) = 0 then group := '?';

     genre := FixFilename(genre);
     if length(genre) = 0 then genre := '?';

     if length(pos) = 0 then pos := '?';
     if length(tpos) = 0 then tpos := '?';

		 track0 := track;
		 if Q_Isinteger(track0) and (length(track0)=1) then
				track0 := '0'+track0;

		 artist1 := artist[1];
		 album1 := album[1];

		 ApplyPattern(pattern, artist, album, title, track, track0, year, artist1, album1, group, genre, pos, tpos);

{		 pattern := Q_ReplaceText(pattern, '%artist%', artist);
		 pattern := Q_ReplaceText(pattern, '%album%', album);
		 pattern := Q_ReplaceText(pattern, '%title%', title);
		 pattern := Q_ReplaceText(pattern, '%track%', track);
		 pattern := Q_ReplaceText(pattern, '%track0%', track0);
		 pattern := Q_ReplaceText(pattern, '%year%', year);
		 pattern := Q_ReplaceText(pattern, '%artist1%', artist1);
		 pattern := Q_ReplaceText(pattern, '%album1%', album1);
		 pattern := Q_ReplaceText(pattern, '%group%', group);

		 //fjerner mellemrum mellem ' ? '
     pattern := Q_ReplaceText(pattern, ' ?', '?');
     pattern := Q_ReplaceText(pattern, '? ', '?');

		 pattern := Q_ReplaceText(pattern, '?- ', '?');
     pattern := Q_ReplaceText(pattern, ' -?', '?');
		 pattern := Q_ReplaceText(pattern, '?-', '?');
		 pattern := Q_ReplaceText(pattern, '-?', '?');
		 pattern := Q_ReplaceText(pattern, '?. ', '?');
     pattern := Q_ReplaceText(pattern, '?.', '?');
		 pattern := Q_ReplaceText(pattern, ' .?', '?');

		 pattern := Q_ReplaceText(pattern, '\?\', '\');

		 pattern := Q_ReplaceText(pattern, '(?)', '');
		 pattern := Q_ReplaceText(pattern, '[?]', '');

		 pattern := Q_ReplaceText(pattern, '?', '');  }

     //fjerner ..
     while Q_PosStr('..', pattern)>0 do
           pattern := Q_ReplaceStr(pattern, '..', '.');

     //fjerner leading '\'
     while not leadingBS and (length(pattern)>0) and (pattern[1]='\') do
           Q_CutLeft(pattern, 1);
     //fjerner trailing '\'
     if (length(pattern)>1) and (pattern[length(pattern)] <> '\') and (length(filename)>0) then
        pattern := pattern + '\' else
     if (length(pattern)>1) and (pattern[length(pattern)] = '\') and (length(filename)=0) then
        Q_CutRight(pattern, 1);

     if length(filename)>0 then
        result := path + pattern + filename
     else
         result := path + pattern + ext
end;

function TMainForm.FixFilename(const fname:string):string;
var      i:integer;
begin
     result := fName;
     for i:=1 to length(invalidFileChars) do
         Q_ReplaceChar(result, invalidFileChars[i], ' ');
     while (length(result)>0) and (result[length(result)]='.') do //fjerner punktummer efter navn
           Q_CutRight(result, 1);
     Q_TrimInPlace(result)
end;

function TMainForm.CreateFilename(root, fname:string; appendRoot:boolean; overwrite:boolean=true):string;
var      i:integer;
begin
     Q_TrimInPlace(root);
		 Q_TrimInPlace(fname);
     fName := FixFilename(fName);
     if length(root)>0 then if root[length(root)] <> '\' then root := root + '\';
     result := root + fname;
     if not overwrite then
     begin
					i:=1;
          while fileExists(result) do
          begin
               result := root + getFilename(fname, false) + '(' + inttostr(i) + ')' + getFileExt(fname);
//               result := root + fname + '(' + inttostr(i) + ')';
               inc(i)
          end
     end;
     if not appendRoot then result := getFileName(result)
end;

{// Hides all submenus where all childs are hidden
procedure FixPopupMenuItem(pm: TPopupMenu);
begin

end;

procedure FixPopupMenu(pm: TPopupMenu);
var
	mi: TMenuItem;
  i: Integer;
begin
	for i:=0 to pm.Items.Count-1 do
end;   }

function GetNextGroupCheckState(gcs: GroupCheckState): GroupCheckState;
begin

  case gcs of
    GroupCheckState_Unchecked: result := GroupCheckState_Checked;
    GroupCheckState_Checked: result := GroupCheckState_Exclude;
  else
      result := GroupCheckState_Unchecked
  end

end;

function HasVisibleChildren(mi: TMenuItem): Boolean;
var
	i:integer;
begin
	result := false;
  for i:=0 to mi.count-1 do
  	result := result or (mi.Items[i].Visible and not Q_SameStr(mi.items[i].caption, '-'))
end;

Procedure TMainForm.DisposeCustomFieldEntryData(entry: TCustomFieldEntry);
begin
	case PCustomField(FieldList.Items[entry.FieldIndex]).dataType of
  	0:
    begin
    	Finalize(PStringData(Entry.Data)^);
    	Dispose(PStringData(Entry.Data))
    end;
    1: Dispose(PIntegerData(Entry.Data));
    2: Dispose(PRealData(Entry.Data));
//    3: Dispose(PBoolData(Entry.Data));
  end
end;

procedure TMainForm.RemoveCustomFieldEntry(rec: PRec; FieldIndex: Integer; FieldIsBeingDeleted: Boolean);
var
	i, j: Integer;
begin
	i := 0;
  while i < length(rec.CustomFields) do
  begin
    if FieldIsBeingDeleted and (rec.CustomFields[i].FieldIndex > FieldIndex) then
    begin
    	Dec(rec.CustomFields[i].FieldIndex);
      Inc(i)
    end
    else
  	if rec.CustomFields[i].FieldIndex = FieldIndex then
    begin
    	DisposeCustomFieldEntryData(rec.CustomFields[i]);
    	for j:=i to length(rec.CustomFields) - 2 do
      	rec.CustomFields[j] := rec.CustomFields[j+1];

      SetLength(rec.CustomFields, length(rec.CustomFields) - 1)
    end
    else
    	Inc(i)
  end
end;

Procedure TMainForm.DisposeRec(rec: Prec);
var
	i: Integer;
begin
  if assigned(rec) then
  begin
     //custom fields
    for i:=0 to length(rec.CustomFields)-1 do
    	DisposeCustomFieldEntryData(rec.CustomFields[i]);

    StrDispose(rec.Fname);
    StrDispose(rec.Title);
    finalize(rec.CustomFields);
    finalize(rec.Groups);
    finalize(rec.Genre);

    finalize(rec^);
    dispose(rec)
  end
end;

{procedure TMainForm.UpdateSoundex(const P: Pointer);
procedure AddWords(rec: Prec; const words: String);
var
	start, stop: Integer;
begin
	start := 1;
  while start < length(words) do
  begin
  	SetLength(rec.SoundExValues, length(rec.SoundExValues)+1);
  	stop := Q_StrScan(words, ' ', start);
    if stop = 0 then
    	stop := length(words);
    rec.SoundExValues[length(rec.SoundExValues)-1] := SoundexWord(Q_CopyRange(words, start, stop));
    start := stop+1
  end
end;
var
	rec: Prec;
  s: String;
begin
	rec := p;
  SetLength(rec.SoundexValues, 0);
  AddWords(rec, GetFTextP(rec, FArtist));
  AddWords(rec, GetFTextP(rec, FTitle));
  AddWords(rec, GetFTextP(rec, FAlbum));
end;    }


Procedure TMainForm.LoadLanguageGUI;
begin
  //Columns
  with tabel.Header do
  begin
  	Columns[0].text := GetText(TXT_ColumnFile);
    Columns[1].text := GetText(TXT_ColumnArtist);
    Columns[2].text := GetText(TXT_ColumnTitle);
    Columns[3].text := GetText(TXT_ColumnAlbum);
    Columns[4].text := GetText(TXT_ColumnGenre);
    Columns[5].text := GetText(TXT_ColumnYear);
    Columns[6].text := GetText(TXT_ColumnComment);
    Columns[7].text := GetText(TXT_ColumnTrack);
    Columns[8].text := GetText(TXT_ColumnKbps);
    Columns[9].text := GetText(TXT_ColumnKhz);
    Columns[10].text := GetText(TXT_ColumnChannels);
    Columns[11].text := GetText(TXT_ColumnLength);
    Columns[12].text := GetText(TXT_ColumnFileSize);
    Columns[13].text := GetText(TXT_ColumnLocation);
    Columns[14].text := GetText(TXT_ColumnGroups);
    Columns[15].text := GetText(TXT_ColumnFilePath);
    Columns[16].text := GetText(TXT_ColumnFileName);
    Columns[17].text := GetText(TXT_ColumnQuality);
    Columns[18].text := GetText(TXT_ColumnType);
    Columns[19].text := GetText(TXT_ColumnAddedToDatabase);
    Columns[20].text := GetText(TXT_ColumnChanged);
    Columns[21].text := GetText(TXT_ColumnTags);
    Columns[22].text := GetText(TXT_ColumnLyrics);
    Columns[23].text := GetText(TXT_ColumnPartOfSet);
    Columns[24].Text := GetText(TXT_ColumnRating);
    Columns[25].Text := GetText(TXT_ColumnArtistSortOrder);
    Columns[26].Text := GetText(TXT_ColumnAutoScanned);
    Columns[27].Text := GetText(TXT_ColumnPlaycount);
  end;
//  for i:=0 to tabel.Header.Columns.Count-1 do
//  	tabel.Header.Columns[i].Text := GetText(50+i);

  LoadMenuLanguage(LanguageDir + CurrentLanguageFile);

  filterBar.Caption := GetText(TXT_guiMainList);
  label1.caption := ' ' + GetText(TXT_guiPlaylist);
  panel1.Caption := GetText(TXT_guiTree);
  pLabel1.Caption := ' ' + GetText(TXT_guiQuicklist);
  PLCONlabel.Caption := ' ' + GetText(TXT_guiQuicklistPLcon);
  CollapseButton.Caption := GetText(TXT_guiCollapseAll) + ' ';
  AllButton.Caption := '  ' + GetText(TXT_guiAll) + '   ';
  groupLabel.Caption := GetText(TXT_guiGroups) + ' ';
  ClearButton.Caption := ' ' + GetText(TXT_guiClear) + ' ';

  SearchLabel.Hint := GetText(TXT_SearchLabelHint);
  GroupLabel.Hint := GetText(TXT_GroupLabelHint);
  f0.Hint := GetText(TXT_f0Hint);
  MinimizeWinplay.Hint := GetText(TXT_MinimizeWinplayHint);
  ClearButton.Hint := GetText(TXT_ClearButtonHint);
  AllButton.Hint := GetText(TXT_AllButtonHint);
  CollapseButton.Hint := GetText(TXT_CollapseButtonHint);
  MinimizeQ2.Hint := GetText(TXT_MinimizeQ2Hint);
  MinimizeQ1.Hint := GetText(TXT_MinimizeQ1Hint);
  Changetracknumberto1231.Hint := GetText(TXT_ChangeTrackTo123Hint);


  //StatusText
  StatusText[1] := ' ' + GetText(TXT_Stopped);
  StatusText[2] := ' ' + GetText(TXT_Paused);
  StatusText[3] := ' ' + GetText(TXT_Playing);
end;

function TMainForm.showOpenDialog(title, defaultFile, initDir, filter:string; var filename:string):boolean;
begin
     OpenDlg.title := title;
     OpenDlg.InitialDir := initDir;
     OpenDlg.FileName := defaultFile;
     OpenDlg.Filter := filter;
     result := OpenDlg.execute;
     if result then
        filename := OpenDlg.filename
end;

function TMainForm.createOpUndo(opType:TopType; oldName, newName:String):pointer;
var      UR:PfileUndoRec;
begin
     new(UR);
     UR.opType := opType;
     UR.dt := now;
     UR.oldName := oldName;
     UR.newName := newName;
     result := UR
end;

procedure TMainForm.saveOpUndos(undoList:Tlist; fname:string);
{         format:
                 undoFileIdent    kun i starten af filen!
                 ---
                 total size:word = total size of the "record", excluding this word
                 opType:TopType
								 dateTime:TDateTime
                 stringLength:word
                 oldName:string
                 stringLength:word
                 newName:string}
function size(UR:PfileUndoRec):word;
begin
     result := (sizeOf(word)*2) + sizeOf(TopType) + sizeOf(TDateTime) + length(UR.oldName) + length(UR.newName)
end;
var       Fstr:Tstream;
          UR:PfileUndoRec;
          i:integer;
          w:word;
          s:string;
begin
     if undoList.Count>0 then
     begin
          if getFileAccess(fname, true, false) then //filen existerer, appender
             Fstr := TfileStream.Create(fname, fmOpenReadWrite or fmShareDenyWrite)
          else Fstr := TfileStream.Create(fname, fmCreate or fmShareDenyWrite);

          Fstr.Position := 0;
          if Fstr.Size = 0 then
             Fstr.Write(undoFileIdent[1], length(undoFileIdent))
          else
          begin
               //checker om filen er gyldig
               if Fstr.Size >= length(undoFileIdent) then
               begin
                    s := LoadString(fstr, length(undoFileIdent));
                    if not Q_SameText(s, undoFileIdent) then
                       Fstr.Size := 0
               end else Fstr.Size := 0
          end;
          //rykker til slutningen af filen
          Fstr.Position := Fstr.size;
          for i:=0 to undoList.count-1 do
          begin
               UR := undoList.Items[i];
               w := size(UR);
               Fstr.Write(w, sizeOf(w));
               Fstr.Write(UR.opType, sizeOf(UR.opType));
               Fstr.Write(UR.dt, SizeOf(UR.dt));
               w := length(UR.oldName);
               Fstr.Write(w, sizeOf(w));
               if w>0 then Fstr.Write(UR.oldName[1], w);
               w := length(UR.newName);
               Fstr.Write(w, sizeOf(w));
               if w>0 then Fstr.Write(UR.newName[1], w);
               dispose(UR)
          end;
          Fstr.free;
          undoList.Clear
     end
end;

procedure TMainForm.SaveWinplayUndo;
begin
	doSaveWinplayUndo(WinplayUndoList)
end;

procedure TMainForm.doSaveWinplayUndo(list:Tlist);
var
	aNode:PvirtualNode;
  WR:PplstRec;
  WUR:PplstUndoRec;
  i: Integer;
begin
	for i:=0 to list.Count-1 do
  	dispose(PplstUndoRec(list.items[i]));

  list.Clear;
  list.Capacity := winplaylist.RootNodeCount;

  aNode := winplaylist.GetFirst;
  while aNode <> nil do
  begin
    WR := winplaylist.GetNodeData(aNode);
    if WR.Rec <> nil then
    begin
      new(WUR);
      WUR.Playing := WR.Playing;
      WUR.Rec := WR.Rec;
      WUR.Kill := WR.Kill;
    	WUR.ShuffleValue := WR.ShuffleValue;
      WUR.EnqueueNo := WR.EnqueueNo;
      list.add(WUR)
    end;
    aNode := winplaylist.GetNext(aNode)
  end;
  list.Capacity := list.Count;
  WinplayCanUndo := true
end;

procedure TMainForm.WinplayUndo;
var       i:integer;
          WPU:Tlist;
          PR:PplstRec;
          PUR:PplstUndoRec;
begin
  if not WinplayCanUndo then
  	exit;

  //backup
  WPU := TList.create;
  doSaveWinplayUndo(WPU);
  //eo backup

  winplaylist.BeginUpdate;
  winplaylist.clear;
  for i:=0 to WinplayUndoList.count-1 do
  begin
    PUR := WinplayUndoList.Items[i];
    PR := Winplaylist.GetNodeData(WinplayAdd(PUR.Rec, PUR.kill, false));
    PR.Playing := PUR.Playing;
    dispose(PUR)
  end;

  WinplayUndoList.Count := WPU.Count;
  for i:=0 to WPU.Count-1 do
  	WinplayUndoList.items[i] := WPU[i];
  WPU.free;

  button4(hwnd_winamp);
  if continuousPlay1.checked then
  	CheckConPlay;
  WinPlaySave;
  winplaylist.endupdate
end;

Procedure TMainForm.LoadAllDBs;
var     i:integer;
begin
	LoadingDBs := true;

	for i:=0 to length(dbs)-1 do
		if not dbs[i].loaded then
			loadDB(i, false);

	LoadingDBs := false
end;

Function TMainForm.DirInAutoScanList(dir:string):boolean;
var      i:integer;
begin
	result := false;
  dir := cutBS(dir);
  for i:=0 to pref.AutoScanPaths.Items.Count-1 do
  	result := result or Q_SameText(cutBS(pref.AutoScanPaths.Items[i]), dir)
end;

Function TMainForm.RefreshSkinArray: Integer;
var
	i, baseIndex: Integer;
	Author, AuthorURL, CorrespondTo, CorrespondToURL, Comment: String;
	InUseFound: Boolean;
begin
  SkinFileFind.Files.Clear;
	SkinFileFind.RootDirectory := SkinDir;
	SkinFileFind.Search;

	baseIndex := 0;
	InUseFound := false;

	SetLength(SkinArray, 0);

	for i:=0 to SkinFileFind.Files.Count-1 do
		if LoadSkinProperties(SkinFileFind.Files.Strings[i], Author, AuthorURL, CorrespondTo, CorrespondToURL, Comment) then
		begin
			SetLength(SkinArray, Length(SkinArray)+1);

			SkinArray[length(SkinArray)-1].Filename := SkinFileFind.Files.Strings[i];
			SkinArray[length(SkinArray)-1].Name := getFileName(SkinFileFind.Files.Strings[i], false);
			SkinArray[length(SkinArray)-1].Author := Author;
      SkinArray[length(SkinArray)-1].AuthorUrl := AuthorURL;
			SkinArray[length(SkinArray)-1].Comment := Comment;
			SkinArray[length(SkinArray)-1].CorrespondTo := CorrespondTo;
      SkinArray[length(SkinArray)-1].CorrespondToURL := CorrespondToURL;
			SkinArray[length(SkinArray)-1].InUse := Q_SameText(CurrentSkin, SkinArray[length(SkinArray)-1].Name);
			if SkinArray[length(SkinArray)-1].InUse then
				result := length(SkinArray)-1;

			InUseFound := InUseFound or SkinArray[length(SkinArray)-1].InUse;

			if Q_SameText('Base', SkinArray[length(SkinArray)-1].Name) then
				BaseIndex := length(SkinArray)-1
		end;

	if not InUseFound and (BaseIndex < length(SkinArray)) then
	begin
		SkinArray[BaseIndex].InUse := true;
		CurrentSkin := SkinArray[BaseIndex].Name;
		LoadSkin(BaseIndex);
		SetSlidersAndPanelFonts;
		result := BaseIndex
	end else
	if not InUseFound and (BaseIndex >= length(SkinArray)) then
	begin
		//fejl! Der er ingen skins installeret!
		ShowmessageX(GetText(TXT_NoSkinsFound));
		result := -1;
		Application.Terminate
	end
end;

Function TMainForm.GetCurrentSkinFilename: String;
var
	i: Integer;
begin
	result := '';
	for i:=0 to length(SkinArray)-1 do
		if SkinArray[i].InUse then
			result := SkinArray[i].Filename
end;

Function TMainForm.UsePlaylistForTrackInfo(fname:string):boolean;    //overload
begin
	result := UsePlaylistForTrackInfo(GetPlayListRec(fname))
end;

Function TMainForm.UsePlaylistForTrackInfo(Ppl:pointer):boolean;    //overload
var      PLrec : PplRec;
begin
  PLrec := Ppl;
  result := false;
  if assigned(PLrec) then
  begin
    if PLrec.UseToSuggest = useToSuggest_use then
      result := true
    else
    if PLrec.UseToSuggest = useToSuggest_unDefined then
    begin
      if YesNoBoxx(GetText(TXT_UsePlaylistCaption), GetText(TXT_UsePlaylistText, [#13#13 + PLrec.filename + #13#13]), GetText(TXT_Yes), GetText(TXT_No), 1)
      	then PLrec.UseToSuggest := useToSuggest_use else PLrec.UseToSuggest := useToSuggest_notuse;
      result := UsePlaylistForTrackInfo(PLrec)
    end
  end
end;

Function TMainForm.GetPlayListRec(const fname:string):pointer;
var      i:integer;
begin
  result := nil;
  for i:=0 to m3uList.count-1 do
  	if Q_SameText(PplRec(m3uList.items[i]).Filename, fname) then
	  begin
	    result := m3uList.items[i];
	    break
	  end
end;

Function TMainForm.LoadDB(Location:Integer;BeginEndUpdate:Boolean=TRUE):Boolean;
Function LoadRecFromStream(Str:TStream; location, staticSize:integer; FV: cardinal):boolean;
Procedure ReadString(var s: String);	overload;
var
	Size : word;
begin
	Str.Read(Size, SizeOf(Size));
  SetLength(s, Size);
  if Size > 0 then
  	Str.Read(s[1], Size)
end;

Procedure ReadString(var p: PChar);	overload;
var
	Size : word;
begin
	Str.Read(Size, SizeOf(Size));

  if Size > 0 then
  begin
	  p := StrAlloc(Size+1);
    FillChar(p^, Size + 1, #0);
    Str.Read(p^, Size);
  end
end;

Function ValidRec(rec: Prec): Boolean;
begin
	result := (rec.Artist < Artistlist.Count) and (rec.ArtistSortOrder < Artistlist.Count) and (rec.Album < Albumlist.Count) and (rec.Fpath < FPathList.Count);
end;
var
	Size : word;
  i:integer;
  rec:Prec;
  recId: smallint;
  dt: TDateTime;
begin
	result := true;
  try
  	str.Read(recId, 2);
    if RecId <> FileRecIdent then
    begin
    	result := false;
      exit
    end;

    new(rec);
    fillChar(rec^, sizeOf(rec^), #0);

    case FV of
      7:
      begin
        str.Read(rec.Audiotype, 1);
        str.Read(rec.FPath, 4);
        str.Read(rec.Artist, 4);
        str.Read(rec.ArtistSortOrder, 4);
        str.Read(rec.Album, 4);
        str.Read(rec.Year, 2);
        str.Read(rec.Track, 1);
        str.Read(rec.TotalTracks, 1);
        str.Read(rec.Kbps, 2);
        str.Read(rec.Length, 4);
        str.Read(rec.addQuality, 2);
        str.Read(dt, 8);
        rec.LastWriteTime := DateTimeToFileDate(dt);
        str.Read(dt, 8);
        rec.DatabaseTime := DateTimeToFileDate(dt);
        str.Read(rec.Channels, 1);
        str.Read(rec.PlayCount, 2);
        str.Read(rec.FSize, 4);
        str.Read(rec.Khz, 2);
        str.Read(rec.Flags, 2);
        str.Read(rec.Rating, 1);
        str.Read(rec.PartOfSet, 1);

        if dbs[location].calculateCRC then
          str.Read(rec.CRC, 4)
      end;

      8:
      begin
			  str.Read(rec.FPath, 4);
        str.Read(rec.Artist, 4);
        str.Read(rec.ArtistSortOrder, 4);
        str.Read(rec.Album, 4);
        str.Read(rec.Year, 2);
        str.Read(rec.Kbps, 2);
        str.Read(rec.Track, 2);
        str.Read(rec.TotalTracks, 2);
        str.Read(rec.Audiotype, 1);
        str.Read(rec.Rating, 1);
        str.Read(rec.PartOfSet, 1);
        str.Read(rec.Channels, 1);
        str.Read(rec.Length, 4);
        str.Read(rec.addQuality, 2);
        str.Read(rec.Khz, 2);
        str.Read(rec.LastWriteTime, 4);
        str.Read(rec.DatabaseTime, 4);
        str.Read(rec.FSize, 4);
        str.Read(rec.PlayCount, 2);
        str.Read(rec.Flags, 2);

        if dbs[location].calculateCRC then
          str.Read(rec.CRC, 4)
      end;

      9:
      begin
        Str.Read(rec^, staticSize);
      end
    end;

    ReadString(rec.FName);

    ReadString(rec.Title);
    ReadString(rec.Comment);

    //Genres
    Str.Read(Size, sizeof(Size));
    setLength(rec^.Genre, Size);
    for i:=0 to Size-1 do
    	Str.Read(Rec^.Genre[i],SizeOf(Cardinal));

    //Groups
    Str.Read(Size, sizeof(Size));
    SetLength(rec^.Groups, Size);
    for i:=0 to Size-1 do
    	Str.Read(Rec^.Groups[i], SizeOf(Byte)); //skal vre sizeOf(Byte) !

    //Custom fields
    Str.Read(Size, SizeOf(Size));
    SetLength(rec^.CustomFields, Size);
    for i:=0 to Size-1 do
    begin
      Str.Read(rec^.CustomFields[i].FieldIndex, SizeOf(Byte));
      Case PCustomField(FieldList.Items[rec^.CustomFields[i].FieldIndex]).DataType of
        0:
        begin
          new(PStringData(rec^.CustomFields[i].data));
          ReadString(PStringData(rec^.CustomFields[i].data).Value)
        end;
        1:
        begin
          new(PIntegerData(rec^.CustomFields[i].data));
          Str.Read(PIntegerData(rec^.CustomFields[i].data).Value, SizeOf(Integer))
        end;
        2:
        begin
          new(PRealData(rec^.CustomFields[i].data));
          Str.Read(PRealData(rec^.CustomFields[i].data).Value, SizeOf(Single))
        end;
      end
    end;

   	rec^.location:=location;
    result := ValidRec(rec);
    if result then
    	reclist.add(rec)
	except
    result := false
  end
{
var
	Size : word;
  i, ps:integer;
  rec:Prec;
  recId: smallint;
  b: Boolean;
begin
	result := true;
  try
    if FV > 1 then
    begin
    	str.Read(recId, 2);
      if RecId <> FileRecIdent then
      begin
        result := false;
        exit
      end
    end;
    new(rec);
    fillChar(rec^, sizeOf(rec^), #0);

    if FV >= 5 then
    begin
    	if (FV < 7) and dbs[location].calculateCRC then
      begin
				Str.Read(rec^, staticSize-4);
        Str.Read(rec.crc, 4)
      end
      else
      begin
    		Str.Read(rec^, staticSize);
        ps := str.Position;
        Str.Position := Str.Position - 4;
        Str.Read(flgs, SizeOf(flgs));
        Str.Position := ps;
      end;
      ReadString(rec.FName);

      if FV = 5 then
      begin
	      Str.Read(rec^.fPath, sizeOf(rec^.fPath));
	      Str.Read(rec^.artist, sizeOf(rec^.artist));
	      Str.Read(rec^.ArtistSortOrder, sizeOf(rec^.ArtistSortOrder));
      end;

      ReadString(rec.Title);

      if FV = 5 then
	      Str.Read(rec^.album, sizeOf(rec^.album));

     	ReadString(rec.Comment);

      Str.Read(Size, sizeof(Size));
      setLength(rec^.Genre, Size);
      for i:=0 to Size-1 do Str.Read(Rec^.Genre[i],SizeOf(Cardinal));

      Str.Read(Size, sizeof(Size));
      SetLength(rec^.Groups, Size);
      for i:=0 to Size-1 do Str.Read(Rec^.Groups[i], SizeOf(Byte)); //skal vre sizeOf(Byte) !

      if FV >= 7 then
      begin
      	Str.Read(Size, SizeOf(Size));
				SetLength(rec^.CustomFields, Size);
        for i:=0 to Size-1 do
        begin
    			Str.Read(rec^.CustomFields[i].FieldIndex, SizeOf(Byte));
          Case PCustomField(FieldList.Items[rec^.CustomFields[i].FieldIndex]).DataType of
    				0:
            begin
              new(PStringData(rec^.CustomFields[i].data));
            	ReadString(PStringData(rec^.CustomFields[i].data).Value)
            end;
			      1:
            begin
              new(PIntegerData(rec^.CustomFields[i].data));
            	Str.Read(PIntegerData(rec^.CustomFields[i].data).Value, SizeOf(Integer))
            end;
			      2:
            begin
              new(PRealData(rec^.CustomFields[i].data));
            	Str.Read(PRealData(rec^.CustomFields[i].data).Value, SizeOf(Single))
            end;
			    end
        end
      end
    end
    else
    begin
      ReadString(rec.FName);

      Str.Read(rec^.fPath, sizeOf(rec^.fPath));

      Str.Read(rec^.artist, sizeOf(rec^.artist));
      Str.Read(rec^.ArtistSortOrder, sizeOf(rec^.ArtistSortOrder));

      ReadString(rec.Title);

      Str.Read(rec^.album, sizeOf(rec^.album));

      ReadString(rec.Comment);

      Str.Read(Size, sizeof(Size));
      setLength(rec^.Genre, Size);
      for i:=0 to Size-1 do Str.Read(Rec^.Genre[i],SizeOf(Cardinal));

      Str.Read(Size, sizeof(Size));
      SetLength(rec^.Groups, Size);
      for i:=0 to Size-1 do Str.Read(Rec^.Groups[i],SizeOf(Byte)); //skal vre sizeOf(Byte) !

      Str.Read(rec^.year, SizeOf(rec^.year));
      Str.Read(rec^.Track, SizeOf(rec^.Track));
      Str.Read(rec^.Kbps, SizeOf(rec^.Kbps));
      Str.Read(rec^.Length, SizeOf(rec^.Length));
      Str.Read(rec^.Channels, SizeOf(rec^.Channels));
      Str.Read(rec^.LastWriteTime, SizeOf(rec^.LastWriteTime));
      Str.Read(rec^.DatabaseTime, SizeOf(rec^.DatabaseTime));
      Str.Read(rec^.PlayCount, SizeOf(rec^.PlayCount));

      if FV < 5 then
      begin
        Str.Read(b, SizeOf(b));
        if b then
        	Include(rec.Flags, rfCompilation)
        else
        	Exclude(rec.Flags, rfCompilation);
        rec^.TotalTracks := 0
      end
      else
      begin
        Str.Read(rec^.Flags, SizeOf(rec^.Flags));
        Str.Read(rec^.TotalTracks, SizeOf(rec^.TotalTracks))
      end;
    
      //CRC
      if dbs[location].calculateCRC or (FV < 3) then
        Str.Read(rec^.CRC, SizeOf(rec^.CRC))
      else
        rec^.CRC := 0;

      Str.Read(rec^.Fsize, SizeOf(rec^.Fsize));
      Str.Read(rec^.Khz, SizeOf(rec^.Khz));
      Str.Read(rec^.addQuality, SizeOf(rec^.addQuality));
      Str.Read(rec^.AudioType, SizeOf(rec^.AudioType))
    end;

   	rec^.location:=location;

    result := ValidRec(rec);
    if result then
    	reclist.add(rec)
	except
    result := false
  end}
end;
var
  dbindex, staticSize:Integer;
  MS : TMemoryStream;
  FV:Cardinal;
  failed : boolean;
  dateTime: Double;
begin
  result := false;
  dbindex := Location;
  if dbs[dbindex].loaded then exit;

  if fileexists(settingsdir + dbs[dbindex].filename) then
  begin
    dbs[dbindex].loaded := true;
    MS := TMemoryStream.create;
    failed := false;
    MS.LoadFromFile(settingsdir + dbs[dbindex].filename);
    if MS.Size > 0 then
    begin
      MS.Read(FV, sizeof(FV));     //fileVersion
      if (FV >= 7) and (FV <= DB_FileVer) then
      begin
        if FV >= 4 then
        begin
          MS.Read(dateTime, SizeOf(dateTime));
          dateTime := invertDate(dateTime);
          AddAppStartDate(dateTime)
        end;

        if dbs[dbIndex].calculateCRC then
          staticSize := StaticRecSizeWithCRC
        else
          staticSize := StaticRecSizeWithoutCRC;

        if FV < 7 then
        	dec(staticSize, 2);

        while not failed and (MS.Position < MS.Size) do
          if not LoadRecFromStream(MS, dbindex, staticSize, FV) then
            failed := true;
      end
      else
      begin
        //unsupported file version
        dbs[dbindex].loaded := false;
        Showmessagex(GetText(TXT_UnSupportedFileVersion))
      end
    end;
	  if failed then
	  	Showmessagex(GetText(TXT_CorruptDatabasefile, [dbs[dbindex].filename]));
	  MS.free;
  end
end;

Procedure TMainForm.UnloadAndSaveAll(ReleaseResources: Boolean; BeginEndUpdate:Boolean);
//.saveDB
{Function CountSize(dbIndex, staticSize:Integer):Integer;
var
	i, j, IntSize :Integer;
	R : Prec;
begin
	result := 0;
	IntSize := StaticSize + FileRecIdentSize + 6 * SizeOf(word) ;

	for i:=0 to reclist.count-1 do
		if assigned(reclist.items[i]) and (Prec(reclist.items[i]).location = dbIndex) then
		begin
			R := Prec(reclist.Items[i]);
			Inc(result, Length(R.Fname));
			Inc(result, Length(R.Title));
			Inc(result, Length(R.Comment));
			Inc(result, Length(R.Genre) * sizeOf(Cardinal));
			Inc(result, Length(R.Groups)*  sizeOf(byte));
      //Custom Fields
      for j:=0 to length(R.CustomFields)-1 do
				Case PCustomField(FieldList.Items[R.CustomFields[j].FieldIndex]).DataType of
		    	0: Inc(result, SizeOf(word) + length(PStringData(R.CustomFields[j].data).Value));
		      1: Inc(result, SizeOf(Integer));
		      2: Inc(result, SizeOf(Single));
//		      3: Inc(result, SizeOf(Boolean))
		    end;
			Inc(result, IntSize)
		end;
end;   }

Procedure AddToStream(R:Prec; Str:TStream; staticSize: Integer);

{procedure Write(const s: String); overload;
var
  Size: word;
begin
  Size := length(s);

  Str.Write(Size, SizeOf(word));
  if Size > 0 then
  	Str.Write(s[1], size)
end;  }

{procedure Write(p: PChar); overload;
var
  Size: word;
begin
  Size := Q_PStrLen(p);

  Str.Write(Size, SizeOf(word));
  if Size > 0 then
  	str.Write(p^, Size)
end; }

var
  Size: word;
  i:Integer;
begin
	//Rewritten 2/5-03
  Str.Write(FileRecIdent, 2);
  Str.Write(R^, staticSize);	//alle vrdier

  WriteString(str, R.FName);
  WriteString(str, R.Title);
  WriteString(str, R.Comment);

  Size := min(high(word), Length(R.Genre));
  Str.Write(Size, SizeOf(Size));
  for i:=0 to Size-1 do
  	Str.Write(R.Genre[i],SizeOf(Cardinal));

  Size := min(high(word), Length(R.Groups));
  Str.Write(Size, SizeOf(Size));
  for i:=0 to Size-1 do
  	Str.Write(R.Groups[i],SizeOf(R.Groups[i]));

  Size := min(high(word), Length(R.CustomFields));
  Str.Write(Size, SizeOf(Size));
  for i:=0 to Size-1 do
  begin
		Str.Write(R.CustomFields[i].FieldIndex, SizeOf(Byte));
    Case PCustomField(FieldList.Items[R.CustomFields[i].FieldIndex]).DataType of
    	0: WriteString(Str, PStringData(R.CustomFields[i].data).Value);
      1: Str.Write(PIntegerData(R.CustomFields[i].data).Value, SizeOf(Integer));
      2: Str.Write(PRealData(R.CustomFields[i].data).Value, SizeOf(Single));
//      3: Str.Write(PBoolData(R.CustomFields[i].data).Value, SizeOf(Boolean))
    end
  end;
end;

procedure SaveWPL;
var       aNode:PVirtualNode;
          WPL : TMyMemoryStream;
          c:cardinal;
          i:integer;
          PL:PplstRec;
					b:boolean;
          Size : word;
begin
     WPL := TMyMemoryStream.create;

     WPL.Write(WPL_FileVer, sizeOf(WPL_FileVer)); //fileversion

     WPL.Write(ShuffleEnabled, SizeOf(ShuffleEnabled));

     c := winplaylist.RootNodeCount;
		 WPL.Write(c, sizeOf(c)); //lngden p playlisten

     aNode := winplaylist.GetFirst;
     while aNode <> nil do
     begin
          PL := Winplaylist.GetNodeData(aNode);
          b := assigned(PL.Rec);
          WPL.Write(b, sizeOf(b));                      //gemmer assigned(PL.ref)
          if b then
					begin
            i := HashedRecListIndexOf(PL.Rec);
            WPL.Write(i, sizeOf(i))
          end else
          begin
               Size := min(MaxSavedChars, Length(PL.Filename));  //filename
							 WPL.Write(Size, SizeOf(Size));
							 WPL.Write(pointer(PL.FileName)^, Size);

               Size := min(MaxSavedChars, Length(PL.text));   //text
               WPL.Write(Size, SizeOf(Size));
               WPL.Write(pointer(PL.text)^, Size);

							 WPL.Write(PL.Seconds, sizeOf(PL.Seconds))
          end;

          WPL.Write(PL.playing, sizeOf(PL.Playing));
          WPL.Write(PL.Kill, sizeOf(PL.Kill));
          WPL.Write(PL.ShuffleValue, sizeOf(PL.shuffleValue));
          WPL.Write(PL.EnqueueNo , sizeOf(PL.EnqueueNo));

					aNode := winplaylist.GetNext(aNode)
     end;
     WPL.SaveToFile(settingsDir + 'winplaylist.dat');
     WPL.free
end;

procedure SaveCoverCache;
var
	mstr: TMyMemoryStream;
  i, j: integer;
  cr: PCoverRec;
begin
	DeleteFile(settingsDir + 'Covers.dat');

  fCoverImgsRW.BeginWrite;
  fCoverRecRW.BeginWrite;
  try
    mstr := TMyMemoryStream.Create;
	  mstr.Write(COVERCACHE_FileVer, sizeOf(COVERCACHE_FileVer)); //fileversion
    for i:=0 to fCoverImgs.Count-1 do
    begin
      cr := fCoverImgs.List^[i];
      //Thumbnail
      if (crfInvalidateThumb in cr.Flags) and (length(cr.ThumbCacheFilename) > 0) then
      begin
        DeleteFile(CoverThumbsDir + cr.ThumbCacheFilename);
        cr.ThumbCacheFilename := ''
      end
      else
      //Check if the thumbnail is loaded
      if (cr.State = ImageLoaded) and not (crfInvalidateThumb in cr.Flags) then
      begin
        //Check if we need to save the thumbnail
        if (crfThumbnailChanged in cr.Flags) and Assigned(cr.Image) then
        begin
          Exclude(cr.Flags, crfThumbnailChanged);

          //Check if the old image should be deleted
          if length(cr.ThumbCacheFilename) > 0 then
            DeleteFile(CoverThumbsDir + cr.ThumbCacheFilename);

          cr.ThumbCacheFilename := RandomFilename(CoverThumbsDir, 'jpg', false);
          cr.Image.SaveToFile(CoverThumbsDir + cr.ThumbCacheFilename);
        end;
      end;

      mstr.Write(cr.SourceType, SizeOf(cr.SourceType));
      mstr.Write(cr.ThumbnailWidth, SizeOf(cr.ThumbnailWidth));
      mstr.Write(cr.ThumbnailHeight, SizeOf(cr.ThumbnailHeight));

      j := HashedRecListIndexOf(cr.SourceRec);
      mstr.Write(j, sizeOf(j));

      WriteString(mstr, cr.ThumbCacheFilename);

      if cr.SourceType = coverSource_imageFile then
      	WriteString(mstr, cr.ImageFilename);
    end;	//of for-loop

	  mstr.SaveToFile(settingsDir + 'Covers.dat');
  finally
  	fCoverImgsRW.EndWrite;
    fCoverRecRW.EndWrite;
	  mstr.Free
	end;
end;

//MAIN
Var
	i, x, StaticSize:integer;
  MS : TMyMemoryStream;
  dateTime: TDateTime;
begin
  dirspyTimer.enabled := false;
  if autoScanThread.Runing then
  begin
  	autoScanThread.Thread.Terminate;
    autoScanThread.Thread.WaitFor
  end;
  MoveAddRecListToReclist;
  UpdateHashedReclist;

  saveOpUndos(fileUndoList, undoDir + autoScanFilename);    //gemmer autoscanUndo

  if pref.ControlPlaylist.checked then
    SaveWPL;  //gemmer winplaylist

  SaveCoverCache;

  for i:=0 to length(dbs)-1 do if dbs[i].Loaded then
  begin
    if dbs[i].calculateCRC then
    	StaticSize := StaticRecSizeWithCRC
    else
    	StaticSize := StaticRecSizeWithoutCRC;

//    Size := SizeOf(DB_FileVer) + SizeOf(dateTime);
//    Inc(Size, CountSize(i, StaticSize));
    ms := TMyMemoryStream.Create;
//    ms.setcapacity(Size);

    ms.Write(DB_FileVer, sizeof(DB_FileVer));

    dateTime := InvertDate(AppFirstRunDate);
    ms.Write(dateTime, SizeOf(dateTime));

    for x:=0 to reclist.count-1 do
    	if assigned(reclist.List^[x]) then
    	begin
      	if Prec(reclist.List^[x]).Location = i then
      	begin
      		AddToStream(Reclist.List^[x], ms, StaticSize);

          if ReleaseResources then
          begin
        		DisposeRec(reclist.List^[x]);
        		reclist.items[x] := nil
          end
      	end
    	end;

    if length(dbs[i].filename) = 0 then
    	dbs[i].filename := createFilename(settingsdir, dbs[i].name + '.db', false, false);

    MS.SaveToFile(settingsdir + dbs[i].filename);
//    OutputDebugString(pchar(inttostr(ms.reallocCount)));
    MS.Free;
  end;

  if ReleaseResources then
	  for i:=0 to length(dbs)-1 do if dbs[i].Loaded then
	  	dbs[i].Loaded := false;

  reclist.pack;
  reclist.capacity := reclist.count
end;


Function TMainForm.LocateDBname(const name:String):integer;
var
	i:integer;
begin
  result := -1;
  for i:=0 to length(dbs)-1 do
  	if Q_SameText(dbs[i].Name, name) then
	  begin
	    result := i;
	    break
	  end
end;

procedure TMainForm.SortWinplayColumnsToRightPosition;
var
	i, k: Integer;
begin
  for i:=0 to length(WPColumnArr)-1 do
  begin
  	//width + Visible
    if i < Winplaylist.Header.Columns.Count then
    begin
			Winplaylist.Header.Columns[i].Width := WPColumnArr[i].Width;
      if WPColumnArr[i].Visible then
      	Winplaylist.Header.Columns[i].Options := Winplaylist.Header.Columns[i].Options + [coVisible]
      else
      	Winplaylist.Header.Columns[i].Options := Winplaylist.Header.Columns[i].Options - [coVisible]
    end;
    for k:=0 to length(WPColumnArr)-1 do
      if (k < Winplaylist.Header.Columns.Count) and (WPColumnArr[k].Position = i) then
        Winplaylist.Header.Columns[k].Position := i
  end;
  CalculateWinplayTextColumn
end;

procedure TMainForm.SaveWinPlayColumns;
var
	i: Integer;
begin
	SetLength(WPColumnArr, Winplaylist.Header.Columns.Count);
  for i:=0 to Winplaylist.Header.Columns.Count-1 do
  begin
  	WPColumnArr[i].Visible := coVisible in Winplaylist.Header.Columns[i].Options;
    WPColumnArr[i].Position := Winplaylist.Header.Columns[i].Position;
    WPColumnArr[i].Width := Winplaylist.Header.Columns[i].Width
  end
end;

procedure TMainForm.CalculateWinplayTextColumn;
var
	tag: Integer;
  c: TColumnIndex;
begin
  c := winplaylist.Header.Columns.GetFirstVisibleColumn;
  while c >= 0 do
  begin
    tag := Winplaylist.Header.Columns[c].Tag;
  	if (Tag <> FWINPLAYPOS) and (Tag <> FFilename) and (Tag <> FLength) and (Tag <> FWinplayEnqueue) then
    begin
     	WPRegularTextColumn := c;
      break
    end;
    c := Winplaylist.Header.Columns.GetNextVisibleColumn(c)
  end
end;

procedure TMainForm.SetWinplayColumns(forceUpdate: Boolean);
var
	vtColumn: TVirtualTreeColumn;
  i: integer;
begin
	if not forceUpdate and (pref.WinplayShowColumns.Checked = (hoVisible in winplaylist.Header.Options)) then
  	exit;

	winplaylist.BeginUpdate;
  if (hoVisible in winplaylist.Header.Options) and not forceUpdate then
  	SaveWinPlayColumns;

  winplaylist.Header.Columns.Clear;

  //Enqueue Column
  vtColumn := Winplaylist.Header.Columns.add;
  vtColumn.Text := GetText(TXT_ColumnEnqueuePosition);
  vtColumn.Tag := FWinplayEnqueue;
  vtColumn.Options := vtColumn.Options - [coAllowClick];
  vtColumn.Style := vsOwnerDraw;
  vtColumn.Alignment := taCenter;

  if pref.WinplayShowColumns.Checked then
  begin
    //playPos Column
		vtColumn := Winplaylist.Header.Columns.add;
    vtColumn.Text := GetText(TXT_ColumnPlaylistPosition);
    vtColumn.Tag := FWINPLAYPOS;
    vtColumn.Options := vtColumn.Options - [coAllowClick];
    vtColumn.Style := vsOwnerDraw;
    vtColumn.Alignment := taCenter;

    for i:=0 to tabel.Header.Columns.Count-1 do
    begin
			vtColumn := Winplaylist.Header.Columns.add;
      vtColumn.Text := tabel.Header.Columns[i].Text;
      vtColumn.Tag := tabel.Header.Columns[i].Tag;
      vtColumn.Alignment := tabel.Header.Columns[i].Alignment;
      vtColumn.BiDiMode := tabel.Header.Columns[i].BiDiMode;
      vtColumn.Options := tabel.Header.Columns[i].Options;// - [coAllowClick];
      vtColumn.Style := vsOwnerDraw
    end;
    SortWinplayColumnsToRightPosition;

  	winplaylist.Header.Options := winplaylist.Header.Options + [hoVisible]
  end
  else
  begin
    winplaylist.Header.Options := winplaylist.Header.Options - [hoVisible];

  	//Text Column
		Winplaylist.Header.Columns.add;

    //playPos Column
		vtColumn := Winplaylist.Header.Columns.add;
    vtColumn.Alignment := taRightJustify
  end;

  winplaylist.EndUpdate
end;

function TMainForm.NodeBelongsToTree(Node: PVirtualNode; tree: TVirtualStringTree; flatList: Boolean):Boolean;
var
	aNode: PVirtualNode;
begin
	result := false;
  if Assigned(Node) then
  begin
	  if flatList then
    begin
    	if Node.Index < (tree.RootNodeCount div 2) then
      begin
      	aNode := tree.GetFirst;
        while aNode <> nil do
        begin
        	if Node = aNode then
	        begin
          	result := true;
          	exit
        	end;
          aNode := aNode.NextSibling
        end
      end
      else
      begin
      	aNode := tree.GetLast;
        while aNode <> nil do
        begin
        	if Node = aNode then
	        begin
          	result := true;
          	exit
        	end;
          aNode := aNode.PrevSibling
        end
      end
    end
    else
    begin
      aNode := tree.GetFirst;
      while aNode <> nil do
      begin
        if Node = aNode then
        begin
          result := true;
          exit
        end;
        aNode := tree.GetNext(aNode)
      end
    end
  end
end;

procedure TMainForm.WinampPlaylistBtnClicked;
begin
	SetMainFormVisible(not MainFormInstance.visible)
end;

procedure TMainForm.SetMainFormVisible(show: Boolean);
var
	SW: TSnapWin;
begin
	try
		if assigned(FSnap) then
			SW := TSnapWin(FSnap.GetSnapWin(MainFormInstance.handle))
		else SW := nil
	except
		SW := nil
	end;
	if Assigned(SW) then SW.WindowClosed := not show;

	if show then
	begin
		if DBinitiated then
		begin
			FSnap.CheckAllSnaps;
			if IsIconic(MainFormInstance.handle) then
				ShowWindow(MainFormInstance.handle, SW_RESTORE);  //gres i ForceForegroundWindow(MainFormInstance.handle);
      ForceForegroundWindow(MainFormInstance.handle);

      CurrentActiveForm := MainFormInstance;
			MainFormInstance.Show;

			with MainFormInstance do
									 SetWindowPos(Handle,
									 HWND_TOPMOST,
									 Left,
									 Top,
									 Width,
									 Height,
									 SWP_NOMOVE or SWP_NOSIZE);
			if not aot.Checked then
				with MainFormInstance do
									 SetWindowPos(Handle,
									 HWND_NOTOPMOST,
									 Left,
									 Top,
									 Width,
									 Height,
									 SWP_NOMOVE or SWP_NOSIZE);
      SetActiveWindow(MainFormInstance.Handle);
      Windows.SetFocus(MainFormInstance.Handle)
		end else ShowAForm
	end else
		if pref.sit.Checked then
			showWindow(MainFormInstance.handle, SW_MINIMIZE)
		else MainFormInstance.hide //ellers laver den et lille vindue p skrivebordet nr den bliver minimeret
end;

Procedure TMainForm.showProcessDlg(APrompt: string; maximum:integer; ShowCancelButton:boolean; var form:TInputbox2);
begin
  Application.CreateForm(TInputbox2, form);
  with TInputbox2(form) do
  begin
    formstyle := fsStayOnTop;
    label1.height := 65;
    Edit1.Visible := false;
    button1.visible := false;
    button2.visible := ShowCancelButton;
    Caption := AppName;
    label1.caption := APrompt;
    Pbar.visible := true;
    Pbar.Max := maximum;
    clientwidth := max(16 + label1.width, 270);
    button2.left := (width div 2) - (button1.width div 2);
    Button2.Top := Pbar.Top - 26;
    clientheight := Button1.top + Button1.height + 6
  end;
  forceRepaint(form)
end;

Procedure TMainForm.ShowMessageX(APrompt: string; Align : TAlignment); //overload;
var
	 CurrentFormBackup : TForm;
begin
		 CurrentFormBackup := CurrentActiveForm;
		 if CurrentFormBackup = MainFormInstance then
			 disableAOT;
		 inputBox2 := nil;
				try
				Application.CreateForm(TInputbox2, Inputbox2);
				inputbox2.FormStyle := fsStayOnTop;
				inputbox2.Label1.Alignment := align;
				inputbox2.label1.height := 65;
        inputbox2.Edit1.Visible := false;
        inputbox2.button2.visible := false;
				inputbox2.Caption := AppName;
        inputbox2.label1.caption := APrompt;
        inputbox2.clientwidth := max(16 + inputbox2.label1.width, 270);
        inputbox2.button1.left := (inputbox2.width div 2) - (inputbox2.button1.width div 2);
        inputbox2.Button1.Top := inputbox2.Label1.top + inputbox2.Label1.height + 8;
        inputbox2.clientheight := inputbox2.Button1.top + inputbox2.Button1.height + 6;
        CurrentActiveForm := InputBox2;
        Inputbox2.showmodal;
				CurrentActiveForm := CurrentFormBackup;
        finally
        if assigned(inputbox2) then
        begin
             inputbox2.release;
             FreeAndNil(Inputbox2)
        end;
				if CurrentActiveForm = MainFormInstance then
					restoreAOT
        end
end;

Procedure TMainForm.ShowMessageX(APrompt: string);   //overload;
begin
	ShowMessageX(APrompt, taCenter)
end;

Function TMainForm.InputBoxx(const ACaption, APrompt: string; var Value: string; passwordField: Boolean = false): Boolean;
var
	CurrentFormBackup : TForm;
begin
	CurrentFormBackup := CurrentActiveForm;
	disableAOT;
	Application.CreateForm(TInputbox2, Inputbox2);
	inputbox2.Caption := Acaption;
	inputbox2.label1.caption := APrompt;
	inputbox2.Edit1.Text := value;
	inputbox2.Edit1.visible := true;
  if passwordField then
  	inputbox2.Edit1.PasswordChar := '*'
  else
  	inputbox2.Edit1.PasswordChar := #0;

	result := false;
	CurrentActiveForm := Inputbox2;
	case Inputbox2.showmodal of
		mrOK:
			begin
				Value := inputbox2.Edit1.text;
				result := true
			end;
		mrCancel:
			begin
				Value := inputbox2.Edit1.text;
				result := false
			end
	end;
	CurrentActiveForm := CurrentFormBackup;
	inputbox2.release;
	FreeAndNil(Inputbox2);
	restoreAOT
end;

Function TMainForm.YesNoBoxx(const ACaption, APrompt, YesText, NoText: string; focused:integer): Boolean;
var
   ipb:TInputBox2;
   CurrentFormBackup : TForm;
begin
        CurrentFormBackup := CurrentActiveForm;
        disableAOT;
        ipb := nil;
				try
				Application.CreateForm(TInputbox2, ipb);
        ipb.Caption := Acaption;
        ipb.label1.caption := APrompt;
        ipb.label1.height := 65;
        ipb.Edit1.Visible := false;
        ipb.button1.Caption := YesText;
				ipb.button2.caption := NoText;
        case focused of
             1:ipb.Focused := ipb.Button1;
             2:ipb.Focused := ipb.Button2
        end;
        result := false;
        CurrentActiveForm := ipb;
        case ipb.showmodal of
                mrOK:  result := true;
                mrCancel: result := false
        end;
        finally
        CurrentActiveForm := CurrentFormBackup;
        if assigned(ipb) then
        begin
             ipb.release;
             FreeAndNil(ipb)
        end;
				restoreAOT
        end
end;

Function TMainForm.YesNoBox3Btn(const ACaption, APrompt, but1, but2, but3: string; focused:integer): integer;
var
   ipb:TInputBox2;
   CurrentFormBackup : TForm;
begin
  CurrentFormBackup := CurrentActiveForm;
  disableAOT;
  Application.CreateForm(TInputbox2, ipb);
  ipb.Caption := Acaption;
  ipb.label1.caption := APrompt;
  ipb.label1.height := 65;
  ipb.Edit1.Visible := false;
  ipb.Button3.Visible := true;
  ipb.button1.Caption := but1;
  ipb.button2.caption := but2;
  ipb.button3.caption := but3;
  case focused of
  	1:ipb.Focused := ipb.Button1;
    2:ipb.Focused := ipb.Button2;
    3:ipb.Focused := ipb.Button3
  end;
  result := 0;
  CurrentActiveForm := ipb;
  case ipb.showmodal of
          mrOK:  result := 1;
          mrCancel: result := 2;
          mrAbort: result := 3
  end;
  CurrentActiveForm := CurrentFormBackup;
  ipb.release;
  FreeAndNil(ipb);
  restoreAOT
end;

Function TMainForm.RenameDialog(const ACaption, source:String; var target:string):TrenameReturn;
var
   Rdlg : TRenameForm;
   CurrentFormBackup : TForm;
begin
     CurrentFormBackup := CurrentActiveForm;
     application.CreateForm(TRenameForm, Rdlg);
     Rdlg.Caption := ACaption;
     Rdlg.sourceFile := source;
     Rdlg.targetFile := target;
     Rdlg.init;
     CurrentActiveForm := Rdlg;
     case Rdlg.ShowModal of
          mrOk :         result := rrDelete;
          mrAbort:       result := rrOverwrite;
          mrRetry:       result := rrRename;
          else           result := rrCancel
     end;
     CurrentActiveForm := CurrentFormBackup;
     if result = rrRename then
        target := Rdlg.newNameEdit.text;
     Rdlg.Release;
     freeAndNil(Rdlg)
end;

procedure UnMeasure(tree: TVirtualStringTree);
var
	aNode: PVirtualNode;
begin
	aNode := tree.GetFirst;
  while aNode <> nil do
  begin
		tree.InvalidateNode(aNode);
  	aNode := tree.GetNext(aNode)
  end;
end;

Function TMainForm.ShowAform:Boolean;
Begin
	result := false;
      if DBinitiated then
      begin
        SetMainFormVisible(true);
        FSnap.CheckAllSnaps;
        result := true;
        exit
      end else
      begin
      	tabel.beginupdate;
        tree.BeginUpdate;
        try
	        InitDB;	//her loades nye datoer for frste krsel af progarmmet. Dette kan betyde, at prvetiden ikke lngere er gyldig
	        if DBinitiated then
	        begin
	          SetMainFormVisible(true);
	          FSnap.CheckAllSnaps;
	          result := true
	        end;
        finally
	        tree.EndUpdate; //fixer lidt grafik
          //UnMeasure(treE);
          tabel.EndUpdate
        end
      end
end;

procedure TMainForm.forceRepaint(control:TControl);
begin
	control.repaint
end;

function TMainForm.FilenameIncomplete(const filename:string):boolean;
var      i, transferred, sPos:integer;
         s, fname:string;
				 data:array[0..512] of byte;
				 fStr:Tstream;
begin //checker om filen er i filen "incomplete downloads.txt", som WinMX bruger nr den downloader
  fName := getFilename(filename);
  if Q_SameTextL('__INCOMPLETE___', fname, 15) or Q_SameTextL('[ftdownload]', fname, 12) then  // winMX 3.0 - 3.1 bruger filnavne som __incomplete__filnavn...
  	result := true
  else
  begin
  s := getFilePath(filename) + 'incomplete downloads.txt';
  if fileexists(s) and GetFileAccess(s, true, false) then
  begin
    FStr := TFileStream.Create(s, fmOpenRead or fmShareDenyNone);
    Fstr.position := 0;
    s := '';
    sPos := 1;
    repeat
          transferred := Fstr.Read(data, sizeof(data));
          setLength(s, length(s)+transferred);
          for i:=0 to transferred-1 do
              s[sPos+i] := char(data[i]);
          inc(sPos, transferred)
    until transferred = 0;
    Fstr.free;
    result := Q_PosText(filename, s)>0
  end else result := false
  end
end;

function TMainForm.OkToAutoScan(const filename:String; CheckReclist:boolean=true):boolean;
function FilenameInAddRecList(const filename:String):boolean;
var      i:integer;
begin
     result := false;
		 for i:=0 to AddRecList.Count-1 do
				 if Q_SameText(getFtextP(AddRecList.List^[i], fFilename), filename) then
         begin
							result := true;
              break
         end
end;
var
	i:integer;
begin
	if not DBInitiated then
		InitDB;

	if fHashedRecList.count <> reclist.count then
		UpdateHashedReclist;

  result := true;

  if length(dbs) > 0 then
    for i:=0 to length(dbs[0].Excl)-1 do
    	if Q_PosText(dbs[0].Excl[i], filename) > 0 then
      begin
      	result := false;
        break
      end;

	result := result and (((not CheckReclist) or (not fHashedRecList.FindFilename(filename, i))) and not FileNameInAddRecList(filename) and not FilenameIncomplete(filename) and getFileAccess(filename, true, true, false, true))
end;

procedure TMainForm.DirSpyTimerTimer(Sender: TObject);
begin
  dirSpyTimer.Enabled := false;
  if AutoScanInProcess or (SafeToAutoScanCount <> 0)then
  	exit;
  AutoScanInProcess := true;
  AutoscanThread.Priority := tpLowest;
  AutoscanThread.Start(nil)
end;

procedure TMainForm.DirSpyTrigger(Sender: TObject; Dir: string; Actions: TJvChangeActions);
begin
  ChangedDirsToAutoScanLock.Enter;
  try
    if ChangedDirsToAutoScan.IndexOf(Dir) < 0 then
      ChangedDirsToAutoScan.Add(Dir);
  finally
    ChangedDirsToAutoScanLock.Leave;
  end;

  if AutoScanInProcess then
     QueSpyScan := true
  else
  begin
    DirSpyTimer.Enabled := false;
    DirSpyTimer.Enabled := true
  end
end;

procedure TMainForm.KillDirSpys;
begin
  if Assigned(dirSpy) then
  begin
    dirSpy.free;
  end;
  dirSpy := nil;
end;

procedure TMainForm.CreateDirSpys;
var
  i: integer;
  changeItem: TJvChangeItem;
begin
	KillDirSpys;
  if pref.AutoScanPaths.Items.Count = 0 then exit;

	dirSpy := TJvChangeNotify.Create(MainFormInstance);
  dirSpy.OnChangeNotify := DirSpyTrigger;
	for i:=0 to pref.AutoScanPaths.Items.count-1 do
		if pref.AutoScanPaths.Checked[i] and directoryExists(pref.AutoScanPaths.Items[i]) then
		begin
      changeItem := dirSpy.Notifications.Add();
      changeItem.Directory := pref.AutoScanPaths.Items[i];
      changeItem.IncludeSubTrees := pref.AutoScanSub.checked;
      changeItem.Actions := [caChangeFileName, caChangeSize];
		end;
  dirSpy.Active := true;
end;

function CompareDates(d1, d2: TDatetime): Integer;
begin
	if d1 = d2 then
  	result := 0
  else
  if d1 > d2 then
  	result := 1
  else
  	result := -1
end;

function SortPointerIntByPointer(Item1, Item2: Pointer): Integer;
begin
	result := CompInteger(integer(PPointerAndInt(Item1).p), integer(PPointerAndInt(Item2).p))
end;

function SortRecsByFilename(Item1, Item2: Pointer): Integer;
begin
	with MainFormInstance do
  	result := Q_CompText(getFtextP(Item1, fFilename), getFtextP(Item2, fFilename))
end;

function SortRecsByCustomField(Item1, Item2: Pointer; Data: Integer): Integer;
begin
	MainFormInstance.doTabelCompareNodes(Item1, Item2, FCustomField + Data, Result)
end;

function SortRecsByLocation(Item1, Item2: Pointer): Integer;
begin
	result := Prec(Item1).Location - Prec(Item2).Location
end;

function SortRecsByArtistSortOrder(Item1, Item2: Pointer): Integer;
begin
	result := Prec(Item1).ArtistSortOrder - Prec(Item2).ArtistSortOrder
end;

function SortRecsByArtist(Item1, Item2: Pointer): Integer;
begin
	result := Prec(Item1).Artist - Prec(Item2).Artist
end;

function SortRecsByAlbum(Item1, Item2: Pointer): Integer;
begin
	result := Prec(Item1).Album - Prec(Item2).Album
end;

function SortRecsBySet(Item1, Item2: Pointer): Integer;
begin
	result := integer(MainFormInstance.GetPartOfSet(Item1)) - integer(MainFormInstance.GetPartOfSet(Item2))
end;

function SortRecsByArtist_Album(Item1, Item2: Pointer): Integer;
begin
	result := Prec(Item1).ArtistSortOrder - Prec(Item2).ArtistSortOrder;
  if result = 0 then
  	result := Prec(Item1).Album - Prec(Item2).Album
end;

{function SortRecsByYear_Album(Item1, Item2: Pointer): Integer;
begin
	result := Q_CompStr(MainFormInstance.GetYearAlbum(Item1), MainFormInstance.GetYearAlbum(Item2))
end;     }

function SortRecsByCompilation(Item1, Item2: Pointer): Integer;
begin
	//result := Prec(Item2).Flags and RF_Compilation - Prec(Item1).Flags and RF_Compilation
  result := integer(rfCompilation in Prec(item2).Flags) - integer(rfCompilation in Prec(item1).Flags);

end;

function SortRecsByCompilationAlbum(Item1, Item2: Pointer): Integer;
begin
	//result := Prec(Item2).Flags and RF_Compilation - Prec(Item1).Flags and RF_Compilation;
  result := integer(rfCompilation in Prec(item2).Flags) - integer(rfCompilation in Prec(item1).Flags);
  if result = 0 then
  	result := Prec(Item1).Album - Prec(Item2).Album
end;

{procedure TMainForm.DisposeSortedRec(const pr: PPointerPCharRec);
begin
	StrDispose(pr.pc);
	finalize(pr^);
	dispose(pr)
end;   }

procedure TMainForm.UpdateHashedReclist;
var
	i:integer;
begin
	fHashedRecList.clear;

	fHashedRecList.Capacity := reclist.count;
	for i:=0 to reclist.count-1 do
    fHashedRecList.AddRec(reclist.List^[i], false);

	fHashedRecList.Sort;
end;

function TMainForm.FindInReclist(const fn:String):pointer;
var      i:integer;
begin
  if fHashedRecList.count <> reclist.count then
    UpdateHashedReclist;

  if fHashedRecList.FindFilename(fn, i) then
    result := fHashedRecList.List^[i]
  else
  	result := nil
end;

Procedure TMainForm.ReleaseRecs(deleteFromPlaylists:boolean; disposeAfterRelease: boolean);
// Gennemlber PlayListCache, quicklist, sortedRecList samt winplaylist og fjerner alle referencer til rec.
var       i, j, k:integer;
          fnames: TStringList;
          aNode, bNode : PVirtualNode;
          WinplayRec: PplstRec;
          pur: PplstUndoRec;
          cr: PCoverRec;
          updated, b, packPending : boolean;
          PLC : PplConRec;
          rec, r2: PRec;
begin
	fnames := TStringList.Create;
  fnames.Capacity := reclist.Count;
  for i:=0 to Reclist.count-1 do
  begin
  	rec := Reclist.List^[i];
  	if rfDeletePending in rec.Flags then
    	fnames.Add(getFtextP(rec, fFilename));
  end;
  fnames.Sort;

	//Coverrecs
  fCoverImgsRW.BeginWrite;
  fCoverRecRW.BeginWrite;
  try
		for i:=0 to fCoverImgs.Count-1 do
	  begin
    	cr := fCoverImgs.List^[i];
      if rfDeletePending in cr.SourceRec.flags  then
      begin
      	rec := cr.SourceRec;
      	b := false;
        if cr.SourceType = coverSource_imageFile then
        begin
        	//Find a rec with the same filepath as this one - and make sure the rec is not about to be deleted
          for j:=0 to reclist.Count-1 do
          begin
          	r2 := reclist.List^[j];
          	if (r2.Fpath = rec.Fpath) and not (rfDeletePending in r2.flags) then
            begin
            	cr.SourceRec := r2;
			        b := true;
	            break	//for j:=0 to reclist.Count-1 do
            end;
          end
        end;

        if not b then
        	Include(cr.Flags, crfDeletePending);
      end
	  end;
    ReleaseAndDisposeCoverRecs(true, true);
  finally
  	fCoverRecRW.EndWrite;
  	fCoverImgsRW.EndWrite
  end;

  //TreePLCache:
  for i:=0 to m3uList.count-1 do
  	for k:=0 to Reclist.Count-1 do
    begin
    	rec := reclist.List^[k];
    	if rfDeletePending in rec.flags then
		  	RemoveFromPLcache(m3uList.items[i], rec, deleteFromPlaylists)
    end;

  packPending := false;
  //WinplayUndo
  for i:=0 to WinplayUndoList.count-1 do
  begin
  	pur := WinplayUndoList.items[i];
    if assigned(pur) and assigned(pur.Rec) and (rfDeletePending in pur.Rec.flags) then
	  begin
	    dispose(pur);
	    WinplayUndoList.items[i] := nil;
      packPending := true
	  end;
  end;
  if packPending then WinplayUndoList.pack;

  packPending := false;
	for i:=0 to fPlaylist.Count-1 do
  	if rfDeletePending in PRec(fPlaylist.items[i]).Flags then
    begin
    	fPlaylist.items[i] := nil;
      packPending := true
    end;
  if packPending then fPlaylist.pack;

  //SortedRecList
  packPending := false;
  for i:=0 to fHashedRecList.count-1 do
  	if rfDeletePending in Prec(fHashedRecList.List^[i]).Flags then
    begin
      fHashedRecList.items[i] := nil;
      packPending := true
    end;
  if packPending then fHashedRecList.pack;

  //Quicklist
  updated := false;
  aNode := plCon.GetFirst;
  while aNode <> nil do
  begin
	  PLC := plCon.getNodeData(aNode);
    if (assigned(PLC.Rec) and (rfDeletePending in PLC.Rec.Flags)) or (deleteFromPlaylists and fnames.Find(PLC.Filename, i)) then
    begin
    	if deleteFromPlaylists then
	    begin
      	bNode := plCon.getNext(aNode);
        plCon.DeleteNode(aNode);
        aNode := bNode;
        updated := true
      end else
      begin
      	rec := PLC.Rec;
        PLC.Filename := GetFTextP(rec, FFilename);
        PLC.Seconds := rec.length div 1000;
        PLC.Text := getFtextP(rec, fArtist) + ' - ' + getFtextP(rec, fTitle);
        PLC.Rec := nil;
        aNode := plCon.GetNext(aNode)
      end
    end
    else aNode := plCon.GetNext(aNode)
  end;
  //opdaterer plCon
  if updated then UpdatePlaylist;

  updated := false;
  aNode := Winplaylist.GetFirst;
  while aNode <> nil do
  begin
    WinplayRec := Winplaylist.GetNodeData(aNode);
    if (assigned(WinplayRec.Rec) and (rfDeletePending in WinplayRec.Rec.Flags)) or (deleteFromPlaylists and fnames.Find(WinplayRec.Filename, i)) then
    begin
    	if deleteFromPlaylists then
      begin
      	if WinplayRec.Playing then
        	button4(hwnd_winamp); //stopper afspilningen
        bNode := winplaylist.getNext(aNode);
		    WinplayDequeue(aNode);
		    Winplaylist.DeleteNode(aNode);
		    aNode := bNode;
		    updated := true
      end else
		  begin
      	rec := WinplayRec.Rec;
		    WinplayRec.Filename := GetFTextP(rec, FFilename);
		    WinplayRec.Text := getFtextP(rec, fArtist) + ' - ' + getFtextP(rec, fTitle);
		    WinplayRec.Seconds := rec.Length div 1000;
		    //WinplayRec.Playing := false; den skal vist ikke vre med!
		    WinplayRec.Rec := nil;
		    aNode := Winplaylist.GetNext(aNode)
		  end
    end
    else
    	aNode := Winplaylist.GetNext(aNode)
	end;

  fnames.Free;

  if disposeAfterRelease then
  begin
  	for i:=0 to Reclist.count-1 do
    	if rfDeletePending in PRec(Reclist.List^[i]).Flags then
      begin
	    	DisposeRec(Reclist.List^[i]);
        Reclist.Items[i] := nil
      end;
    reclist.Pack
  end;

  if updated then winplaysave;
end;


Procedure TMainForm.RecListToTabel(BeginEndUpdate, LockReclist:boolean);
begin
  if LockReclist then
  	BeginUseReclist;
	reclist.pack;
	reclist.capacity := reclist.count;
	if beginendupdate then tabel.beginupdate;
	tabel.clear;
	if fOnlyPL then
  	tabel.RootNodeCount := fPlaylist.Count
	else
  	tabel.RootNodeCount := reclist.count;

	tabel.reinitnode(tabel.rootnode, true);

  fOldOnlyPL := fOnlyPL;

	DoShowHideNodes(true);

	if beginendupdate then
  	tabel.endupdate;

  if LockReclist then
  	EndUseReclist
end;

Procedure TMainForm.StopScanning;
begin
  if ScanThread.Runing then
  begin
		if FileFind1.Searching then
	  	FileFind1.Abort;
    ScanThread.Thread.Terminate;
    ScanThread.Thread.waitfor
	end
end;

procedure TMainForm.ShowHideNodes;
begin
  BeginUseReclist;
	DoShowHideNodes(false);
	EndUseReclist
end;

Procedure TMainForm.DoShowHideNodes(skipRecListToTabel: boolean);
var
	aNode : PVirtualNode;
	fileCount, totalNodeHeight, visibleCount: Cardinal;
	time: int64;
	rec: PRec;
	i, u: Integer;
	AutoSizeColumns, NodeVisible: Boolean;
	TextLengths, ColumnTags, ColumnIndexes: array of Integer;
  CharWidth: Integer;
	ShowColumns: array of Boolean; //artist (1), Album(3), Genre(4)
//  start: dword;
begin
//	start := Gettickcount;

	fileCount := 0;
	time := 0;
	UpdateSearchBools;
	SetLength(ShowColumns, length(TabelColumnsVisible));

	for i:=0 to length(ShowColumns)-1 do
		ShowColumns[i] := TabelColumnsVisible[i];

	if Pref.HideInfoShownInTree.Checked and (Length(fTreeFilter) = 1) then
	begin
			for i:=1 to length(fTreeFilter[0])-1 do
			begin
				if fTreeFilter[0][i].Kind in [TreeKind_artist, TreeKind_ArtistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum] then
					ShowColumns[1] := false  //artist
        else
				if fTreeFilter[0][i].Kind in [TreeKind_album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_artistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum] then
					ShowColumns[3] := false  //album
        else
				if fTreeFilter[0][i].Kind = TreeKind_genre then
					ShowColumns[4] := false   //genre
        else
        if fTreeFilter[0][i].Kind = TreeKind_Year then
					ShowColumns[5] := false   //Year
			end
	end;

	AutoSizeColumns := pref.AutoResizeColumnHeaders.Checked;
	if AutoSizeColumns then
	begin
		TempCanvas.Canvas.Font := tabel.Font;
    TempCanvas.Canvas.Font.Style := TempCanvas.Canvas.Font.Style + [fsBold] + [fsItalic];
    TempCanvas.Canvas.Font := tabel.Font;
    CharWidth := TempCanvas.Canvas.TextWidth('X ');

		ColumnTags := nil;
		for i:=1 to ColumnsToAutoResizeCount do
			if ShowColumns[ColumnsToAutoResize[i]] then
			begin
				SetLength(ColumnTags, Length(ColumnTags)+1);
				SetLength(ColumnIndexes, Length(ColumnIndexes)+1);
				ColumnTags[length(ColumnTags)-1] := tabel.Header.Columns[ColumnsToAutoResize[i]].Tag;
				ColumnIndexes[length(ColumnTags)-1] := ColumnsToAutoResize[i]
			end;

    //Custom fields
    for i:=0 to tabel.Header.Columns.Count-1 do
    	if (tabel.Header.Columns[i].Tag >= FCustomField) and (ShowColumns[i]) then
      begin
      	SetLength(ColumnTags, Length(ColumnTags)+1);
				SetLength(ColumnIndexes, Length(ColumnIndexes)+1);
				ColumnTags[length(ColumnTags)-1] := tabel.Header.Columns[i].Tag;
				ColumnIndexes[length(ColumnTags)-1] := i
      end;

		SetLength(TextLengths, length(ColumnTags))
	end;
///////////////////////////////////////////////////////////////////
	if (not skipRecListToTabel and fOnlyPL) or (fOnlyPL <> fOldOnlyPL) then
	begin
		recListToTabel(false, false);
		if AutoSizeColumns then
			for u:=0 to fPlaylist.count-1 do
      	ProcessTextLength(TempCanvas.Canvas, fPlaylist.Items[u], ColumnTags, TextLengths, length(ColumnTags), CharWidth)
	end;

	if (not fOnlyPL) or (fOnlyPL and filterstrings) then
	begin
		if not fOnlyPL then
    begin
			MoveAddRecListToReclist;
      if (reclist.Count <> tabel.RootNodeCount) then
      	ReclistToTabel(false, false)
    end;

    //	(start) replacement for isVisible
  	visibleCount := 0;//tabel.VisibleCount;
//  	tabelRoot := tabel.RootNode;
    totalNodeHeight := 0;//tabel.rootnode.NodeHeight;
	  // 	(stop) replacement for isVisible

    aNode := tabel.GetFirst;
    while aNode <> nil do
      begin
        NodeVisible := false;
        ////////////////////// REPLACEMENT CODE: 28/02-2005
        //if fOnlyPL then
        //  rec := getRec(aNode);
        //else
        //	rec := reclist.List^[aNode.index];
        rec := PTreeData(integer(@aNode.Data) + 4).p;

        if filterRec(rec) then
        begin
          inc(fileCount);
          inc(time, rec.Length);
          NodeVisible := true
        end;

        {if fOnlyPL then
        begin
          rec := getRec(aNode);
          if filterRec(rec) then
          begin
            inc(fileCount);
            inc(time, rec.Length);
            NodeVisible := true
          end
        end
        else
        begin
          if filterrec(reclist.List^[aNode.index]) then
          begin
            inc(fileCount);
            inc(time, Prec(reclist.List^[aNode.Index]).Length);
            NodeVisible := true
          end
        end;  }

        if NodeVisible then
				begin
        	inc(VisibleCount);
          inc(TotalNodeHeight, aNode.nodeHeight);
          include(aNode.States, vsVisible);

        	if AutoSizeColumns then
          	ProcessTextLength(TempCanvas.Canvas, rec, ColumnTags, TextLengths, length(ColumnTags), CharWidth)
      	end
        else
        begin
        	Exclude(aNode.States, vsVisible);
          //De-select the node
          tabel.Selected[aNode] := false
        end;

        aNode := aNode.NextSibling
      end;

    //	(start) replacement for isVisible
    tabel.TreeStates := tabel.TreeStates + [tsValidationNeeded] - [tsUseCache]; //	= TBaseVirtualTree.InvalidateCache;
    tabel.VisibleCount := visibleCount;
    tabel.rootnode.TotalHeight := tabel.rootnode.NodeHeight + TotalNodeHeight;
    if visibleCount = 0 then
	    Include(tabel.rootnode.States, vsAllChildrenHidden)
    else
    	Exclude(tabel.rootnode.States, vsAllChildrenHidden)
	end;

  begin
    //resizer columns:
    if AutoSizeColumns then
    begin
      for i:=0 to length(ColumnIndexes)-1 do
      begin
        if TextLengths[i] = 0 then
          ShowColumns[ColumnIndexes[i]] := false
        else tabel.Header.Columns[ColumnIndexes[i]].Width := TextLengths[i]+16
      end
    end;

    if Pref.HideInfoShownInTree.Checked or AutoSizeColumns then
      for i:=0 to length(ShowColumns)-1 do
        if ShowColumns[i] then
          tabel.Header.Columns[i].Options := tabel.Header.Columns[i].Options + [coVisible]
        else tabel.Header.Columns[i].Options := tabel.Header.Columns[i].Options - [coVisible];

    filterBar.Hint := GetText(TXT_TotalPlayingTime, [IntTimeToStr(Time, true, true), inttostr(fileCount)])
  end;

//  label1.Caption := inttostr(gettickcount-start)
end;

Procedure TMainForm.UpdateCustomFieldName(index: Integer);
var
	i: Integer;
begin
  pref.SearchInFields.Items[PREDEFINED_SEARCHINFIELDCOUNT + index] := PCustomField(FieldList.Items[index]).Name;

	for i:=0 to tabel.Header.Columns.Count-1 do
  	if tabel.Header.Columns[i].Tag = FCustomField + Index then
    	tabel.Header.Columns[i].Text := PCustomField(FieldList.Items[index]).Name;

  for i:=0 to Winplaylist.Header.Columns.Count-1 do
  	if Winplaylist.Header.Columns[i].Tag = FCustomField + Index then
    	Winplaylist.Header.Columns[i].Text := PCustomField(FieldList.Items[index]).Name;
end;

Function TMainForm.isPlayingInWinamp(const fn:string):Boolean;
var
	posi:integer;
  name:Pchar;
begin
	Posi := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
  name := pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTFILE));
  result := Q_SameText(fn, name)
end;

procedure TMainForm.WMNCHitTest(var M: TWMNCHitTest);
function Test(x: integer; y: integer; w: integer; h: integer): Boolean;
begin
	result :=  (clientHeight > WindowShadeHeight) and PtInRect(Rect(x, y, x+w, y+h), MainFormInstance.ScreenToClient(mouse.cursorpos))
end;
procedure SetResult(value: Integer);
begin
	setWindowLong(MainFormInstance.Handle, GWL_STYLE, GetWindowLong(MainFormInstance.Handle,GWL_STYLE) or WS_THICKFRAME);
	M.Result := value
end;
begin
	inherited;
	if not PartyMode1.Checked and not winmaximized and (M.Result = HTClient) then
	begin
		if Test(0, 0, 10, 10) then
			SetResult(HTTOPLEFT)
		else
		if Test(clientWidth - 20, clientHeight - 20, 20, 20) then
			SetResult(HTBOTTOMRIGHT)
		else
		if Test(0, clientHeight - 15, 8, 15) then
			SetResult(HTBOTTOMLEFT)
		else
		if Test(0, clientHeight - 8, clientWidth, 8) then
			SetResult(HTBOTTOM)
		else
		if Test(clientWidth-imgRight.Width, iUp.Height, imgRight.Width, clientHeight) then
			SetResult(HTRIGHT)
		else
		if Test(0, 0, 8, clientHeight) then
			SetResult(HTLEFT)
	end
end;

Procedure TMainForm.WMEraseBkGnd;
Begin
	msg.result := 1;
End;

Function TMainForm.globalshortcuthandle(key:Word; shift:Tshiftstate):boolean;
Begin
	result := CheckPopUpMenuFromKey(nil, global, key, shift)
End;

Procedure TMainForm.Checkdrives(checkIfPlaylistsExists :boolean);
procedure UpdateFileRoot(dbIndex:integer; pathSwapArr: array of TTwoStrings);
var
	i, pathIdx:integer;
  rec:Prec;
  aNode, bNode:PvirtualNode;
  Data:PTreeRec;
  swpArr: array of TTwoStrings;
begin
  //Check if we need to run this method?
  for i:=0 to length(pathSwapArr)-1 do
  	if (length(pathSwapArr[i].s1)>0) and (length(pathSwapArr[i].s2)>0) and not Q_SameText(pathSwapArr[i].s1, pathSwapArr[i].s2) then
    begin
    	SetLength(swpArr, length(swpArr)+1);
      swpArr[length(swpArr)-1] := pathSwapArr[i]
    end;

  if length(swpArr) = 0 then
  	exit;

  //reclist
  for i:=0 to reclist.Count-1 do
  begin
  	rec := reclist.List^[i];
    if rec.location = dbIndex then
    begin
      for pathIdx:=0 to length(swpArr)-1 do
      	if Q_SameTextL(getFtextP(rec, FFILEPATH), swpArr[pathIdx].s1, length(swpArr[pathIdx].s1)) then
        begin
        	BeginSetArtistAlbumFilename;
          try
          	rec.Fpath := setFpath(swpArr[pathIdx].s2 + Q_CopyFrom(getFtextP(rec, FFILEPATH), length(swpArr[pathIdx].s2)+1))
          finally
          	EndSetArtistAlbumFilename;
          end;
          break
        end
    end;
  end;

  //tree
  if showmedia1.Checked then
  begin
    aNode := tree.getfirst;
    while aNode <> nil do
    begin
      Data := tree.GetNodeData(aNode);
      if (data.kind in [TreeKind_Drive, TreeKind_DriveRecursive]) and (data.location = dbindex) then
      begin
        bNode := aNode.Parent;
        if assigned(bNode) and (PTreeRec(tree.GetNodeData(bNode)).kind in [TreeKind_Zip, TreeKind_CDrom]) then
          for pathIdx:=0 to length(swpArr)-1 do
            if Q_SameTextL(swpArr[pathIdx].s1, data.text, 2) then
            begin
              data.Text := Q_CopyRange(swpArr[pathIdx].s2, 1,2);
              break
            end
      end;
      aNode := tree.GetNext(aNode)
    end
  end
end;

var
	u, dbIdx, pathIdx:integer;
  ld : DWORD;
  snr:DWord;
  exists, needUpdate:boolean;
  path:string;
  pathSwapArr: array of TTwoStrings;
  VolumeName, FileSystemName     : array [0..MAX_PATH-1] of Char;
  MaxComponentLength,FileSystemFlags    : Dword;
  DirExistsThread : TDirExistsThread;
//  startTime: DWord;
begin
	screen.cursor := crhourglass;

  needUpdate := false;

  for dbIdx:=0 to length(dbs)-1 do
  begin
    if dbs[dbIdx].Loaded and (dbs[dbIdx].Media in [media_removable, media_cdrom]) then
    begin
    	exists := false;
      SetLength(pathSwapArr, length(dbs[dbIdx].paths));

      for pathIdx:=0 to length(dbs[dbIdx].paths)-1 do
      begin
      	if not Q_SameStrL('\\', dbs[dbIdx].Paths[pathIdx], 2) then	//Don't do network-drives
        begin
        	pathSwapArr[pathIdx].s1 := dbs[dbIdx].paths[pathIdx];

          snr := Dword(dbs[dbIdx].Snrs[pathIdx]);
          path := Q_CopyRange(dbs[dbIdx].Paths[pathIdx], 1, Q_StrScan(dbs[dbIdx].Paths[pathIdx], '\'));

          //prver frst det sidste drev
          exists := DrivePresent(path[1]);
          if exists and GetVolumeInformation(pchar(copy(path,1,3)),VolumeName,MAX_PATH,@VolumeSerialNo,MaxComponentLength,FileSystemFlags,FileSystemName,MAX_PATH) then
	          exists := snr = volumeserialNo
          else
          	exists := false;
          //eo prver

          if not exists then
          begin //lber alle drev igennem
          	ld := GetLogicalDrives;
	          for u := 2 to 25 do
          	begin
            	if ((ld and (1 shl u)) <> 0) and (GetDriveType(pchar(Char(Ord('A') + u) + ':\')) in [DRIVE_CDROM, DRIVE_REMOVABLE]) then
		          begin
			          if DrivePresent(Char(Ord('A') + u)) then
				          if GetVolumeInformation(pchar(Char(Ord('A') + u) + ':\'),VolumeName,MAX_PATH,@VolumeSerialNo,MaxComponentLength,FileSystemFlags,FileSystemName,MAX_PATH) then
					          if snr = volumeserialNo then
					          begin //fundet
						          exists:= true;
                      path := Char(Ord('A') + u) + ':\';
                      needUpdate := true;
                      break //drives
                    end
          		end
          	end
          end;	//of if not exists

          dbs[dbIdx].paths[pathIdx] := path + Q_CopyFrom(dbs[dbIdx].paths[pathIdx], 4); // TODO: may be unsafe
          pathSwapArr[pathIdx].s2 := dbs[dbIdx].paths[pathIdx];
          dbs[dbIdx].exists := exists
        end
        else
        begin
        	//If we go here, the path is a newwork path
          DirExistsThread := TDirExistsThread.Create(dbs[dbIdx].Name, dbs[dbIdx].paths[pathIdx], dbIdx);
          DirExistsThread.Resume;
        end
      end;	//of iterating paths

      UpdateFileRoot(dbIdx, pathSwapArr)
    end
    else	//dbs[dbIdx].Media not in [media_removable, media_cdrom]
    if dbs[dbIdx].Loaded then
    begin
    	dbs[dbIdx].exists := false;
      for pathIdx:=0 to length(dbs[dbIdx].paths)-1 do
      begin
      	if (dbs[dbIdx].Media = media_network) or Q_SameStrL('\\', dbs[dbIdx].Paths[pathIdx], 2) then
        begin
	      	DirExistsThread := TDirExistsThread.Create(dbs[dbIdx].Name, dbs[dbIdx].paths[pathIdx], dbIdx);
	        DirExistsThread.Resume
        end
        else
        begin
        	try
	        	dbs[dbIdx].exists := dbs[dbIdx].exists or (DirectoryExists(dbs[dbIdx].Paths[pathIdx]))
          except
          end
        end
      end
    end;
  end;

  if NeedUpdate then
  	UpdateHashedReclist;

  UpdateTreeExistsFlag(CheckIfPlaylistsExists);

  if tabel.UpdateCount = 0 then
	  tabel.repaint;
	screen.cursor := crdefault
end;

procedure TMainForm.UpdateTreeExistsFlag(checkIfPlaylistsExists :boolean);
var
	aNode: PVirtualNode;
  TR:PTreeRec;
  PL:PplRec;
begin
  if showmedia1.Checked then
  begin
    tree.BeginUpdate;

    aNode := tree.getfirst;
    while aNode <> nil do
    begin
      TR := tree.GetNodeData(aNode);
      if TR.kind = TreeKind_Playlist then
      begin
      	PL := TR.PlRecRef;
        if checkIfPlaylistsExists then
	        TR.Exists := assigned(PL) and FileExists(PL.Filename)
        else
					TR.Exists := assigned(PL) and ((PL.location = -1) or dbs[PL.location].Exists);
      end
      else
      begin
      	TR.Exists := (TR.Location = -1) or dbs[TR.Location].Exists
      end;

      aNode := tree.GetNext(aNode)
    end;

  	tree.endupdate
  end;
end;

constructor TDirExistsThread.create(name, path: string; DbIndex: integer);
begin
	inherited Create(true);
  self.FreeOnTerminate := true;
  Fname := name;
  Fpath := path;
  FDbIndex := dbIndex;
end;

Procedure TDirExistsThread.Execute;
begin
	if NetDirTest.NewDirThread(FPath, 8000, FDbIndex, FName) = trDirectoryExists then 	//Wait for max 8 seconds
  	Synchronize(SetDirExists)
end;

Procedure TDirExistsThread.SetDirExists;
begin
  if (length(dbs) > FDbIndex) and Q_SameStr(dbs[FDbIndex].name, Fname) and not dbs[FDbIndex].exists then
  begin
    dbs[FDbIndex].exists := true;
    MainFormInstance.UpdateTreeExistsFlag(false)
  end
end;

//function TMainForm.Encrypt(S: String; Key: Word): String;
function Encrypt(const S: String; Key: Word): String;
const
     C1 = 52845;
     C2 = 22719;
var
   I: Integer;
begin
  Result := S;
  for I := 1 to Length(S) do
      begin
           Result[I] := char(byte(S[I]) xor (Key shr 8));
           Key := (byte(Result[I]) + Key) * C1 + C2;
      end;
end;

Function  TMainForm.Getkey(name : string) : integer;
const
		 C1 = 52845;
     C2 = 22719;
var     i, total:integer;
				s, key, k:string;
        c:char;
        ke:word;
begin
  s := name;
  if Q_SameText(s, 'MISIEK@EFC87.POLAND_TEAM') or Q_SameText(s, 'bennizilin') or Q_SameText(s, 'nemesis]tnt!crack!team') or Q_SameText(s, 'weed2k [tca]') or (length(s) < 8) then
  begin
  	result := -1;
    exit
  end;
  for i:=1 to length(s) do s[i] := chr(ord(s[i]) + 29 + i);
  total := 0;
  for i:=1 to length(s) do total := total + ord(s[i]) + i*(8*(i div 2));
  total := ((20 * total) div length(inttostr(total))) * (length(name)*2 );
  key := inttostr(total+999);
  if not ((strtoint(key[3] + key[6]) + 65) in [65..91]) then key[1] := 'H' else key[1] := chr(strtoint(key[3] + key[6]) + 65);
  if not ((strtoint(key[2] + key[4]) + 65) in [65..91]) then key[2] := 'E' else key[2] := chr(strtoint(key[2] + key[4]) + 65);
  c := key[3]; key[3] := key[1]; key[1] := c;
  c := key[4]; key[4] := key[5]; key[5] := c;
  c := key[6]; key[6] := key[2]; key[2] := c;
  //        k := key;
  //        Result := S;
  k := key;
  ke:=26548;
  for I := 1 to Length(key) do
  begin
    k[I] := char(byte(key[I]) xor (ke shr 8));
    ke := (byte(k[I]) + ke){ * C1 + C2};
  end;
  ///        k := encrypt(key, 26548);
  key := k;
  total := 0;
  for i:=1 to length(key) do total := ord(key[i]) + total;
  result := total * 47;
  //				result := Key;
end;

Procedure TMainForm.CheckAutoSkin;
function GetWinampSkin: String;
begin
	result := trim(pchar(SendMessage(hwnd_winamp, WM_WA_IPC, 0, 201)));
	if result = '' then
		result := 'Base'
	else result := GetFileName(result, false)
end;
var
	i, oldIndex, found: Integer;
	s: String;
begin
	oldIndex := -1;
	if Length(CurrentWinampSkin) = 0 then //frste gang denne metode kaldes
		CurrentWinampSkin := GetWinampSkin
	else
  begin
  	s := GetWinampSkin;
    if not Q_SameText(s, CurrentWinampSkin) then
		begin
			CurrentWinampSkin := s;
      InitSnap;
      if not FSnap.Started then FSnap.Start;

   	 	if pref.AutoChangeSkin.Checked then
			begin
        found := -1;
        for i:=0 to Length(SkinArray)-1 do
        begin
          if Q_SameText(s, SkinArray[i].CorrespondTo) then
            found := i
        end;
        if found >= 0 then
        begin
          //finder oldIndex
          for i:=0 to Length(SkinArray)-1 do
            if Q_SameText(CurrentSkin, SkinArray[i].Name) then
              oldIndex := i;

          for i:=0 to Length(SkinArray)-1 do
            if i = found then
            begin
              if not SkinArray[i].InUse then
              begin
                CurrentSkin := SkinArray[i].Name;
                LoadSkin(i, oldIndex);
                SetSlidersAndPanelFonts;
                MainFormInstance.repaint
              end;
              SkinArray[i].InUse := true
            end
            else
              SkinArray[i].InUse := false
        end
      end
    end
	end
end;

function TMainForm.SupportedSkinFileVersion(fv: Word):Boolean;
var
	i: Integer;
begin
	result := false;
	for i:=1 to length(SupportedSkin_FileVer) do
		result := result or (fv = SupportedSkin_FileVer[i])
end;

Function TMainForm.LoadSkinProperties(const skinFileName: String; var Author, AuthorURL, CorrespondTo, CorrespondToURL, Comments: String): Boolean;
//retunerer true hvis skin er valid
Function LoadString(FStr: TStream): String;
var
	w, i: word;
	c: Char;
begin
	FStr.Read(w, SizeOf(w));
	result := '';
	for i:=1 to w do
	begin
		FStr.Read(c, 1);
		result := result + c
	end
end;
var
	FStr: TStream;
	FV: Word;
	Ident: Integer;
begin
	result := false;

	if not FileExists(skinFileName) then
		exit;

	try
		FStr := TFileStream.Create(skinFileName, fmOpenRead);
	except
		exit
	end;

	try
		FStr.Read(Ident, SizeOf(Ident));
		FStr.Read(FV, SizeOf(FV));
		if (Ident = SkinFileIdent) and SupportedSkinFileVersion(FV) then
		begin
			Author := LoadString(FStr);
			CorrespondTo := LoadString(FStr);
			Comments := LoadString(FStr);
      if FV >= 4 then
      begin
      	AuthorURL := LoadString(FStr);
        CorrespondToURL := LoadString(FStr)
      end
      else
      begin
				AuthorURL := '';
        CorrespondToURL := ''
      end;

			result := true
		end;
		FStr.Free
	except
		result := false
	end
end;

Procedure TMainForm.LoadSkin(const index: Integer; OldIndex: Integer = -1);
Function LoadColor(const FStr: TStream): TColor;
begin
	FStr.Read(result, SizeOf(TColor));
end;

Procedure LoadImage(const FStr: TStream; const Img: TBitmap);
begin
	Img.LoadFromStream(Fstr);
end;

Function LoadInteger(const FStr: TStream):Integer;
begin
	FStr.Read(result, SizeOf(Integer))
end;
var
	FStr: TStream;
	FV, w: Word;
	Ident, i, imgCount, j, k: Integer;
	byt: Byte;
	img: TBitmap;
	BitmappedScrollBars: Boolean;
begin
	if not FileExists(SkinArray[index].Filename) then
		exit;

	if OldIndex >= 0 then
		SaveFontColorSettings(OldIndex);

	FStr := nil;
	try
		FStr := TFileStream.Create(SkinArray[index].Filename, fmOpenRead);
	except end;

	try
		FStr.Read(Ident, SizeOf(Ident));
		FStr.Read(FV, SizeOf(Word));
		if (Ident = SkinFileIdent) and SupportedSkinFileVersion(FV) then
		begin
			CurrentSkinDate := FileAge(SkinArray[index].Filename);

			//springer over Author, Correspond og Comments
      if FV >= 4 then
      	j := 5
      else
      	j := 3;
			for i:=1 to j do
			begin
				FStr.Read(w, SizeOf(w));
				FStr.Seek(w, soFromCurrent)
			end;

			//henter positioner
      FStr.Read(ShuffleImgPos, SizeOf(TPoint));
			FStr.Read(RepeatImgPos, SizeOf(TPoint));
			FStr.Read(ConfigImgPos, SizeOf(TPoint));

			FStr.Read(VolbarImgPos, SizeOf(TPoint));
			FStr.Read(VolbarWidth, SizeOf(Integer));

			FStr.Read(PrevRect, SizeOf(TRect));
			FStr.Read(PlayRect, SizeOf(TRect));
			FStr.Read(PauseRect, SizeOf(TRect));
			FStr.Read(StopRect, SizeOf(TRect));
			FStr.Read(NextRect, SizeOf(TRect));

			//Scrollbars
			FStr.Read(BitmappedScrollBars, SizeOf(Boolean));

			if BitmappedScrollBars then
			begin
				TreeScrollV.BM_UpArrowHeight := LoadInteger(FStr);
				TreeScrollV.TrackbarYpos := LoadInteger(FStr);
				TreeScrollV.BM_TtrackbarStopFromBottom := LoadInteger(FStr);

				TreeScrollH.BM_UpArrowHeight := LoadInteger(FStr);
				TreeScrollH.TrackbarYpos := LoadInteger(FStr);
				TreeScrollH.BM_TtrackbarStopFromBottom := LoadInteger(FStr);

				for i:=7 to 12 do
					LoadImage(FStr, ScrollBarImgs[i])
			end;
			TreeScrollH.Bitmapped := BitmappedScrollBars;
			TreeScrollV.Bitmapped := BitmappedScrollBars;

			//Lser farver:
			//Main list
			tabel.Color := LoadColor(Fstr);
      if FV >= 4 then
      	TabelOddRowColor := Loadcolor(FStr)
      else
      	TabelOddRowColor := tabel.Color;
			tabelSelTextColor := LoadColor(Fstr);
			tabel.Colors.FocusedSelectionColor := LoadColor(Fstr);
			tabel.Colors.UnfocusedSelectionColor := LoadColor(Fstr);
			tabel.Colors.DropMarkColor := LoadColor(Fstr);
			tabel.Colors.DropTargetColor := LoadColor(Fstr);
			tabel.Header.Background := LoadColor(Fstr);
			tabel.Header.Font.Color := LoadColor(Fstr);

      if FV >= 4 then
      begin
      	FSkinMainlistColorStarBright := LoadColor(FStr);
        FSkinMainlistColorStarDark := LoadColor(FStr)
      end
      else
      begin
      	FSkinMainlistColorStarBright := clYellow;
  			FSkinMainlistColorStarDark := clGreen
      end;

			//Tree
			Tree.Color := LoadColor(Fstr);
      if FV >= 4 then
      	TreeOddRowColor := Loadcolor(FStr)
      else
      	TreeOddRowColor := Tree.Color;
			TreeSelTextColor := LoadColor(Fstr);
			Tree.Colors.FocusedSelectionColor := LoadColor(Fstr);
			Tree.Colors.UnfocusedSelectionColor := LoadColor(Fstr);
			Tree.Colors.DropMarkColor := LoadColor(Fstr);
			Tree.Colors.DropTargetColor := LoadColor(Fstr);
			Tree.Colors.TreeLineColor := LoadColor(Fstr);
			if FV > 1 then
			begin
				Tree.Colors.TreeLineButtonColor := LoadColor(FStr);
				Tree.Font.Color := LoadColor(FStr)
			end
			else
			begin
				Tree.Colors.TreeLineButtonColor := clBlack;
				Tree.Font.Color := clLime
			end;

      if FV >= 5 then
      begin
      	FSkinTreeColorStarBright := LoadColor(FStr);
        FSkinTreeColorStarDark := LoadColor(FStr);
      end
      else
      begin
      	FSkinTreeColorStarBright := clYellow;
        FSkinTreeColorStarDark := clGreen
      end;

			//Winplaylist
			WinPlayList.Color := LoadColor(Fstr);
      if FV >= 4 then
      	WinplaylistOddRowColor := Loadcolor(FStr)
      else
      	WinplaylistOddRowColor := WinPlayList.Color;
			winplaylistSelTextColor := LoadColor(Fstr);
			WinPlayList.Colors.FocusedSelectionColor := LoadColor(Fstr);
			WinPlayList.Colors.UnfocusedSelectionColor := LoadColor(Fstr);
			WinPlayList.Colors.DropMarkColor := LoadColor(Fstr);
			WinPlayList.Colors.DropTargetColor := LoadColor(Fstr);
			WinPlayList.Font.Color := LoadColor(Fstr);
			Winplayingcolor := LoadColor(Fstr);
			WinKillcolor := LoadColor(Fstr);
      if FV >= 4 then
      begin
      	FSkinWinplaylistColorStarBright := LoadColor(FStr);
        FSkinWinplaylistColorStarDark := LoadColor(FStr)
      end
      else
      begin
      	FSkinWinplaylistColorStarBright := clYellow;
  			FSkinWinplaylistColorStarDark := clGreen
      end;

			//Playlistbox
			Playlistbox.Color := LoadColor(Fstr);
      if FV >= 4 then
    		QuicklistOddRowColor := Loadcolor(FStr)
      else
      	QuicklistOddRowColor := Playlistbox.Color;
			PlaylistboxSelTextColor := LoadColor(Fstr);
			Playlistbox.Colors.FocusedSelectionColor := LoadColor(Fstr);
			Playlistbox.Colors.UnfocusedSelectionColor := LoadColor(Fstr);
			Playlistbox.Colors.DropMarkColor := LoadColor(Fstr);
			Playlistbox.Colors.DropTargetColor := LoadColor(Fstr);
			Playlistbox.Font.Color := LoadColor(Fstr);

			//PLcon
			PLcon.Color := LoadColor(Fstr);
      if FV >= 4 then
      	QuicklistContentOddRowColor := Loadcolor(FStr)
      else
      	QuicklistContentOddRowColor := PLcon.Color;
			PLconSelTextColor := LoadColor(Fstr);
			PLcon.Colors.FocusedSelectionColor := LoadColor(Fstr);
			PLcon.Colors.UnfocusedSelectionColor := LoadColor(Fstr);
			PLcon.Colors.DropMarkColor := LoadColor(Fstr);
			PLcon.Colors.DropTargetColor := LoadColor(Fstr);
			PLcon.Font.Color := LoadColor(Fstr);

			//Other
			panel1.Color := LoadColor(Fstr); //sliders
			TreeScrollH.Color := LoadColor(Fstr);
			panel1.Font.Color  := LoadColor(Fstr);
			CollapseButton.Font.Color := LoadColor(Fstr);
			FCurPlayBitmap.Canvas.Font.Color := LoadColor(FStr);
			TimerColor := LoadColor(FStr);
			F0Textcolor := LoadColor(FStr);
			CaptionStatusTextColor := LoadColor(FStr);
			LowerSmallPanel.Color := LoadColor(FStr);

			if FV > 1 then
			begin
				tabel.Colors.SelectionRectangleBlendColor := LoadColor(FStr);
				tabel.Colors.SelectionRectangleBorderColor := LoadColor(FStr)
			end else
			begin
				tabel.Colors.SelectionRectangleBlendColor :=  clHighlight;
				tabel.Colors.SelectionRectangleBorderColor := clHighlight
			end;

      if FV >= 4 then
      begin
      	//Database colors
        FStr.Read(j, 4);
        k := min(11, j);
        for i:=0 to k-1 do
        	FStr.Read(FSkinDbColors[i], SizeOf(FSkinDbColors[i]));

        for i:=0 to j - 11 - 1 do
        	FStr.Seek(SizeOf(FSkinDbColors[0]), soFromCurrent);
      end
      else
      begin
      	FSkinDbColors[0] := clLime;
        FSkinDbColors[1] := $000080FF;
        FSkinDbColors[2] := $00FF8000;
        FSkinDbColors[3] := $008282FF;
        FSkinDbColors[4] := $00D7D7D7;
        FSkinDbColors[5] := $00FFA4CF;
        FSkinDbColors[6] := $00C0DFFE;
        FSkinDbColors[7] := $00FCD8AB;
        FSkinDbColors[8] := $00DDFEA7;
        FSkinDbColors[9] := $00EDD8E6;
        FSkinDbColors[10] := $00AEFFFF
      end;
			//eo. ls farver

			FStr.Read(imgCount, SizeOf(imgCount));
			//ls MEXP ramme
			LoadImage(Fstr, iupLeft);												//1
			LoadImage(Fstr, iup);                           //2
			LoadImage(Fstr, iArc);                      		//3
			LoadImage(Fstr, iupRight);                      //4

			LoadImage(Fstr, iupLeftShade);                  //5
			LoadImage(Fstr, iupShade);                      //6
			LoadImage(Fstr, iArcShade);                 		//7
			LoadImage(Fstr, iupRightShade);                 //8

			LoadImage(Fstr, ImgLeft);                       //9
			LoadImage(FStr, iUpBlank);											//10
			LoadImage(Fstr, ImgRight);                      //11

			LoadImage(Fstr, imglowerleft);                //12
			LoadImage(Fstr, ImgLower);                      //13
			LoadImage(Fstr, imglowerright);   	            //14

			LoadImage(FStr, imgShuffle);				//15
			LoadImage(FStr, imgRepeat);					//16
			LoadImage(FStr, imgConfig);					//17

			//Volume Controls
			LoadImage(Fstr, ImgVolSliderBtn);                        //18
			imgVolSliderBtn.transparent := True;
			imgVolSliderBtn.TransparentColor := clFuchsia;
			imgVolSliderBtn.TransparentMode := tmFixed;

			//slider
			LoadImage(Fstr, imgSlider);  											//19
			LoadImage(Fstr, imgSliderBtn);                //20
			imgSliderBtn.transparent := True;
			imgSliderBtn.TransparentColor := clFuchsia;
			imgSliderBtn.TransparentMode := tmAuto;

			for i:=1 to 6 do
				ScrollBarImgs[i].LoadFromStream(Fstr);

			img := TBitmap.Create;

			for i:= 26 to ImgCount-1 do
				img.LoadFromStream(FStr); //lser forbi eventuelle billeder, der ikke er understttet i denne version af mexp

			FStr.Read(imgCount, SizeOf(imgCount));	//lser antal ikoner
			TreeImgs.Clear;
			for i:=1 to imgCount do
			begin
				img.LoadFromStream(Fstr);
				TreeImgs.AddMasked(img, clFuchsia)
			end;

			img.free;

			if FV >= 2 then //blendFactor
			begin
				FStr.Read(byt, SizeOf(byt));
				tabel.SelectionBlendFactor := byt
			end
			else
				tabel.SelectionBlendFactor := 100;

			if FV >= 3 then
			begin
				FStr.Read(PosSliderLrgPos, SizeOf(PosSliderLrgPos));
				FStr.Read(PosSliderLrgStopFromEnd, SizeOf(PosSliderLrgStopFromEnd));
				FStr.Read(PosSliderSmallPos, SizeOf(PosSliderSmallPos));
				FStr.Read(PosSliderSmallStopFromEnd, SizeOf(PosSliderSmallStopFromEnd))
			end
			else
			begin
				PosSliderLrgPos := point(130, 20);
				PosSliderLrgStopFromEnd := 160;
				PosSliderSmallPos := point(4, 16);
				PosSliderSmallStopFromEnd := 8
			end
		end
	except
	end;
	if assigned(FStr) then
		try
			FStr.free
		except
		end;

	//lser fonts og Check om farver skal overskrives:
	LoadFontColorSettings(index)
	//	SetSlidersAndPanelFonts - > skal ikke sttes her
end;

Function TMainForm.GetFontColorSettingsFile(index: Integer): String;
begin
	result := Settingsdir + 'Color settings\' + SkinArray[index].Name + '.ini'
end;

Procedure TMainForm.SaveFontColorSettings(index: Integer);
procedure SaveColor(reg:TMexpIniFile; const key: string; clr:TColor);
begin
	try
		reg.WriteBinaryData('Clr_' + key, clr, sizeof(clr));
	except
	end
end;

procedure SaveFont(Reg:TMexpIniFile; name: String; value: TFont);
var     F:TFNT;
begin
    try
			 F.Fontname := value.Name;
       F.Size := value.size;
       F.Charset := value.Charset;
       F.Color := value.color;
       F.Pitch := value.Pitch;
       F.Bold := fsBold in value.Style;
			 F.Italic := fsItalic in value.style;
       F.Underline := fsUnderline in Value.style;
       F.StrikeOut := fsStrikeOut in Value.Style;
			 reg.WriteBinaryData(name, F, sizeof(F))
    except
    end;
end;
var
	ColorSettings: TMexpIniFile;
begin
	ForceDirectories(GetFilePath(GetFontColorSettingsFile(index)));
	ColorSettings := TMexpIniFile.Create(GetFontColorSettingsFile(index));

	ColorSettings.ClearAllValues;

	SaveFont(ColorSettings, 'ListFont',tabel.font);
	SaveFont(ColorSettings, 'TreeFont',tree.font);
	SaveFont(ColorSettings, 'QLFont1',playlistbox.font);
	SaveFont(ColorSettings, 'QLFont2',plcon.font);
	SaveFont(ColorSettings, 'WinplaylistFont',winplaylist.font);
	SaveFont(ColorSettings, 'SplittersFont',panel1.Font);
	SaveFont(ColorSettings, 'CaptionFont',CollapseButton.font);
	SaveFont(ColorSettings, 'PlayLabelFont', FCurPlayBitmap.Canvas.Font);

	if pref.AllowColorOverride.Checked then
	begin
		SaveColor(ColorSettings, 'ListColor',(tabel.color));
		SaveColor(ColorSettings, 'TreeColor',(tree.color));
		SaveColor(ColorSettings, 'QLColor1',(playlistbox.color));
		SaveColor(ColorSettings, 'QLColor2',(plcon.color));
		SaveColor(ColorSettings, 'WinplaylistColor',(winplaylist.color));
		SaveColor(ColorSettings, 'SplittersColor',(panel1.color));

		SaveColor(ColorSettings, 'tabelFocused', (tabel.colors.FocusedSelectionColor));
		SaveColor(ColorSettings, 'treeFocused', (tree.colors.FocusedSelectionColor));
		SaveColor(ColorSettings, 'WinplayFocused', (winplaylist.colors.FocusedSelectionColor));
		SaveColor(ColorSettings, 'PlBoxFocused', (playlistbox.colors.FocusedSelectionColor));
		SaveColor(ColorSettings, 'plconFocused', (plcon.colors.FocusedSelectionColor));

		SaveColor(ColorSettings, 'tabelUnFocused', (tabel.colors.UnFocusedSelectionColor));
		SaveColor(ColorSettings, 'treeUnFocused', (tree.colors.UnFocusedSelectionColor));
		SaveColor(ColorSettings, 'WinplayUnFocused', (winplaylist.colors.UnFocusedSelectionColor));
		SaveColor(ColorSettings, 'PlBoxUnFocused', (playlistbox.colors.FocusedSelectionColor));
		SaveColor(ColorSettings, 'plconUnFocused', (plcon.colors.UnFocusedSelectionColor));

		SaveColor(ColorSettings, 'tabelSelColor', (tabelseltextcolor));
		SaveColor(ColorSettings, 'treeSelColor', (treeseltextcolor));
		SaveColor(ColorSettings, 'winplaySelColor', (winplaylistSelTextColor));
		SaveColor(ColorSettings, 'playlistboxselColor', (PlaylistboxSelTextColor));
		SaveColor(ColorSettings, 'plconselColor', (plconSelTextColor));
		SaveColor(ColorSettings, 'winplayingcolor', (Winplayingcolor));
		SaveColor(ColorSettings, 'WinKillcolor', WinKillcolor);

		SaveColor(ColorSettings, 'TabelHeaderColor', (tabel.header.Background));
		SaveColor(ColorSettings, 'TabelHeaderTextColor', (tabel.header.font.color));

		SaveColor(ColorSettings, 'SearchFontColor', (F0Textcolor))
	end;
	ColorSettings.Free
end;

Procedure TMainForm.LoadFontColorSettings(index: Integer);
function LoadFont(reg:TMexpIniFile; const key: string; font:TFont):boolean;
var
	F:TFNT;
begin
	result := false;
	if reg.valueexists(key) then
	try
		reg.ReadBinaryData(key, F, sizeof(F));
		Font.Name := f.fontname;
		Font.size := f.size;
		Font.Charset := f.Charset;
		if pref.AllowColorOverride.Checked then
			Font.Color := F.Color;
		Font.Pitch := F.Pitch;
		Font.style := [];
		if F.Bold then font.style := font.style + [fsBold];
		if F.Italic then font.style := font.style + [fsItalic];
		if F.Underline then font.style := font.style + [fsUnderline];
		if F.Strikeout then font.style := font.style + [fsStrikeOut];
		result := true
	except
	end
end;

function LoadColor(reg:TMexpIniFile; const key: string; var clr:TColor):boolean;
begin
	result := false;
	if reg.valueexists('Clr_' + key) then
	try
		reg.ReadBinaryData('Clr_' + key, clr, sizeof(Tcolor));
		result := true
	except
	end
end;
var
	ColorSettings: TMexpIniFile;
	clr: TColor;
begin
	if fileExists(GetFontColorSettingsFile(index)) then
	begin
		ColorSettings := TMexpIniFile.Create(GetFontColorSettingsFile(index));

		loadfont(ColorSettings, 'ListFont', tabel.font);
		loadfont(ColorSettings, 'TreeFont', tree.font);
		loadfont(ColorSettings, 'QLFont1', playlistbox.font);
		loadfont(ColorSettings, 'QLFont2', plcon.font);
		loadfont(ColorSettings, 'WinplaylistFont', winplaylist.font);
		loadfont(ColorSettings, 'SplittersFont', panel1.Font);
		loadfont(ColorSettings, 'CaptionFont', CollapseButton.font);
		LoadFont(ColorSettings, 'PlayLabelFont', FCurPlayBitmap.Canvas.Font);

		if pref.AllowColorOverride.Checked then
		begin
			if LoadColor(ColorSettings, 'SearchFontColor', clr) then
				f0.Font.color := clr;
			F0Textcolor := f0.Font.Color;

			if LoadColor(ColorSettings, 'ListColor', clr) then
				tabel.color := clr;

			if LoadColor(ColorSettings, 'TreeColor', clr) then
				tree.color := clr;

			if LoadColor(ColorSettings, 'QLColor1', clr) then
				playlistbox.color := clr;

			if LoadColor(ColorSettings, 'QLColor2', clr) then
				plcon.color := clr;

			if LoadColor(ColorSettings, 'WinplaylistColor', clr) then
				winplaylist.color := clr;

			if LoadColor(ColorSettings, 'SplittersColor', clr) then
				panel1.color := clr;

			if LoadColor(ColorSettings, 'TabelHeaderColor', clr) then
				tabel.header.Background := clr;

			if LoadColor(ColorSettings, 'TabelHeaderTextColor', clr) then
				tabel.header.font.color := clr;

			if LoadColor(ColorSettings, 'tabelFocused',clr) then
				tabel.colors.FocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'treeFocused',clr) then
				tree.colors.FocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'WinplayFocused', clr) then
				winplaylist.colors.FocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'PlBoxFocused', clr) then
				playlistbox.colors.FocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'plconFocused', clr) then
				plcon.colors.FocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'tabelUnFocused', clr) then
				tabel.colors.UnFocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'treeUnFocused', clr) then
				tree.colors.UnFocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'WinplayUnFocused', clr) then
				winplaylist.colors.UnFocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'PlBoxUnFocused', clr) then
				playlistbox.colors.FocusedSelectionColor := clr;

			if LoadColor(ColorSettings, 'plconUnFocused', clr) then
				plcon.colors.UnFocusedSelectionColor := clr;

			LoadColor(ColorSettings, 'tabelSelColor', tabelseltextcolor);
			LoadColor(ColorSettings, 'treeSelColor', treeseltextcolor);
			LoadColor(ColorSettings, 'winplaySelColor', winplaylistSelTextColor);
			LoadColor(ColorSettings, 'playlistboxselColor', PlaylistboxSelTextColor);
			LoadColor(ColorSettings, 'plconselColor', plconSelTextColor);
			LoadColor(ColorSettings, 'winplayingcolor', Winplayingcolor);
			LoadColor(ColorSettings, 'WinKillcolor', WinKillcolor)
		end;
		ColorSettings.free
	end
end;

procedure TMainForm.SetSlidersAndPanelFonts;
procedure FixSelectionColors(vt: TVirtualStringTree);
begin
	if vt.colors.FocusedSelectionBorderColor <> vt.Colors.FocusedSelectionColor then
		vt.colors.FocusedSelectionBorderColor := vt.Colors.FocusedSelectionColor;
	if vt.colors.UnFocusedSelectionBorderColor <> vt.Colors.UnFocusedSelectionColor then
		vt.colors.UnFocusedSelectionBorderColor := vt.Colors.UnFocusedSelectionColor;
end;

procedure SetScrollbarParameters(const source, destination: TWinampScrollVert);
begin
	destination.TrackbarYpos := Source.TrackbarYpos;
	destination.BM_UpArrowHeight := Source.BM_UpArrowHeight;
	destination.BM_TtrackbarStopFromBottom := Source.BM_TtrackbarStopFromBottom;
	destination.Color := Source.Color;
	destination.Bitmapped := Source.Bitmapped
end;
var
	mixedColor: TColor;
begin
	//PANEL1
	panel1.height := abs(panel1.Font.Height) + 3;
	treeplbar.Font := panel1.font;
	treeplbar.height := abs(panel1.Font.Height) + 3;
	plconbar.Font := panel1.font;
	plconbar.height := abs(panel1.Font.Height) + 3;
	filterbar.Font := panel1.font;
	filterbar.height := abs(panel1.Font.Height) + 4;
	WPbar.Font := panel1.font;
	WPbar.height := abs(panel1.Font.Height) + 3;
	WPbarLow.Font := panel1.font;
	WPbarLow.height := abs(panel1.Font.Height) + 3;
	winplaylistTimeLabel.Font := panel1.font;
	winplaylistTimeLabel.Font.Height := abs(panel1.Font.Height) + 3;
	winplaylistCurrentTimeLabel.Font := panel1.font;
	winplaylistCurrentTimeLabel.Font.Color := TimerColor;
	winplaylistCurrentTimeLabel.Font.Height := abs(panel1.Font.Height) + 3;

	tabelbar.color:= panel1.color;
	f0.color := panel1.color;
	filterbar.color:=panel1.color;
	treeplbar.color:=panel1.color;
	plconbar.color:=panel1.color;
	WPbar.color:=panel1.color;
	WPbarLow.color:= panel1.Color;

	Winplaylist.Colors.SelectionRectangleBlendColor := tabel.Colors.SelectionRectangleBlendColor;
	Winplaylist.Colors.SelectionRectangleBorderColor := tabel.Colors.SelectionRectangleBorderColor;
	Winplaylist.SelectionBlendFactor := tabel.SelectionBlendFactor;

	PLcon.Colors.SelectionRectangleBlendColor := tabel.Colors.SelectionRectangleBlendColor;
	PLcon.Colors.SelectionRectangleBorderColor := tabel.Colors.SelectionRectangleBorderColor;
	PLcon.SelectionBlendFactor := tabel.SelectionBlendFactor;

	PlaylistBox.Colors.SelectionRectangleBlendColor := tabel.Colors.SelectionRectangleBlendColor;
	PlaylistBox.Colors.SelectionRectangleBorderColor := tabel.Colors.SelectionRectangleBorderColor;
	PlaylistBox.SelectionBlendFactor := tabel.SelectionBlendFactor;

	Tree.Colors.SelectionRectangleBlendColor := tabel.Colors.SelectionRectangleBlendColor;
	Tree.Colors.SelectionRectangleBorderColor := tabel.Colors.SelectionRectangleBorderColor;
	Tree.SelectionBlendFactor := tabel.SelectionBlendFactor;

	//minimizers //stadig panel1
	MinimizeQ1.font:=panel1.font;
	MinimizeQ2.font:=panel1.font;
	MinimizeWinplay.font:=panel1.font;
	plabel1.Font := panel1.Font;
	PLCONlabel.Font := panel1.Font;

	mixedColor := mixColors(panel1.Font.Color, tabelbar.color);
	MinimizeQ1.Font.Color := mixedColor;
	MinimizeWinplay.Font.Color := mixedColor;
	MinimizeQ2.Font.Color := mixedColor;

	MinimizeQ1.Font.Name := 'Webdings';
	MinimizeWinplay.Font.Name := 'Webdings';
	MinimizeQ2.Font.Name := 'Webdings';

	//Buttons - CollapseButton
	AllButton.font:=CollapseButton.font;
	searchlabel.font:=CollapseButton.font;
	grouplabel.font:=CollapseButton.font;
	clearButton.font:=CollapseButton.font;
	searchlabel.font:= Collapsebutton.font;
	f0.font := CollapseButton.font;
	f0.Font.Color := F0Textcolor;

	if pref.SelectionRectangle.ItemIndex = 0 then
	begin
		tabel.DrawSelectionMode := smDottedRectangle;
		Winplaylist.DrawSelectionMode := smDottedRectangle;
		plCon.DrawSelectionMode := smDottedRectangle;
		tree.DrawSelectionMode := smDottedRectangle;
		playlistbox.DrawSelectionMode := smDottedRectangle
	end
	else
	begin
		tabel.DrawSelectionMode := smBlendedRectangle;
		Winplaylist.DrawSelectionMode := smBlendedRectangle;
		plCon.DrawSelectionMode := smBlendedRectangle;
		tree.DrawSelectionMode := smBlendedRectangle;
		playlistbox.DrawSelectionMode := smBlendedRectangle
	end;

  //Headers:
  WinplayList.Header.Background := tabel.Header.Background;
	WinplayList.Header.Font := tabel.Header.Font;

	//Scrollbars:
	TreeScrollV.Color := TreeScrollH.Color; //skal vre der
	SetScrollbarParameters(TreeScrollH, TabelScrollH);

	SetScrollbarParameters(TreeScrollV, PlaylistboxScrollV);
	SetScrollbarParameters(TreeScrollV, plconScrollV);
	SetScrollbarParameters(TreeScrollV, TabelScrollV);
	SetScrollbarParameters(TreeScrollV, WinPlayScrollV);
  SetScrollbarParameters(TreeScrollV, WinPlayScrollH);

	FixSelectionColors(tabel);
	FixSelectionColors(tree);
	FixSelectionColors(winplaylist);
	FixSelectionColors(playlistbox);
	FixSelectionColors(plcon);

	//updaterer panels
	UpdateSizesTreePanel(WPbar);
	AdjustNodeHeight(winplaylist);
	AdjustNodeHeight(plcon);
	AdjustNodeHeight(tabel);
	AdjustNodeHeight(tree);
	AdjustNodeHeight(playlistbox);
	tabelbar.width := 9;
	OnResize(nil);
	if sliderTimer.Enabled then
		doSliderTimerTimer(nil);
end;

Procedure TMainForm.LoadColumnSettings;
var
	i, k: Integer;
	MLColumnArr : array of TColSave;
begin
	SetLength(TabelColumnsVisible, tabel.header.Columns.Count);

	setLength(MLColumnArr, 0);
  for i:=0 to tabel.header.columns.count-1 do
    if Settings.ValueExists('MLColumn_'+tabel.header.columns[i].text) then
    begin
      setLength(MLColumnArr, length(MLColumnArr)+1);
      Settings.ReadBinaryData('MLColumn_'+tabel.header.columns[i].text, MLColumnArr[length(MLColumnArr)-1], Sizeof(TColSave));
      tabel.header.columns[i].Width := MLColumnArr[length(MLColumnArr)-1].Width;
      TabelColumnsVisible[i] := MLColumnArr[length(MLColumnArr)-1].Visible
    end;
    ApplyTabelColumnsVisible;
    for i:=0 to length(MLColumnArr)-1 do
      for k:=0 to length(MLColumnArr)-1 do
        if MLColumnArr[k].Position = i then
          tabel.header.columns[k].Position := i;

    i:=0;
    setLength(WPColumnArr, 0);
    while Settings.ValueExists('WPColumn_' + IntToStr(i)) do
    begin
      setLength(WPColumnArr, length(WPColumnArr)+1);
      Settings.ReadBinaryData('WPColumn_' + IntToStr(i), WPColumnArr[length(WPColumnArr)-1], Sizeof(TColSave));
      inc(i)
    end;
    SetWinplayColumns(true);

  //Sortoptions til tabel
  if Settings.valueexists('FMLSortColumn') then
    tabel.header.sortcolumn := Settings.ReadInteger('FMLSortColumn');
  if Settings.valueexists('FAscending') then
    if Settings.readBool('FAscending') then
      tabel.header.SortDirection := sdAscending
    else tabel.header.SortDirection := sdDescending;

  if Settings.valueexists('FMLSortedCol') then
    FMLSortedCol := Settings.ReadInteger('FMLSortedCol');

  if Settings.valueexists('FMLSortedCol1') then
    FMLSortedCol1 := Settings.ReadInteger('FMLSortedCol1');

  if Settings.valueexists('FWPSortColumn') then
    Winplaylist.header.sortcolumn := Settings.ReadInteger('WPLSortColumn');
  if Settings.valueexists('FWPAscending') then
    if Settings.readBool('FWPAscending') then
      Winplaylist.header.SortDirection := sdAscending
    else Winplaylist.header.SortDirection := sdDescending;
  if Settings.valueexists('FWPSortedCol') then
    FWPSortedCol := Settings.ReadInteger('FWPSortedCol');

  if Settings.valueexists('FWPSortedCol1') then
    FWPSortedCol1 := Settings.ReadInteger('FWPSortedCol1');
end;

Procedure TMainForm.loadSettings;
function LoadInt(reg:TMexpIniFile; const key: string; var i:integer):boolean;
begin
		 result := false;
		 if reg.valueexists(key) then
				try
					 i := reg.ReadInteger(key);
					 result := true
				except
		 end
end;

procedure LoadShortCutMenuItem(reg:TMexpIniFile; mi:TMenuItem);
var       i:integer;
					sc : TshortCut;
begin
     if (mi.tag>=0) and (assigned(mi.onclick)) and reg.ValueExists('Scut'+ mi.name) then
     begin
          reg.ReadBinaryData('Scut'+ mi.name, sc, sizeOf(TshortCut));
          mi.shortcut := sc
		 end;
     for i:=0 to mi.Count-1 do
				 LoadShortCutMenuItem(reg, mi.Items[i])
end;
procedure LoadShortCuts(reg:TMexpIniFile; menu:TPopUpMenu);
var       i:integer;
begin
      for i:=0 to menu.Items.Count-1 do
          LoadShortCutMenuItem(reg, Menu.Items[i])
end;

var
	r, monitorRect:Trect;
	i, maximizedMonitor:integer;
	c: TComponent;
Begin
	if Settings.ValueExists('CurrentSkin') then
		CurrentSkin := Settings.ReadString('CurrentSkin');

	tabelseltextcolor := clwhite;
	treeseltextcolor := clwhite;
	winplaylistSelTextColor := clwhite;
	plconSelTextColor := clwhite;
	winplayingcolor := clyellow;
	WinKillcolor := clSilver;
	F0Textcolor := $004080FF;
	MainFormInstance.Boundsrect := rect(50, 50, 600, 500);
	WpBar.top := 300;
//	fInvertGroups := false;
	FMLSortedCol1 := -1;
	FMLSortedCol := -1;
  FWPSortedCol1 := -1;
	FWPSortedCol := -1;

	i := RefreshSkinArray;
	LoadSkin(i);
	SetSlidersAndPanelFonts;

	try
		if {Settings.ValueExists('maindim') and Settings.ValueExists('maximized') and} Settings.ValueExists('maximizedMonitor') then
		begin
      maximizedMonitor := Settings.ReadInteger('maximizedMonitor');
			if (maximizedMonitor >= 0) and (maximizedMonitor < Screen.MonitorCount) then //Settings.ReadBool('maximized') then
			begin
				winmaximized := true;
        monitorRect := Rect(Screen.Monitors[maximizedMonitor].Left, Screen.Monitors[maximizedMonitor].Top, Screen.Monitors[maximizedMonitor].Left + Screen.Monitors[maximizedMonitor].Width, Screen.Monitors[maximizedMonitor].Top + Screen.Monitors[maximizedMonitor].Height);
				Settings.ReadBinaryData('maindim', beforemaximizepos, sizeof(beforemaximizepos));

        //checker om startbaren skal skres vk
        SystemParametersInfo(SPI_GETWORKAREA, 0, @r, 0);
         if pointInRect(point(((monitorRect.Right - monitorRect.Left) div 2) + monitorRect.Left, ((monitorRect.Bottom - monitorRect.Top) div 2) + monitorRect.Top), r) then
          monitorRect := r;

				setwindowpos(MainFormInstance.handle, HWND_TOP, monitorRect.left, monitorRect.top, monitorRect.Right - monitorRect.Left, monitorRect.Bottom - monitorRect.Top, SWP_NOZORDER)
			end else
			begin
				winmaximized := false;
				Settings.ReadBinaryData('maindim', r, sizeof(r));
				MainFormInstance.Boundsrect := r
			end;
			if Settings.ValueExists('SnappedTo') and Settings.ValueExists('SnappedX') and Settings.ValueExists('SnappedY') and Settings.ValueExists('snappedLastPos') then
			begin
				i := Settings.ReadInteger('SnappedTo');
				c := FSnap.GetSnapWin(MainFormInstance.handle);
				if assigned(c) and (i > 0) then
				begin
					Settings.ReadBinaryData('snappedLastPos', TSnapWin(c).LastPos, SizeOf(TRect));
					TSnapWin(c).deltaX := Settings.ReadInteger('SnappedX');
					TSnapWin(c).deltaY := Settings.ReadInteger('SnappedY');
					case i of
						1: TSnapWin(c).SnappedTo := hwnd_WinAmp;
						2: TSnapWin(c).SnappedTo := hwnd_PL;
					end
				end
			end;
			if LoadInt(Settings, 'treeheight', i) then
				treepanel.width := i
		end;

		if Settings.valueExists('WPbarTop') then
			i := Settings.readInteger('WPbarTop') else i :=-1;
		if Settings.ValueExists('wplaylistminimized') and Settings.ReadBool('wplaylistminimized') then
		begin
			MinimizeWinplay.caption := arrowup;
			if i>=0 then WPbar.tag := i
		end else
		begin
			MinimizeWinplay.caption := arrowdown;
			if i>=0 then
				WPbar.top := i
		end;

		if Settings.valueExists('treeplbar') then
			i := Settings.readInteger('treeplbar') else i := -1;
		if Settings.ValueExists('Qlistminimized') and Settings.ReadBool('Qlistminimized') then
		begin
			MinimizeQ1.caption := arrowup;
			if i>=0 then
				treeplbar.tag := i;
		end else
		begin
			MinimizeQ1.caption := arrowdown;
			if i>=0 then
				treeplbar.top := i
		end;

		if Settings.valueExists('plconbar') then
			i := Settings.readInteger('plconbar') else i := -1;
		if Settings.ValueExists('Qsongsminimized') and Settings.ReadBool('Qsongsminimized') then
		begin
			MinimizeQ2.caption := arrowup;
			if i>=0 then
				plconbar.tag := i
		end else
		begin
			MinimizeQ2.caption := arrowdown;
			if i>=0 then
				plconbar.top := i
		end;

		if Settings.ValueExists('ignoreDupes') then
			Ignoreduplicates1.checked := Settings.ReadBool('ignoreDupes');

		FInvertGroupsChecked := Settings.ValueExists('InvertGroups') and Settings.ReadBool('InvertGroups');
		fAndGroups := Settings.ValueExists('AndGroups') and Settings.ReadBool('AndGroups');

			LoadShortCuts(Settings, filesPopUp);
			LoadShortCuts(Settings, treePop);
			LoadShortCuts(Settings, PLBoxpopup);
			LoadShortCuts(Settings, qlsongspop);
			LoadShortCuts(Settings, Winplaypop);
			LoadShortCuts(Settings, Global);

			if Settings.ValueExists('AutoKill') then
				AutosetKillafterplay1.Checked := Settings.ReadBool ('AutoKill');

			continuousPlay1.checked := Settings.ValueExists('ConPlay') and Settings.ReadBool('ConPlay');
      if Settings.ValueExists('ConPlayMode') then
      begin
      	i:=Settings.ReadInteger('ConPlayMode');
        frommainlist1.Checked := i=1;
        randomfrommainlist1.Checked := i=2;
        randomfromcurrentdatabase1.Checked := i=3;
				randomfromallavailabledatabases1.Checked := i=4
      end;

			Onlyshowaviablefiles1.Checked := Settings.ValueExists('OnlyShowAviable') and Settings.ReadBool('OnlyShowAviable')
	except
	end;

{	if pref.AutoResizeColumns.Checked then                  //removed - don't think anyone's using it (18/07-05)
		MainFormInstance.tabel.Header.Options := MainFormInstance.tabel.Header.Options + [hoAutoResize]
	else
  	MainFormInstance.tabel.Header.Options := MainFormInstance.tabel.Header.Options - [hoAutoResize];}

	for i:=0 to ComponentCount-1 do
		if Components[i].ClassType = TVirtualStringTree then
			with (Components[i] as TVirtualStringTree) do
			begin
				if pref.Scrollbars.ItemIndex in [0, 1] then
					scrollbaroptions.ScrollBars := ssBoth;
				case pref.Scrollbars.ItemIndex of
					0: scrollbaroptions.ScrollBarStyle := sbmRegular;
					1: scrollbaroptions.ScrollBarStyle := sbmFlat;
					2: scrollbaroptions.ScrollBars := ssNone;
				end
			end;
	UpdateSizesTreePanel(nil);
end;

Procedure TMainForm.saveSettings(ReleaseResources: Boolean);
type
  TColSave=record
    Visible:Boolean;
    Position:Byte;
    Width:Cardinal;
  end;

procedure SaveShortCutMenuItem(reg:TMexpIniFile; mi:TMenuItem);
var
   i:integer;
   sc : TshortCut;
begin
     if (mi.tag>=0) and (assigned(mi.onclick))  then
     begin
          sc := mi.shortcut;
					reg.WriteBinaryData('Scut'+ mi.name, sc, sizeOf(TshortCut))
     end;
     for i:=0 to mi.Count-1 do
         SaveShortCutMenuItem(reg, mi.Items[i])
end;

procedure SaveShortCuts(reg:TMexpIniFile; menu:TPopUpMenu);
var
   i:integer;
begin
      try
			for i:=0 to menu.Items.Count-1 do
          SaveShortCutMenuItem(reg, menu.Items[i])
			except end
end;

var
	fStr : TMyMemoryStream;
  dateTime: TDateTime;
	i:integer;
	r, monitor:Trect;
//	maximized : boolean;
	ColSave :TColSave;
//	SO : TTreeShow;
	pt:Tpoint;
	c : TComponent;
	hwd : Cardinal;
	s: String;
Begin
	if settingsreset then
		exit;

	pref.SaveSettings(true);

	for i:=0 to Length(SkinArray)-1 do
		if SkinArray[i].InUse then
			SaveFontColorSettings(i);

//	systemParametersInfo(SPI_GETWORKAREA, 0, @d, 0);
	if IsIconic(handle) then
		r := MainFormInstance.BoundsRect
	else
		getwindowrect(MainFormInstance.handle, r);

//	maximized := (d.top=r.top) and (d.left=r.left) and (d.right=r.right) and (d.bottom=r.bottom);

//	try
		Settings.WriteString('Version', ver);

		if winmaximized then
			Settings.WriteBinaryData('maindim', beforemaximizepos, sizeof(beforemaximizepos))
		else
		begin
			//checker om mexp er docket til WinAMP, og winamp er minimeret. Isfald skal lastPos gemmes i stedet for boundsrect
			if not FormPlacementValid(r) then
			begin
				c := FSnap.GetSnapWin(MainFormInstance.handle);
				if assigned(c) then
				begin
					r.Left := TSnapWin(c).lastPos.Left;
					r.Right := TSnapWin(c).lastPos.Right
				end
			end;
			if not FormPlacementValid(r) then
			begin
				c := FSnap.GetSnapWin(MainFormInstance.handle);
				if assigned(c) then
				begin
					r.Top := TSnapWin(c).lastPos.Top;
					r.Bottom := TSnapWin(c).lastPos.Bottom
				end
			end;
			Settings.WriteBinaryData('maindim', r, sizeof(r))
		end;

		for i:=0 to tabel.header.columns.count-1 do
    begin
      ColSave.Visible := TabelColumnsVisible[i];//coVisible in tabel.header.columns[i].options;
      ColSave.Position := tabel.header.columns[i].position;
      ColSave.Width :=  tabel.header.columns[i].width;
      s := 'MLColumn_' + tabel.header.columns[i].text;
      Settings.WriteBinaryData(s, ColSave, Sizeof(ColSave))
      //Settings.WriteBinaryData('MLColumn_'+tabel.header.columns[i].text, ColSave, Sizeof(ColSave))
    end;

		if hoVisible in winplaylist.Header.Options then
	  	SaveWinPlayColumns;
    for i:=0 to Length(WPColumnArr)-1 do
    	Settings.WriteBinaryData('WPColumn_' + IntToStr(i), WPColumnArr[i], Sizeof(ColSave));

		Settings.writebool('wplaylistminimized',MinimizeWinplay.caption = arrowup);
		Settings.writebool('Qlistminimized',MinimizeQ1.caption = arrowup);
		Settings.writebool('Qsongsminimized', MinimizeQ2.caption = arrowup);

		Settings.WriteBool('ignoreDupes', Ignoreduplicates1.checked);

		if MinimizeWinplay.caption = arrowup then //WinPlayList
		begin
			Settings.writeinteger('WPbartop',WPbar.tag)
		end else
			Settings.writeinteger('WPbartop',WPbar.top);

		if MinimizeQ1.caption = arrowup then //TreePlBar
		begin
			Settings.writeinteger('treeplbar', treeplbar.tag)
		end else
			Settings.writeinteger('treeplbar',treeplbar.top);

		if MinimizeQ2.caption = arrowup then //PlConBar
		begin
			Settings.writeinteger('plconbar', plconbar.tag)
		end else
			Settings.writeinteger('plconbar',plconbar.top);

		//Settings.writebool('maximized', maximized);
		monitor := GetMonitorRect(MainFormInstance);
    if sameRect(BoundsRect, monitor)  then
    	Settings.WriteInteger('maximizedMonitor', MainFormInstance.Monitor.MonitorNum)
    else
    	Settings.WriteInteger('maximizedMonitor', -1);

		Settings.WriteString('CurrentSkin', CurrentSkin);

  c := FSnap.GetSnapWin(MainFormInstance.handle);        //her fejler den!
  if assigned(c) then
  begin
    Settings.WriteBinaryData('snappedLastPos', TSnapWin(c).LastPos, SizeOf(TRect));
    hwd := TSnapWin(c).SnappedTo;
    Settings.WriteInteger('SnappedX', TSnapWin(c).deltaX);
    Settings.WriteInteger('SnappedY', TSnapWin(c).deltaY)
  end
  else hwd := 0;
  if hwd > 0 then
    if hwd = hwnd_winamp then
      hwd := 1
    else
    if hwd = hwnd_PL then
      hwd := 2;
  Settings.WriteInteger('SnappedTo', hwd);
  if (hwd = 1) and TSnapWin(c).SnappedWindowIsMinimized then
    Settings.writebool('visible', false)
  else
    Settings.writebool('visible', MainFormInstance.visible);
  Settings.writebool('aot', aot.checked);
  Settings.writestring('searchstring',f0.text);
  Settings.writeInteger('treeheight', treepanel.width);
  Settings.writeinteger('playlitboxheight', playlistbox.height);

  Settings.writebool('InvertGroups',FInvertGroupsChecked);
  Settings.writebool('AndGroups', fAndGroups);

  //Gemmer shortcuts til menuer
  SaveShortCuts(Settings, filesPopUp);
  SaveShortCuts(Settings, treePop);
  SaveShortCuts(Settings, PLBoxpopup);
  SaveShortCuts(Settings, qlsongspop);
  SaveShortCuts(Settings, Winplaypop);
  SaveShortCuts(Settings, Global);

  Settings.writeBool('ConPlay', continuousPlay1.checked);
  if frommainlist1.Checked then
    i:=1
  else if randomfrommainlist1.Checked then
    i:=2
  else if randomfromcurrentdatabase1.Checked then
    i:=3
  else
    i:=4;
  Settings.WriteInteger('ConPlayMode', i);

  Settings.writeBool('OnlyShowAviable', Onlyshowaviablefiles1.checked);

  if ReleaseResources and continuousPlay1.checked then
  begin
    continuousPlay1.checked := false;
    if CheckConPlay then
      Winplaysave
  end;

  //sortoptions til tabel & Winplaylist
  Settings.writeinteger('FMLSortColumn', tabel.header.sortcolumn);
  Settings.writebool('Fascending',tabel.header.sortdirection = SDascending);
  Settings.writeinteger('FMLSortedCol',FMLSortedCol);
  Settings.writeinteger('FMLSortedCol1',FMLSortedCol1);

  Settings.writeinteger('FWPSortColumn', Winplaylist.header.sortcolumn);
  Settings.writebool('FWPAscending',Winplaylist.header.sortdirection = SDascending);
  Settings.writeinteger('FWPSortedCol', FWPSortedCol);
  Settings.writeinteger('FWPSortedCol1', FWPSortedCol1);
  //EO sortoptions til tabel

  Settings.WriteBool('AutoKill', AutosetKillafterplay1.Checked);

  try
    //Gemmer tree
    if DBInitiated then
    begin
      fStr := TMyMemoryStream.Create;
      fstr.SetCapacity(1024*1024*2);
      fStr.write(TREE_fileVer, sizeOf(TREE_fileVer));

      dateTime := AppFirstRunDate * -1;
      FStr.Write(dateTime, SizeOf(dateTime));

      fStr.Write(showMedia1.checked, sizeof(boolean));

      //gemmer scrollinfo
      pt := tree.OffsetXY;
      fStr.Write(pt, sizeOf(Tpoint));

      //gemmer nodes
      SaveTree(tree, FStr);

      fStr.SaveToFile(settingsdir + 'treestruct.dat');
      fStr.free
    end
  except
  end;
	savedatabase(ReleaseResources)
end;

function TMainForm.FormPlacementValid(formRect: TRect):Boolean;
var
	i:integer;
  formRgn, monitorRgn, newRgn: HRGN;
  RType: Integer;
begin
  result := false;
  formRgn := CreateRectRgnIndirect(formRect);
  newRgn := CreateRectRgn(0, 0, 0, 0);
	for i:=0 to Screen.MonitorCount-1 do
  begin
		monitorRgn := CreateRectRgn(Screen.Monitors[i].Left, Screen.Monitors[i].Top, Screen.Monitors[i].Left + Screen.Monitors[i].Width, Screen.Monitors[i].Top + Screen.Monitors[i].Height);
    CombineRgn(newRgn, monitorRgn, formRgn, RGN_DIFF);
    //Check om monitorens rect har ndret sig:
    RType := CombineRgn(newRgn, monitorRgn, newRgn, RGN_DIFF);
    DeleteObject(monitorRgn);
    if RType <> NULLREGION then
    begin
    	result := true;
      break
    end
  end;
  DeleteObject(formRgn);
  DeleteObject(newRgn);
end;

function TMainForm.IsWinampMinimized:boolean;
begin
	result := IsIconic(Hwnd_winamp)
end;

procedure TMainForm.TrayIconClicked(forceToggle: boolean = false);
var
	r, d: TRect;
	c : TComponent;
	hidden, showWindow, WinampMinimized : boolean;
begin
	showWindow := true;
	WinampMinimized := false;
	c := FSnap.GetSnapWin(MainFormInstance.handle);
	if assigned(c) then
		WinampMinimized := IsWinampMinimized and (TSnapWin(c).SnappedTo = Hwnd_Winamp);// or IsWindowCovered(MainFormInstance.handle);

	if forceToggle or (pref.TrayIconOptions.ItemIndex = 1) then
	begin
		if assigned(c) then
			hidden := TSnapWin(c).WindowClosed or not MainFormInstance.Visible or ((TSnapWin(c).SnappedTo = Hwnd_Winamp) and WinampMinimized) or IsWindowCovered(MainFormInstance.handle)
		else
			hidden := not MainFormInstance.Visible;
		if not hidden then
		begin
			showWindow := false;
			SetMainFormVisible(false)
		end
	end;

	if showWindow then
	begin
		if not ShowAform or (ScanThread.Runing and not MainFormInstance.enabled) then
    	exit;
		//finder desktop og MainFormInstance rect

		SystemParametersInfo(SPI_GETWORKAREA,0,@d,0);
		GetWindowRect(MainFormInstance.handle, r);

		//if (r.Left >= d.Right) or (r.Left < 0) then
    if not FormPlacementValid(r) then
		begin
			c := FSnap.GetSnapWin(MainFormInstance.handle);
			if assigned(c) then
			begin
				r.Left := TSnapWin(c).lastPos.Left;
				r.Right := TSnapWin(c).lastPos.Right
			end
		end;
    if not FormPlacementValid(r) then
		//if (r.Left >= d.Right) or (r.Right < 50) then
		begin
			r.Right := r.Right - r.Left + 50;
			r.Left := 50
		end;
    if aot.Checked then
      SetWindowPos(MainFormInstance.Handle, HWND_TOPMOST,
                  r.Left,
                  r.Top,
                  r.Right - r.Left,
                  r.Bottom - r.Top,
                  SWP_SHOWWINDOW or SWP_NOMOVE or SWP_NOSIZE)
    else
    begin
      SetWindowPos(MainFormInstance.Handle, HWND_TOPMOST,
                  r.Left,
                  r.Top,
                  r.Right - r.Left,
                  r.Bottom - r.Top,
                  SWP_SHOWWINDOW or SWP_NOMOVE or SWP_NOSIZE);

      SetWindowPos(MainFormInstance.handle, HWND_NOTOPMOST,
                  r.Left,
                  r.Top,
                  r.Right - r.Left,
                  r.Bottom - r.Top,
                  SWP_SHOWWINDOW and SWP_NOMOVE and SWP_NOSIZE);
      //MainFormInstance.activate
    end;
    //SetActiveWindow(MainFormInstance.handle)
	end
end;

procedure TMainForm.HandlePartyMode(const Msg: TMessage);
var
	pass: string;
	pc: Pchar;
begin
	pc := StrAlloc(Msg.LParam);
	GlobalGetAtomName(Msg.WParam, pc, Msg.LParam);
	pass := pc;
	StrDispose(pc);
	EnablePartyMode(pass);
end;

procedure TMainForm.HandleRemoteCall(const Msg: TMessage);
begin
	if partyMode1.Checked and pref.partyDisableRemote.Checked then
		exit;

	case Msg.WParam of
		1: prevMouseDown(nil, mbLeft, [], 0, 0); //previous
		2: button2(hwnd_winamp);	//Play
		3: button3(hwnd_winamp);	//Pause
		4: button4(hwnd_winamp);		//Stop
		5: nxtMouseDown(nil, mbLeft, [], 0, 0); //Next
		6: Button1_Shift(hwnd_winamp); //backward 5 sec.
		7: Button5_Shift(hwnd_winamp); //forward 5 sec.
		8:	begin
					treepopPopup(nil);
					if Playallsongsinselecteddatabase1.Visible then
						Playallsongsinselecteddatabase1Click(nil)
				end;
    9:	Playallsongs1Click(nil);
		20: if not MainFormInstance.ScanThread.Runing and not partyMode1.Checked then
    			TrayIconClicked(true); //toggle MEXP
	end
end;

Procedure TMainForm.HandleSkinSave;
var
	i, k: Integer;
	dt: TDateTime;
begin
	k := 0;
	for i:=0 to length(SkinArray)-1 do
		if skinArray[i].InUse then
			k := i;
	dt := FileAge(skinArray[k].Filename);
	if dt <> CurrentSkinDate then
	begin
		LoadSkin(k, k);
		SetSlidersAndPanelFonts
	end
end;

procedure TMainForm.ToggleSystrayIcon(toggle: Boolean);
begin
	if IconShowingInSystray then
  begin
  	if toggle then
    	Icondata.hIcon := Icon2.Picture.Icon.Handle
    else
    	Icondata.hIcon := Icon1.Picture.Icon.Handle;
    Shell_NotifyIcon(Nim_Modify, @Icondata)
  end
end;

procedure TMainForm.SetSystrayIconToolTip(s: String);
begin
	if IconShowingInSystray then
  begin
    if length(s) > 63 then
    	s := Q_CopyRange(s, 1, 60) + '...';
  	StrPCopy(IconData.szTip, s);
    Shell_NotifyIcon(Nim_Modify, @Icondata)
  end
end;

procedure TMainForm.WndProc(var Msg : TMessage);
begin if quitting then exit;
	case Msg.Msg of
  	WM_USER + 100: if not quitting then SetMainFormVisible(msg.lparam=1);
		WM_USER + 50: HandleRemoteCall(Msg);     //der er kaldt fra MEXPcontrol
		WM_USER + 51: HandleSkinSave;     //der er kaldt fra Skinner
		WM_USER + 52: HandlePartyMode(Msg);
    WM_UPDATE_TREE: Updatetree(Msg.WParam = 1);
		WM_USER + 1:                // sker nr ikonet i systrayen klikkes
			if not (MainFormInstance.ScanThread.Runing and (pref.visible or assigned(dbpref))) then
        case Msg.lParam of
        	WM_LBUTTONDOWN:
          	begin
              ToggleSystrayIcon(true);
            	TrayIconClicked
            end;
					WM_RBUTTONDOWN:
          begin
          	ToggleSystrayIcon(true);
						if pref.TrayIconOptions.ItemIndex = 0 then
							SetMainFormVisible(false)
						else
						begin
							//if not IsWindowVisible(MainFormInstance.Handle) then    dette fr den til at crashe nr den lukker (16/12-2004)
							//	ForceForegroundWindow(MainFormInstance.Handle);
							ConfigMenu.Popup(Mouse.CursorPos.x, Mouse.CursorPos.y);
							PostMessage(Handle, WM_NULL, 0, 0)
						end
          end;
          WM_LBUTTONUP, WM_RBUTTONUP: ToggleSystrayIcon(false)
        end;

		WM_ENTERSIZEMOVE:
    	Resizing := true;
		WM_EXITSIZEMOVE:
		begin
    	Resizing := false;
      ResizeWinplaylistColumns;
      UpdateTreeBounds(winplaylist);
			tree.repaint;
			tabel.repaint;
			winplaylist.repaint
		end;

    CM_EXITMENULOOP:
    	fTreeDropMenuClosed := true;

    CM_ENTERMENULOOP:
    	fTreeDropMenuClosed := false
	end;

	if (msg.msg =WM_ACTIVATE) and not rez and not Quitting then
	begin
			 if (loword(msg.wparam) = WA_ACTIVE) or (loword(msg.wparam) = WA_CLICKACTIVE) then
			 begin
						appactivated:=true;
						RepaintTopImage;
//						upperLeftImage.Picture := iupleft.Picture;
//            upperright.Picture := iupright.picture;
//						forceRepaint(topImage)
						//SetThreadPriority(application.handle,THREAD_PRIORITY_NORMAL);
			 end else
			 if loword(msg.wparam) = WA_INACTIVE then
			 begin
						appactivated:=false;
						RepaintTopImage;
//						upperLeftImage.Picture := iupleftshade.Picture;
//						upperright.Picture := iuprightshade.picture;
//						forceRepaint(topImage)
						//SetThreadPriority(application.handle,THREAD_PRIORITY_IDLE);
			 end
end;

  inherited;
end;

procedure TMainForm.CMMenuClosed( var msg: TWMMenuSelect );
begin
	if ConfigImageShown then
	begin
		ConfigImageShown := false;
		volbarPaint(nil, Canvas)
	end
end;

Function TMainForm.GetGenreID(s:String):integer;
var
	i:integer;
begin
	if not Q_IsInteger(s) then
		s:=cleanString(s);
	if Q_SameText('rx', s) then
		s := 'Remix';
	if Q_SameText('cr', s) then
		s := 'Cover';
	if Q_IsInteger(s) then
	begin
		result := strtoint(s);
		if result > MAXGENRES then
			result := -1
	end
	else
	if s = '' then
		result := -1
	else
	begin
		for i:=0 to genreList.count-1 do
			if Q_SameText(genreList.strings[i], s) then
			begin
				result := i;
				exit
			end;
		result := genreList.Add(s)
	end
end;

Function TMainForm.hasGenre(genreIndex:cardinal; p:pointer):boolean;
var      l, k:integer;
begin
	result := false;
  l := length(Prec(p).genre)-1;
  for k:=0 to l do
  	result := result or (Prec(p).genre[k] = genreIndex)
end;

Function TMainForm.GetAudioType(const filename:String; var index:byte):boolean;
var
	i, x :integer;
	ext:string;
begin
	result := false;
	ext := GetFileExt(filename);
	for i:=0 to length(audioTypes)-1 do
		for x:=0 to length(audioTypes[i].ext)-1 do
		begin
			if Q_SameText(audioTypes[i].ext[x], ext) then
			begin
				index := i;
				result := true;
				exit
			end
		end
end;

Function TMainForm.SetCustomFieldData(rec: PRec; FieldIndex: Integer; const Data: String): Boolean;
var
  k, j: Integer;
begin
  if length(Data) > 0 then
  begin
    case PCustomField(FieldList.List^[FieldIndex]).dataType of
      0: result := true;	//string
      1: result := Q_IsInteger(Data);
      2: result := Q_IsFloat(Data);
    else result := false;
    end;

    if result then
    begin
      k := -1;
      for j:=0 to length(rec.CustomFields)-1 do
        if rec.CustomFields[j].FieldIndex = FieldIndex then
          k := j;

      if k >= 0 then
        DisposeCustomFieldEntryData(rec.CustomFields[k])
      else
      begin
        SetLength(rec.CustomFields, Length(rec.CustomFields) + 1);
        k := length(rec.CustomFields) -1
      end;

      rec.CustomFields[k].FieldIndex := FieldIndex;
      case PCustomField(FieldList.List^[FieldIndex]).dataType of
        0:
        begin
          new(PStringData(rec.CustomFields[k].Data));
          PStringData(rec.CustomFields[k].Data).value := Data;
        end;
        1:
        begin
          new(PIntegerData(rec.CustomFields[k].Data));
          PIntegerData(rec.CustomFields[k].Data).value := StrToInt(Data);
        end;
        2:
        begin
          new(PRealData(rec.CustomFields[k].Data));
          PRealData(rec.CustomFields[k].Data).value := StrToFloat(Data)
        end
      end;	//of case
    end	//og "result"
  end
  else
  begin
    result := true;
  	//Fjern data, hvis eksisterer
    k := -1;
    for j:=0 to length(rec.CustomFields)-1 do
      if rec.CustomFields[j].FieldIndex = FieldIndex then
        k := j;

    if k >= 0 then
    begin
      DisposeCustomFieldEntryData(rec.CustomFields[k]);
      //Ryk de eksisterende custom fields op
      for j := k to length(rec.CustomFields)-2 do
      begin
      	rec.CustomFields[j] := rec.CustomFields[j+1]
      end;
      SetLength(rec.CustomFields, length(rec.CustomFields)-1)
    end
  end
end;

Function TMainForm.ReadID3(Thread: TBMDExecuteThread; const filename:String; const scanPath:String; master:integer; DBindex:integer; Rec:PRec; changeGroups:boolean=true; filenames:TQ_StringList=nil): boolean;
{den korte version}
var
  audioType:byte;
  addQ:word;
  Flags:TRecFlags;
  art, ArtistSortOrder, tit,alb,com:string;
  yea,track,TotalTracks,kbps,cha, freq:integer;
  crc: LongWord;
  duration : Cardinal;
  Fsize:Cardinal;
  LastWriteTime:Integer;
  repairVBR: Boolean;
  PartOfSet, rating: Byte;
  cr: PCoverRec;
begin
  if master <> master_DirSpy then
  begin
	  Inc(SafeToAutoScanCount);
	  WaitForAutoScan
  end;

  result := false;
  fillChar(rec^, sizeOf(rec^), #0);
  SetLength(rec.Groups,0);
  SetLength(rec.Genre,0);
  rec.location:=dbindex;
  Flags := rec.Flags;
  if assigned(rec) then
  	repairVBR := dbs[rec.location].repairVBR
  else
  	repairVBR := false;
  if readid3(thread, repairVBR, ScanPath, filename,master,audioType, addQ, art,ArtistSortOrder,tit,alb,com, PartOfSet, rating, yea,track,TotalTracks,kbps,cha,duration, {groups,}flags, Fsize,CRC,freq, {CreateTime, }LastWriteTime, dbs[dbIndex].calculateCRC, cr, rec, true, filenames) then
  begin
    try
    	BeginSetArtistAlbumFilename;
    	try
        rec.location:=dbindex;
        rec.AudioType := audioType;
        rec.addQuality := addQ;
        setFilename(rec, filename, master <> master_DirSpy);
        setArtist(rec, art, ArtistSortOrder);
        SetPCharString(rec.Title, tit);
        rec.Album:= GetAlbumID(alb);
        rec.rating := rating;
        rec.PartOfSet := PartOfSet;
        if (yea>=-1) and (yea<32767) then rec.Year:= yea else rec.Year := -1;
        rec.Comment:= com;
        if (track>=0) and (track < high(word)) then rec.Track:= track else rec.Track := 0;
        if (TotalTracks>=0) and (TotalTracks < high(word)) then rec.TotalTracks := TotalTracks else rec.TotalTracks := 0;
        if (kbps > -32767) and (kbps < 32767) then rec.Kbps:= kbps else rec.kbps := 0;
        rec.Length := duration; //ingen sammenligning ndvendig
        if cha in [0 .. 4] then rec.Channels := Cha else rec.Channels := 4;//unknown
        rec.LastWriteTime := LastWriteTime;
				rec.DatabaseTime := DateTimeToFileDate(now);
        rec.PlayCount := 0;
        rec.flags := flags;
        if (crc > low(LongWord)) and (crc < high(LongWord)) then
        	rec.CRC := crc
        else
        	rec.CRC := 0;
        rec.FSize := Fsize;
        if (freq>=0) and (freq<=high(word)) then rec.khz := freq else rec.Khz := 0;
        Exclude(rec.Flags, rfPlaying);
        AddCoverRecToList(cr, rec);
        result := true
      finally
      	EndSetArtistAlbumFilename
      end
      except
      begin
          ShowmessageX(GetText(TXT_ErrorAssigningVal, [filename]));
          result := false
      end
     end
  end;

  if master <> master_DirSpy then
	  Dec(SafeToAutoScanCount)
end;

procedure TMainForm.AddCoverRecToList(cr: PCoverRec; recToAssignToSourceRec: PRec);
var
	i: integer;
  aNode: PVirtualNode;
  tr: PTreeRec;
  cr2: PCoverRec;
  found: Boolean;
begin
	if assigned(cr) then
  begin
  	cr.SourceRec := recToAssignToSourceRec;
  	found := false;
		fCoverImgsRW.BeginWrite;
	  fCoverRecRW.BeginWrite;
	  try
	  	for i:=0 to fCoverImgs.Count -1 do
      begin
      	cr2 := fCoverImgs.List^[i];
	    	if (cr2.SourceRec = cr.sourceRec) and (cr2.SourceType in [coverSource_id3v2TagIndex0, coverSource_id3v2TagIndex3]) and (cr.SourceType in [coverSource_id3v2TagIndex0, coverSource_id3v2TagIndex3]) then
        begin
        	found := true;
          fCoverImgs.Items[i] := cr;

        	//Enumerate Tree
        	aNode := tree.GetFirst;
          while aNode <> nil do
          begin
          	tr := tree.GetNodeData(aNode);
            if tr.CoverRec = cr2 then
            	tr.CoverRec := cr;
          	aNode := tree.GetNext(aNode)
          end;

          DisposeCoverRec(cr2, true)
        end
      end;

      if not found then
	      fCoverImgs.Add(cr)
	  finally
	  	fCoverRecRW.EndWrite;
	    fCoverImgsRW.EndWrite;
	  end
  end
end;

procedure TMainForm.AskGroupDialog(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
var
	Ask: PAskGroupData;
  x: Integer;
  GR: PGroupRec;
begin
	Ask := Data;

	Application.CreateForm(Taddgroup, addgroup);
  addgroup.Label1.caption := GetText(TXT_AGroupNamedText, [Ask.GroupName, #13 + Ask.filename + #13]); //'A group named "' + s + '" is defined in the file' + #13 + filename + #13 + 'This group is not defined in your database.';
  addgroup.listbox1.Items.Clear;
  for x:=0 to GroupList.count-1 do
  	addgroup.listbox1.items.add(PGroupRec(grouplist.items[x]).name);
  case addgroup.ShowModal of
  	mryes:  //tilfj gruppe
    	begin
      	New(GR);
        fillChar(GR^, sizeOf(GR^), #0);
        GR.name := Ask.GroupName;
        GR.Checkstate := GroupCheckState_Checked;
        Ask.GroupIndex := GroupList.Add(GR);
        Ask.result := agtrrAddGroup
      end;
    mrok:   //brug gruppe fra liste
    	begin
      	for x:=0 to addgroup.listbox1.items.count-1 do
        	if addgroup.listbox1.selected[x] then
          	Ask.GroupIndex := x;
        Ask.result := agtrrUseExistingGroup
      end;
    mrNo:	Ask.Result := agtrrRemoveGroupFromTag;
    mrNoToAll: Ask.Result := agtrrRemoveGroupFromAllTags;
    mrCancel: Ask.Result := agtrrIgnore;
    else
    begin
    	Ask.GroupIndex := -1;
      Ask.result := agtrrIgnore
    end
  end;
  AddGroup.release;
  FreeAndNil(AddGroup)
end;

Function ReadStringUntilNull(enc: byte; str: TStream): String;
var
	b: byte;
  w: word;
begin
	result := '';
  while str.Position < str.Size do
  begin
	  if enc = 0 then
	  begin
			str.Read(b, 1);
	    if b > 0 then
	    	result := result + chr(b)
	    else
      	break
    end
    else
    if (enc = 1) and (str.Position < str.Size -1) then
    begin
    	str.Read(w, 2);
	    if (w > 0) then
      begin
	    	if (w <= 255) then
        	result := result + chr(w)
      end
	    else
      	break
    end
    else
    	break
  end
end;

Function TMainForm.ReadID3(Thread: TBMDExecuteThread; repairVBR: Boolean; const ScanPath, filename:string; master:integer; var audioType:byte; var addQuality:word; var artist, ArtistSortOrder, title, Album, Comment : string; var PartOfSet, rating: Byte; var year, Track, TotalTracks, kbps, Channels: integer; var duration : Cardinal;var Flags:TRecFlags;var Fsize:Cardinal; var CRC:LongWord; var freq:integer; var LastWriteTime:Integer; calculateCRC: boolean; out coverRec: PCoverRec; NewRec:PRec=nil; changeGroups:boolean=true; filenames:TQ_StringList=nil; playlistFiles:PPlaylistFiles = nil) : boolean;
//den lange version
function AddGroupToRec(const GroupName: String; const Grps: array of byte; var GroupID:Integer):TAskGroupToRecResult;
var
	HasGroup, askgroup: Boolean;
	i, x: Integer;
	GR : PGroupRec;
  AskGroupData: PAskGroupData;
begin
	result := agtrrIgnore;
	hasgroup := false;
	askgroup := true;
	for x:=0 to GroupList.count-1 do
		if sametext(PGroupRec(Grouplist.items[x]).Name, GroupName) then
		begin
			if not MainFormInstance.hasGroup(Grps, x) then
			begin
				GroupID := x;
				result := agtrrAddGroup
			end;
			hasgroup := true
		end;

  if not HasGroup and pref.AaddGroups.checked then
  begin
    New(GR);
    fillChar(GR^, sizeOf(GR^), #0);
    GR^.Name := GroupName;
    GR^.Checkstate := GroupCheckState_Checked;
    GroupID := GroupList.Add(GR);
    result := agtrrAddGroup
  end
  else
  if FIgnoreGroupList.Find(GroupName, i) then
  	result := agtrrIgnore
  else
  if FDeleteGroupsFromTagList.Find(GroupName, i) then
  	result := agtrrRemoveGroupFromTag
  else
  if FUseGroupInsteadList.Find(GroupName, i) then
  begin
  	GroupID := Integer(FUseGroupInsteadList.Objects[i]);
    result := agtrrAddGroup
  end
  else
  if not hasgroup and askgroup then
  begin
    new(AskGroupData);
    FillChar(AskGroupData^, SizeOf(AskGroupData^), 0);
    AskGroupData.GroupName := groupName;
    AskGroupData.Filename := Filename;
    AskGroupData.GroupIndex := -1;

    if assigned(Thread) then
      Thread.Synchronize(AskGroupDialog, AskGroupData)
    else
      AskGroupDialog(nil, nil, pointer(AskGroupData));

    case AskGroupData.result of
			agtrrAddGroup:
      begin
      	GroupID := AskGroupData.GroupIndex;
      	result := agtrrAddGroup
    	end;
      agtrrUseExistingGroup:
      begin
      	GroupID := AskGroupData.GroupIndex;
        FUseGroupInsteadList.AddObject(GroupName, @GroupID);
      	result := agtrrAddGroup
      end;
    	agtrrRemoveGroupFromAllTags:
      begin
      	FDeleteGroupsFromTagList.Add(GroupName);
        result := agtrrRemoveGroupFromTag
      end;
      agtrrRemoveGroupFromTag:
      begin
      	result := agtrrRemoveGroupFromTag
      end;
      agtrrIgnore:
      begin
      	FIgnoreGroupList.Add(GroupName);
        result := agtrrIgnore
      end;
    end;
    dispose(AskGroupData)
  end
end;

function GetExtendedInfo(const filename: String; const field: String): String;
var
	ExtFileInfo: ExtendedFileInfoStruct;
  i: Integer;
begin
 	FillChar(ExtFileInfo, SizeOf(ExtFileInfo), #0);
  ExtFileInfo.filename := Pchar(filename);
  ExtFileInfo.metadata := Pchar(field);
  ExtFileInfo.retlen := 512;
  GetMem(ExtFileInfo.ret, 512);
  i := SendMessage(hwnd_winamp, WM_WA_IPC, LongInt(@ExtFileInfo), 290); // 290 = IPC_GET_EXTENDED_FILE_INFO
  if i = 1 then
	  result := String(Pchar(ExtFileInfo.ret))
  else
  	result := '';
  FreeMem(ExtFileInfo.ret, 512)
end;

function ProcessId3v2Pictures(id3v2: TMyID3Controller): PCoverRec;
var
	cr: PCoverRec;
	i: Integer;
  foundPicType: TJvID3PictureType;
  picFrm: TJvID3PictureFrame;
begin
	foundPicType := TJvID3PictureType(-1);

	//Search for APIC frame
  for i:=0 to id3v2.Frames.Count-1 do
  begin
    if id3v2.Frames[i].FrameId = fiPicture then
    begin
      picFrm := TJvID3PictureFrame(id3v2.Frames[i]);
//    	mstr := TMemorystream.Create;
//			id3v2.getFrameData(i, mstr);
//      if mstr.Size > 32 then
//      begin
	//      mstr.Position := 1;	//seek past encode-type
//        mime := ReadStringUntilNull(0, mstr);
//        mstr.Read(picType, 1);
        //If front cover is already read, don't read the next one
        if (foundPicType <> ptCoverFront) and (picFrm.PictureType in [ptOther, ptCoverFront]) and (Q_SameText(picFrm.MIMEType, 'image/jpg') or Q_SameText(picFrm.MIMEType, 'image/png') or Q_SameText(picFrm.MIMEType, 'image/jpeg')) then
        begin
        	foundPicType := picFrm.PictureType
        end
  //    end;
//      mstr.Free
    end;
    if foundPicType = ptCoverFront then break
  end;

  if foundPicType in [ptOther, ptCoverFront] then
  begin
  	new(cr);
    FillChar(cr^, SizeOf(cr^), 0);
    if foundPicType = ptOther then
	    cr.SourceType := coverSource_id3v2TagIndex0
    else
    	cr.SourceType := coverSource_id3v2TagIndex3;
    cr.State := notLoaded;
    result := cr
  end
  else
  	result := nil
end;

var
  basicFileInfo: basicFileInfoStruct;
  mpgOK : Boolean;
  s,s2,d,a,t : string;
  x,x2,i2,i,k, j, sz, genreIndex: integer;
  mpegSize : Int64;
  b,bl,b2:boolean;
  HasV2Tag,HasV1Tag, HasApeTag:Boolean;
  bt : byte;
  C : Char;
  ch:array[0..1024] of char;
  cha:array of char;
  fname2:array[0..1024] of char;
  Id3v2 : TMyId3Controller;
  Id3v1 : TID3v1Tag;
  Diz, Value : String;
  wsValue: WideString;
  Fstr: TStream;
  Mstr: TMemoryStream;
  Buffer: array of char;
  p:pointer;
  Grps : array of byte;
  Genr : array of Word;
  MPEGaudio: TMPEGaudio;
  MusePack: TMPEGplus;
  Ogg : TOggVorbis;
  Wma : TWMAfile;
  Wav : TWavFile;
  Monkey : TMonkey;
  Ape : TApeTag;
  ch255 : array[0..255] of char;
  Lyrics3Str: array[1..9] of Char;
  ParsingParams :Boolean;
  Id3v2FrameName: string;
  Id3v2FrameId : TJvId3FrameId;
  id3v2ContentFrame: TJvID3ContentFrame;
  id3v2SimpleListFrame: TJvID3SimpleListFrame;
  txxxFrame: TJvID3UserFrame;
//  Genres : TStringList;
  byte1, byte2 : byte;
  wrd:word;
  AudioDataStartPosition : integer;
  AccessTime : TDateTime;
  CurrentFormBackup : TForm;
  CheckIfValueIsCroppedFromFileName: boolean;
  Id3v2GenreAdded: Boolean;
  FileMode: Integer;
  containsCover: Boolean;
  cf: PCustomField;
Begin
	if master <> master_DirSpy then
  begin
	  Inc(SafeToAutoScanCount);
	  WaitForAutoScan;
  end;

  artist := '';
  artistSortOrder := '';
  title := '';
  album := '';
  Comment := '';
  year := -1;
  Track := 0;
  TotalTracks := 0;
  kbps := 0;
  Channels := 0;
  Duration := 0;
  Rating := 0;
  SetPartOfSet(PartOfSet, 0);
//  Flags := 0;	 skal ikke vre der - HUSK at nr readId3 kaldes SKAL Flags enten sttes til 0 eller skal sttes til existerende rec.flags
//	SetFlag(Flags, RF_HasId3v1 or RF_HasId3v2 or RF_HasApeTag or RF_HasWmaTag or RF_HasOggTag or RF_EqualId3 or RF_HasLyrics, false);
  Exclude(Flags, rfHasId3v1);
  Exclude(Flags, rfHasId3v2);
  Exclude(Flags, rfHasApeTag);
  Exclude(Flags, rfHasWmaTag);
  Exclude(Flags, rfHasOggTag);
  Exclude(Flags, rfEqualId3);
  Exclude(Flags, rfHasLyrics);

  Fsize := 0;
  CRC := 0;
  freq := 0;
  SetLength(Grps,0);
  SetLength(Genr,0);
  audioType := 0;
  addQuality := 0;
  CheckIfValueIsCroppedFromFileName := false;
  containsCover := false;
  coverRec := nil;

  Id3v1 := nil;
  Id3v2 := nil;
  Ape := nil;

  if not fileexists(filename) or not GetAudioType(filename, audioType) then
  begin
    result := false;
    if master <> master_DirSpy then
	  	Dec(SafeToAutoScanCount);
    exit
  end;

  //GetFileTimes(filename, CreateTime, AccessTime, LastWriteTime);
  LastWriteTime := FileAge(filename);

  begin
        //Skal bnes med skriverettigheder om muligt
        FStr := OpenReadWriteFileStream(filename, FileMode);
        if not Assigned(FStr) then
        begin
        	result := false;
			    if master <> master_DirSpy then
				  	Dec(SafeToAutoScanCount);
			    exit
        end;

				{Lser alle tags som kan vre i flere typer filer: Id3v1, ID3v2 og Ape }
        if AudioTypes[audioType].Id3v1 then
				begin
        	Id3v1 := TId3V1Tag.Create;
          Id3v1.LoadFromStream(Fstr, Fstr.Size);
          HasV1Tag := Id3v1.Ok;
				end
        else
        	HasV1Tag := false;

        if HasV1Tag then
        	Include(Flags, rfHasId3v1)
        else
        	Exclude(Flags, rfHasId3v1);



		  { Always read Id3v2 - even if not allowed in the file-type}
	  	try
        if AudioTypes[audioType].audio then
        begin
        	BeginUseId3v2;
					Id3v2 := TMyId3Controller.Create(self);
					//HasV2Tag := id3v2.LoadFromStream(Fstr, 0) shr 8 in [0, 2, 33, 192, 193, 194]
          try
            id3v2.LoadFromStream(FStr);
            HasV2Tag := id3v2.TagSize > 0;
          except
            FreeAndNil(id3v2);
            HasV2Tag := false;
          end
        end
        else
        begin
        	HasV2Tag := false;
          Id3v2 := nil
        end;

				if HasV2Tag then
					// AudioDataStartPosition := Id3v2.sourceFileOffset + Id3v2.tagSetSize + 10
          AudioDataStartPosition := Id3v2.TagSize + 10
				else
          AudioDataStartPosition := 0;

         if HasV2Tag then
        	Include(Flags, rfHasId3v2)
        else
        	Exclude(Flags, rfHasId3v2);



				if AudioTypes[audioType].ApeV1 or AudioTypes[audioType].ApeV2 then
				begin
        	Ape := TApeTag.Create;
          HasApeTag := Ape.ReadFromStream(FStr);
				end
        else
        	HasApeTag := false;

         if HasApeTag then
        	Include(Flags, rfHasApeTag)
        else
        	Exclude(Flags, rfHasApeTag);



				if audioType = 0 then  //MpegAudio
				begin
             MPEGaudio := TMPEGaudio.Create;

						 result := MpegAudio.ReadFromStream(Fstr, AudioDataStartPosition, HasV1Tag, false{ assigned(newRec) and (dbs[Prec(newRec).location].media in [media_CDROM, media_network])});
             result := result and MpegAudio.Valid;
						 if result then
             begin
                  if repairVBR and MpegAudio.VBR.Found and MpegAudio.VBR.InvalidHeader and MpegAudio.VBR.CanWriteNewVBR and (FileMode = fmOpenReadWrite) then //GetFileAccess(filename, true, true, true) then
                  begin
											 //UpdateScanLabel(master, GetText(TXT_WritingVBR, [filename]));
//                       Fstr.free;
//                       FStr := TFilestream.Create(Filename, fmOpenReadWrite or fmShareDenyWrite);
											 MpegAudio.AddNewVBRtoStream(Fstr);
											 result := MpegAudio.ReadFromStream(Fstr, AudioDataStartPosition, HasV1Tag)
									end;

									if MpegAudio.VBR.Found then kbps := MpegAudio.BitRate * -1 else kbps := MpegAudio.BitRate;
									duration := MpegAudio.Duration;
									Channels := MpegAudio.Frame.ModeID;
									freq := MpegAudio.SampleRate;

									AudioDataStartPosition := MpegAudio.FirstFramePos
             end;
						 MpegAudio.free
        end else
				if audioType = 1 then //MusePack
				begin
						 MusePack := TMPEGplus.Create;
						 result := MusePack.ReadFromStream(Fstr, HasV1Tag, AudioDataStartPosition);
						 result := result and MusePack.Valid;
						 if result then
						 begin
									kbps := MusePack.BitRate;
									duration := round(MusePack.duration*1000);
									channels := MusePack.ChannelModeID;
									freq := 44100; //standard, tror jeg
									byte1 := MusePack.StreamVersion; //  addQuality and $FF
									byte2 := MusePack.ProfileID; // addQuality shr 8
									addQuality := byte1 or (byte2 shl 8)
						 end;
						 MusePack.free
				end else
				if audioType = 2 then //OggVorbis
				begin
						 Ogg := TOggVorbis.create;
						 result := Ogg.ReadFromStream(FStr);//, AudioDataStartPosition);
						 result := result and Ogg.Valid;
						 if result then
						 begin
                  if length(trim(ogg.artist + ogg.title + ogg.album))>0 then
        						Include(Flags, rfHasOggTag)
        					else
        						Exclude(Flags, rfHasOggTag);

                  if length(trim(Ogg.Lyrics)) > 0 then
                  	Include(Flags, rfHasLyrics);

									kbps := Ogg.BitRate;
									duration := round(Ogg.Duration*1000);
									channels := Ogg.ChannelModeID;
									freq := Ogg.SampleRate;
									addQuality := Ogg.BitRateNominal;

									artist := Ogg.Artist;
									title := Ogg.Title;
									album := Ogg.album;
									comment := Ogg.Comment;
                  s := Trim(Ogg.Track);
                  if GetTrackNoInt(s) > 0 then
                  	Track := GetTrackNoInt(s);
                  if GetTotalTracksInt(s) > 0 then
                  	TotalTracks := GetTotalTracksInt(s);

									if (length(Ogg.Date) = 4) and Q_IsInteger(Ogg.Date) then
										Year := StrToInt(Ogg.DAte);
									genreIndex := GetGenreID(Ogg.Genre);
									if genreIndex >= 0 then
									begin
                  	setLength(genr, length(genr)+1);
                    genr[length(genr)-1] := genreIndex
									end;

                  GetOggRatingTagIndex(Ogg, Rating);

									//Groups
									for i:=Ogg.AdditionalTags.Count-1 downto 0 do
									begin
                  	s := Ogg.GetAddListKeyName(Ogg.AdditionalTags.Strings[i], value);
                    if length(s) > 0 then
                    begin
											if Q_SameText(s, ApeOggGroupIdent) then
	                    begin
												if (length(value)>0) then
	                      	case AddGroupToRec(value, Grps, x) of
	                        	agtrrAddGroup:
														begin
															SetLength(Grps, length(Grps)+1);
															Grps[length(Grps)-1] := x
														end;
	                          agtrrRemoveGroupFromTag:
	                          if (FileMode = fmOpenReadWrite) then
	                          begin
															Ogg.AdditionalTags.Delete(i);
	                            Ogg.SaveTag
	                          end;
	                        end
	                      end
											else
											if Q_SameText(s, ApeOggCompilationIdent) then
	                      Include(Flags, rfCompilation)
	                    else
	                    if Q_SameText(s, 'ARTISTSORTORDER') and (length(value) > 0) then
	                    begin
	                    	//SetFlag(Flags, RF_ArtistSortOrderInTag, true);
	                      ArtistSortOrder := value
	                    end
	                    else
	                    if Q_SameText(s, 'DISCNUMBER') and (length(value) > 0) and Q_IsInteger(value) and (StrToInt(value) <= 16) then
	                    	SetPartOfSet(PartOfSet, StrToInt(value))
	                    else
	                    	if Assigned(NewRec) and (length(value) > 0) then
	                        for x:=0 to FieldList.Count-1 do
	                          if Q_SameText(s, PCustomField(FieldList.Items[x]).OggFieldName) then
	                            SetCustomFieldData(NewRec, x, value);
										end
                  end
							end
              else
              	 Exclude(Flags, rfHasOggTag);
						 Ogg.Free
				end else
				if audioType = 3 then //WMA - Windows Media Audio
				begin
						 Wma := TWMAfile.create;
						 result := wma.ReadFromFile(filename);
						 result := result and wma.Valid;
						 if result then
						 begin
                  if length(trim(wma.artist + wma.title + wma.album))>0 then
        						Include(Flags, rfHasWMATag)
        					else
        						Exclude(Flags, rfHasWMATag);

                  if length(trim(WMA.Lyrics)) > 0 then
                  	Include(Flags, rfHasLyrics);

									kbps := wma.BitRate;
									duration := round(wma.Duration*1000);
									channels := wma.ChannelModeID;
									freq := wma.SampleRate;

									artist := wma.Artist;
									title := wma.Title;
									album := wma.album;
									comment := wma.Comment;
									track := wma.Track;
									if (length(wma.Year) = 4) and Q_IsInteger(wma.Year) then
										 year := StrToInt(wma.Year);
									genreIndex := GetGenreID(wma.Genre);
									if genreIndex >= 0 then
									begin
                  	setLength(genr, length(genr)+1);
                    genr[length(genr)-1] := genreIndex
									end;

                  GetWMARatingTagIndex(Wma, Rating);

									//Groups
									for i:=0 to wma.AddList.Count-1 do
									begin
										s := wma.GetAddListKeyName(TStream(wma.AddList.Items[i]), wsValue);
										if Q_SameText(s, WMAGroupIdent) then
										begin
											while length(wsValue)>0 do
											begin
												if Q_StrScan(wsValue, #0)>0 then
												begin
													s := Q_CopyRange(wsValue, 1, Q_StrScan(wsValue, #0)-1);
                          wsValue := Q_CopyRange(wsValue, length(s)+2, length(wsValue));
													//Q_CutLeft(wsValue, length(s)+1)	<- don't work with widestring
												end
												else
												begin
													s := wsValue;
													wsValue := ''
												end;
												case AddGroupToRec(s, Grps, x) of
                        	agtrrAddGroup:
													begin
														SetLength(Grps, length(Grps)+1);
														Grps[length(Grps)-1] := x
													end;
                          agtrrRemoveGroupFromTag:
                          if (FileMode = fmOpenReadWrite) then
                          begin
														wma.AddList.Delete(i);
                            wma.WriteToStream(FStr)
                          end;
                        end
											end
										end
										else
                    if Q_SameText(s, WMACompilationIdent) then
                      Include(Flags, rfCompilation)
                    else
                    if Q_SameText(s, 'WM/ArtistSortOrder') and (length(wsValue) > 0) then
                    begin
                     	//SetFlag(Flags, RF_ArtistSortOrderInTag, true);
                      ArtistSortOrder := wsValue
                    end
                    else
                    if Q_SameText(s, 'WM/PartOfSet') and (length(wsValue) > 0) then
                    	SetPartOfSetFromString(PartOfSet, wsValue)
                    else
                      	if Assigned(NewRec) and (length(wsValue) > 0) then
                          for x:=0 to FieldList.Count-1 do
                            if Q_SameText(s, PCustomField(FieldList.Items[x]).WmaFieldName) then
                              SetCustomFieldData(NewRec, x, wsValue);
									end
						 end
             else
             	Exclude(Flags, rfHasWMATag);
						 wma.Free
				end else
				if audioType = 4 then //Ape - Money's audio
				begin
						 Monkey := TMonkey.create;
						 result := Monkey.ReadFromStream(FStr, AudioDataStartPosition);
						 result := result and Monkey.Valid;
						 if result then
						 begin
                if Monkey.Duration >0 then
                begin
                  kbps := Round((Fstr.Size /125) / Monkey.Duration);
                end;
                duration := round(Monkey.Duration*1000);
                channels := Monkey.channels;
                freq := Monkey.SampleRate;

                addQuality := Monkey.CompressionID;
						 end;
						 Monkey.Free
				end else
				if audioType = 5 then //WAV
				begin
						 Wav := TWavFile.create;
						 result := Wav.ReadFromStream(FStr);
						 result := result and Wav.Valid;
						 if result then
              begin
                if Wav.Duration >0 then
                	kbps := Round(((int64(Fstr.Size) *8) / Wav.Duration) / 1000);
                duration := round(Wav.Duration*1000);
                channels := Wav.ChannelNumber;
                freq := Wav.SampleRate
              end;
						 Wav.Free
				end;

        if audioType >= PREDEFINED_AUDIOTYPESCOUNT then
        begin
        	//COSTUM AUDIOTYPE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          if WinampVersion >= $2900 then
          begin
            result := true;

            kbps := 0;
            channels := -1;
            freq := 0;
            addQuality := 0;

            FillChar(basicFileInfo, SizeOf(basicFileInfo), #0);
            basicFileInfo.quickCheck := 0;
            basicFileInfo.filename := pchar(filename);
            basicFileInfo.titlelen := 255;
            GetMem(basicFileInfo.title, basicFileInfo.titlelen);
            x := SendMessage(hwnd_winamp,WM_WA_IPC, LongInt(@basicFileInfo), 291);
            if x = 1 then
            begin
              title := String(pchar(basicFileInfo.title));
              if basicFileInfo.length > 0 then
	              duration := basicFileInfo.length * 1000
            end;
            FreeMem(basicFileInfo.title, basicFileInfo.titlelen);

            if length(title) = 0 then
            	title := GetExtendedInfo(filename, 'title');
            artist := GetExtendedInfo(filename, 'artist');
            album := GetExtendedInfo(filename, 'album');
            comment := GetExtendedInfo(filename, 'comment');

            s := GetExtendedInfo(filename, 'genre');
            genreIndex := GetGenreID(s);
            if genreIndex >= 0 then
            begin
            	setLength(genr, length(genr)+1);
              genr[length(genr)-1] := genreIndex
            end;

            s := trim(GetExtendedInfo(filename, 'track'));
            if Q_IsInteger(s) then
            	track := StrToInt(s);

            if duration = 0 then
            begin
	            s := trim(GetExtendedInfo(filename, 'length'));
	            if Q_IsInteger(s) and (StrToInt(s) > 0) then
	            	duration := StrToInt(s) * 1000
            end
          end
          else
          	result := false
        end;

				if result then
        begin

        Fsize := Fstr.Size;

				//CRC start
				Crc := 0;
				if calculateCRC then
				begin
					// Read the first 256 bytes from  10%, 50%, 90% and the last 256 bytes of the mpeg-part of the file
					mpegSize := Fsize - AudioDataStartPosition;
					if HasV1Tag then
          	dec(mpegSize,128);

          /////////////////
					Fstr.Position := round((mpegSize * 0.1)) + AudioDataStartPosition + 100;
					Fstr.Read(ch255,256);
					//Crc := CRC32(Crc, ch255);
          crc := Q_CRC32(@ch255, 256);
					Fstr.Position := round((mpegSize * 0.5)) + AudioDataStartPosition + 100;
					Fstr.Read(ch255,256);
					//Crc := CRC32(Crc, ch255);
          Q_NextCRC32(crc, @ch255, 256);
					//90%
					Fstr.Position := round((mpegSize * 0.9)) + AudioDataStartPosition + 100;
					Fstr.Read(ch255,256);
					//Crc := CRC32(Crc, ch255);
          Q_NextCRC32(crc, @ch255, 256);

					Fstr.Position := mpegSize + AudioDataStartPosition - 1024;
					Fstr.Read(ch255,256);
					//Crc := CRC32(Crc, ch255);
          Q_NextCRC32(crc, @ch255, 256);
				end;

				if HasV1Tag or HasV2Tag then
				begin
          s := '';
          //Artist
          if assigned(Id3v2) then
             //Id3v2.getAsciiText('TPE1', s);
             s := Id3v2.GetText(fiLeadArtist);
          if trim(s) <> '' then
             Artist := trim(s)
          else if assigned(Id3v1) and (trim(Id3v1.Artist) <> '') then
               Artist := trim(Id3v1.Artist);

          //Title
          s := '';
          if assigned(Id3v2) then
             s := Id3v2.GetText(fiTitle); // TIT2
          // On some files TIT2 = Track ## and Id3v1 is the right one
          if Q_SameTextL('Track', s, 5) and Q_IsInteger(trim(Q_CopyFrom(s,6))) and assigned(Id3v1) and (length(trim(Id3v1.Title))>0) then
             Title := trim(Id3v1.Title)
          else
              if trim(s) <> '' then
                 Title := trim(s)
              else if assigned(Id3v1) and (trim(Id3v1.Title) <> '') then
                   Title := trim(Id3v1.Title);

          if HasV1Tag and not HasV2Tag and not HasApeTag and (audioType in [0, 1, 4]) then //mp3, musepack, Monkeysaudio
            CheckIfValueIsCroppedFromFileName := true;

          //Album
          s := '';
          if assigned(Id3v2) then
             //Id3v2.getAsciiText('TALB', s);
             s := Id3v2.GetText(fiAlbum);
          if trim(s) <> '' then
             Album := trim(s)
          else if assigned(Id3v1) and (trim(Id3v1.Album) <> '') then
               Album := trim(Id3v1.Album);

          //Comment
          { Comment kan ikke lses umiddelbart fra Id3v2.
          Dette gres frst sammen med lsning af groups og genres}
          if assigned(Id3v1) and (trim(Id3v1.Comment) <> '') then
             Comment := trim(Id3v1.Comment);

          //Year
          s := '';
          if assigned(Id3v2) then
             // Id3v2.getAsciiText('TYER', s);
             s := Id3v2.GetText(fiYear);
          Q_TrimInPlace(s);
          if not Q_IsInteger(s) and assigned(Id3v2) then
          begin
               //Id3v2.getAsciiText('TDRC', s);
               s := Id3v2.GetText(fiRecordingTime);
               Q_TrimInPlace(s)
          end;
          if Q_IsInteger(s) then
             year := strtoint(s)
          else if assigned(Id3v1) and Q_IsInteger(Id3v1.Year) then
               year := strtoint(Id3v1.Year)
          else year := -1;

          //Track
          s := '';
          if assigned(Id3v2) then
            //Id3v2.getAsciiText('TRCK', s);
            s := Id3v2.GetText(fiTrackNum);
          Q_TrimInPlace(s);
          if GetTrackNoInt(s) > 0 then
            track := GetTrackNoInt(s);
          if GetTotalTracksInt(s) > 0 then
            TotalTracks := GetTotalTracksInt(s);

          if (track = 0) and assigned(Id3v1) and (Id3v1.Track <> 0) then
               Track := Id3v1.Track;
          if not track in [0..255] then track := 0;

          //Genre, Id3v1 - kommer efter Id3v2!
          Id3v2GenreAdded := false;

          //Id3v2:
          if assigned(Id3v2) and HasV2Tag then
          	for i:=0 to Id3v2.Frames.Count-1 do
            begin
              Id3v2FrameId := Id3v2.Frames[i].FrameID;
              Id3v2FrameName := Id3v2.Frames[i].FrameName;
              
              if (Id3v2FrameId = fiUnsyncedLyrics) and not (Length(TJvId3ContentFrame(Id3v2.Frames[i]).Text) > 0) then     //Lyrics
                Include(flags, rfHasLyrics)
              else
              if Id3v2FrameId = fiContentType then     //genre
              begin
                id3v2SimpleListFrame :=  TJvID3SimpleListFrame (id3v2.Frames[i]);

//                Genres := TStringlist.create;
  //              Id3v2.getTCON(Genres, i, remix, cover);

//                if remix then
//                  Genres.Add('rx');
//                if cover then
//                  Genres.Add('cr');

                for x:=0 to id3v2SimpleListFrame.List.Count-1 do
                begin
                  genreIndex := getGenreID(id3v2SimpleListFrame.List[x]);
                  if genreIndex >= 0 then
                  begin
                    b := false;
                    for k:=0 to length(genr)-1 do
                    b := b or (genreIndex = genr[k]);
                    if not b then
                    begin   //Tilfj genren
                      setLength(genr, length(genr)+1);
                      genr[length(genr)-1] := genreIndex;
                      Id3v2GenreAdded := true
                    end
                  end
                end;
              end //TCON
              else
              if Id3v2FrameId = fiComment then    //Comments
              begin
                id3v2ContentFrame := TJvID3ContentFrame(id3v2.Frames[i]);
                if length(id3v2ContentFrame.Description) = 0 then		//Added 19/07-05
                begin
	                value := id3v2ContentFrame.Text;
	                value := Q_ReplaceStr(value, #13, ' ');
	                Q_DeleteStr(value, #10);//                 value := Q_ReplaceStr(value, #10, '');
	                if length(value) > 0 then
                  	comment := value
                end
                else
                begin
                  // The description is not empty. It can then be used to store custom fields in
                	if Assigned(NewRec) then
                  begin
	                	//Check custom fields
	                  for x:=0 to FieldList.Count-1 do
	                  begin
	                  	cf := PCustomField(FieldList.List^[x]);
	                    if Q_SameText(Id3v2FrameName, cf.Id3v2FieldName) and
	                			(cf.id3v2ReadAllLanguages or Q_SameText(id3v2ContentFrame.language, cf.id3v2DefaultLanguage))
                        and Q_SameText(id3v2ContentFrame.description, cf.id3v2Description) then
	                    begin
	                    	SetCustomFieldData(NewRec, x, id3v2ContentFrame.Text)
                      end
                    end
                  end
                end
              end
              else
              begin
                if Id3v2FrameId = fiPrivate then
                begin
                  // mexp private frame (groups, compilation) starts with "www.mexp.dk#0"
                  Mstr := TMemoryStream.Create();
                  TJvID3BinaryFrame(Id3v2.Frames[i]).SaveToStream(Mstr);
                  if MStr.Size >= 12 then
                  begin
                    SetString(Diz, PAnsiChar(MStr.Memory), 12);
                    if Q_SameStr(Diz, 'www.mexp.dk' + #0) then
                    begin
                      MStr.position := 12;
                      while Mstr.Position < Mstr.Size do
                      begin
                        Mstr.read(bt, 1);
                        if (bt = 1) and (MStr.Size - MStr.Position >= 5) then
                        begin   //group
                          Mstr.read(k, 4); // length of data (incl. encoding)
                          Mstr.read(bt, 1);  // encoding
                          dec(k);
                          if (bt = 0) and (MStr.Size - MStr.Position >= k)  then
                          begin //ASCII,  no support for unicode in the version
                            SetString(value, PAnsiChar(Mstr.Memory) + MStr.Position, k);
                            MStr.Seek(k, soFromCurrent);
                            case AddGroupToRec(value, Grps, x) of
                              agtrrAddGroup:
                                begin
                                  SetLength(Grps, length(Grps)+1);
                                  Grps[length(Grps)-1] := x
                                end;

                              agtrrRemoveGroupFromTag:
                                // remove the group from the tag and write new tag
                                if (FileMode = fmOpenReadWrite) then
                                begin
                                  // write the rest of the stream to the buffer
                                  SetLength(Buffer, MStr.Size - MStr.Position);
                                  if length(buffer) > 0 then
                                    MStr.Read(Buffer[0], MStr.Size - MStr.Position);

                                  // seek to start position of the group
                                  MStr.Seek(- (length(Buffer) + k + 5), soFromCurrent);

                                  // overwrite the group with the contents of buffer
                                  if length(Buffer) > 0 then
                                    MStr.Write(Buffer[0], Length(Buffer));

                                  // shorten the stream and save it.
                                  MStr.Size := MStr.Position;

                                  TJvID3BinaryFrame(Id3v2.Frames[i]).LoadFromStream(MStr);
                                  Id3v2.SaveToStream(FStr);

                                  // seek to the position after the removed group (buffer contained the rest of the stream, so use the size of that)
                                  MStr.Seek(-length(Buffer), soFromEnd);
                                  SetLength(Buffer, 0)
                                end;
                            end  //of case
                          end //of if bt = 0 then
                        else
                          Mstr.Position := Mstr.position + k
                        end
                        else
                        if bt = 2 then
                        begin  //compilation
                          Mstr.read(k, sizeOf(k)); // read size, though not used
                          Include(Flags, rfCompilation)
                        end
                        else
                        begin // en anden unsupp. frame
                          Mstr.read(k, sizeOf(k)); //size;
                          Mstr.position := Mstr.position + k
                        end
                      end
                    end
                  end;
                  Mstr.free
                end
                else
                	if Id3v2FrameId = fiPerformerSortOrder then
                  begin
                  	s := TJvID3TextFrame(Id3v2.Frames[i]).Text;
                    Q_TrimInPlace(s);
                    if length(s) > 0 then
                    begin
	                    ArtistSortOrder := s
                    end
                  end
                  else
                  if Id3v2FrameId = fiPartInSet then
                  begin
                  	s := TJvID3TextFrame(id3v2.Frames[i]).Text;
                    Q_TrimInPlace(s);
                  	SetPartOfSetFromString(PartOfSet, s)
                  end
                  else
                  if (Id3v2FrameID = fiPopularimeter)
                    and (Q_SameText(TJvID3PopularimeterFrame(Id3v2.Frames[i]).EMailAddress, pref.txtEmail.Text)) then
                  begin
                    rating := TJvID3PopularimeterFrame(Id3v2.Frames[i]).Rating;
                  	//GetId3v2RatingFrameIndex(Id3v2, Rating)
                  end
                  else
                  if Id3v2FrameID = fiPicture then
                  	containsCover := true
                  else
                  //test custom fields
                  if Assigned(NewRec) and (Q_CompText(Id3v2FrameName, 'T000') >= 0) and (Q_CompText(Id3v2FrameName, 'TZZZ') <= 0) then
                  begin
                    for x:=0 to FieldList.Count-1 do
                    begin
                    	cf := PCustomField(FieldList.List^[x]);
                      if Q_SameText(Id3v2FrameName, cf.Id3v2FieldName) then
                      begin
                      	if Id3v2FrameId = fiUserText then
                        begin
                          txxxFrame := TJvID3UserFrame(Id3v2.Frames[i]);
                          s := txxxFrame.Value;
                          if not Q_SameText(txxxFrame.Description, cf.id3v2Description) then
                          	continue	//this is not the TXXX frame we're looking for
                        end
                        else
                        begin
                          if Id3v2.Frames[i] is TJvID3TextFrame then
  	                        s := TJvID3TextFrame(Id3v2.Frames[i]).Text
                          else if Id3v2.Frames[i] is TJvID3SimpleListFrame and (TJvID3SimpleListFrame(Id3v2.Frames[i]).List.Count > 0) then
                            s:= TJvID3SimpleListFrame(Id3v2.Frames[i]).List[0];
                        end;
                        Q_TrimInPlace(s);
                        SetCustomFieldData(NewRec, x, s);
                      end
                    end
                  end
              end
            end;             //Id3v2

             //Genre, Id3v1
            if HasV1Tag and assigned(Id3v1) and (Id3v1.GenreID <= MAXGENRES) and
               (not Id3v2GenreAdded or not pref.SkipId3v1Genre.Checked) then
            begin
              b := false;
              for x:=0 to length(genr)-1 do
                b := b or (Id3v1.GenreID = genr[x]);
              if not b then
              begin   //Tilfj genren
                setLength(genr, length(genr)+1);
                genr[length(genr)-1] := Id3v1.GenreID
              end
            end;  //Genre / Contenttype
          end;  // of if hasid3v1 & id3v2


            if HasApeTag then
            begin
              if length(trim(Ape.Lyrics)) > 0 then
                Include(Flags, rfHasLyrics);

              //artist
              if length(trim(Ape.Artist)) > 0 then
                Artist := Ape.Artist;
              //Title
              if length(trim(Ape.Title)) > 0 then
                Title := Ape.Title;

              //Album
              if length(trim(Ape.Album)) > 0 then
                Album := Ape.Album;

              //Comment
              if length(trim(Ape.Comment)) > 0 then
                Comment := Ape.Comment;

              //Year
              if (length(trim(Ape.Year)) > 0) and Q_IsInteger(String(Ape.Year)) then
                Year := StrToInt(Ape.Year);

              //Track
              s := trim(Ape.Track);
              if GetTrackNoInt(s) > 0 then
                Track := GetTrackNoInt(s);
              if GetTotalTracksInt(s) > 0 then
                TotalTracks := GetTotalTracksInt(s);

              //Genre
              genreIndex := getGenreID(Ape.Genre);
              if genreIndex >= 0 then
              begin
                b := false;
                for k:=0 to length(genr)-1 do
                  b := b or (genreIndex = genr[k]);
                if not b then
                begin   //Tilfj genren
                  setLength(genr, length(genr)+1);
                  genr[length(genr)-1] := genreIndex
                end
              end;

              GetApeRatingTagIndex(Ape, Rating);

              for i:=0 to Ape.AddList.Count-1 do
              begin
                s := Ape.GetAddListKeyName(TStream(Ape.AddList.Items[i]), value);
                //Groups
                if Q_SameText(s, ApeOggGroupIdent) then
                begin
                  while length(value)>0 do
                  begin
                    if Q_StrScan(value, #0)>0 then
                    begin
                      s := Q_CopyRange(value, 1, Q_StrScan(value, #0)-1);
                      Q_CutLeft(value, length(s)+1)
                    end
                    else
                    begin
                      s := value;
                      value := ''
                    end;
                    case AddGroupToRec(s, Grps, x) of
                      agtrrAddGroup:
                      begin
                        SetLength(Grps, length(Grps)+1);
                        Grps[length(Grps)-1] := x
                      end;
                      agtrrRemoveGroupFromTag:
                      if (FileMode = fmOpenReadWrite) then
                      begin
                        ape.AddList.Delete(i);
                        ape.SaveToStream(Fstr, ape.Version)
                      end;
                    end
                  end
                end
                else
                if Q_SameText(s, ApeOggCompilationIdent) then
                  Include(Flags, rfCompilation)
                else
                if Q_SameText(s, 'ArtistSortOrder') and (length(value) > 0) then
                begin
                  //SetFlag(Flags, RF_ArtistSortOrderInTag, true);
                  ArtistSortOrder := value
                end
                else
                if Q_SameText(s, 'PartOfSet') and (length(value) > 0) then
                  SetPartOfSetFromString(PartOfSet, value)
                else
                if Assigned(NewRec) then
                	for x:=0 to FieldList.Count-1 do
                  	if (Length(value) > 0) and Q_SameText(s, PCustomField(FieldList.Items[x]).ApeFieldName) then
                      SetCustomFieldData(NewRec, x, value);
              end
            end; //of has Ape tag

            //Sger efter Lyrics 3
            if Audiotypes[Audiotype].audio and not (rfHasLyrics in Flags) and (FStr.Size > 137) then
            begin
              if HasV1Tag then
                FStr.Position := FStr.Size - 137
              else
                FStr.Position := FStr.Size - 9;
              FStr.Read(Lyrics3Str, 9);
              if Q_SameStr(Lyrics3Str, 'LYRICSEND') or Q_SameStr(Lyrics3Str, 'LYRICS200') then
                Include(Flags, rfHasLyrics)
            end;

            if NewRec <> nil then //Kopierer genres, groups
            begin
              if changeGroups then
              begin
                SetLength(NewRec.groups,length(Grps));
                for x:=0 to length(Grps)-1 do
                	NewRec.groups[x] := Grps[x]
              end;

              SetLength(NewRec.genre,length(genr));
              for x:=0 to length(genr)-1 do
              	NewRec.Genre[x] := genr[x]
            end
					end; // of if result
          if Id3v1EqualsId3v2(Id3v1, Id3v2) then
          	Include(flags, rfEqualId3)
          else
          	Exclude(flags, rfEqualId3);

        	if not containsCover and assigned(Id3v2) then	Id3v2.free;
        	if assigned(Id3v1) then Id3v1.free;
        	if assigned(Ape) then Ape.free;
        	Fstr.free
        finally
        	if AudioTypes[audioType].audio and ((not result) or (not containsCover)) then
          	EndUseId3v2;
        end;

      end;   // of fileexists
      setLength(genr, 0);
      setLength(grps, 0);

      if result and (pref.CorrectTags.Checked or (length(artist) = 0) or (length(title) = 0)) then
        SuggestFromFilename(scanpath, filename, Artist, Title, Album, Track, filenames, CheckIfValueIsCroppedFromFileName, playlistFiles);

			try
      	if containsCover and assigned(Id3v2) then
	      begin
	      	coverRec := ProcessId3v2Pictures(id3v2);
	        Id3v2.Free
	      end;
      finally
      	if AudioTypes[audioType].audio and containsCover and result then
        	EndUseId3v2;
      end;

	if master <> master_DirSpy then
  	Dec(SafeToAutoScanCount);
End;

{procedure TMainForm.AddCoverFromTagToDatabase(artist, album: integer; image:TStream; mime: string; crc: LongWord);
var
	cr: PCoverRec;
  fstr: TStream;
begin
	new(cr);
  FillChar(cr^, SizeOf(cr^), 0);
  cr.Artist := artist;
  cr.Album := album;
  cr.ImageCRC := crc;
  cr.state := NotLoaded;
  cr.ImageFilename := RandomFilename(CoverFromTagCacheDir, Q_CopyFrom(mime, 1 + Q_StrScan(mime, '/')), true);
  fstr := TFileStream.Create(cr.ImageFilename, fmCreate);
  fstr.CopyFrom(image, image.Size - image.Position);
  fstr.Free;

  fCoverImgsRW.AcquireWriter;
  fCoverImgs.Add(cr);
  fCoverImgsRW.ReleaseWriter
end;   }

{function TMainForm.CoverCrcExists(crc: LongWord): boolean;
var
	i: integer;
begin
	fCoverImgsRW.AcquireReader;
  fCoverRecRW.AcquireReader;

  try
		result := false;
	  for i:=0 to fCoverImgs.Count-1 do
	  	if PCoverRec(fCoverImgs.Items[i]).ImageCRC = crc then
	    begin
	    	result := true;
	      exit
	    end
  finally
  	fCoverImgsRW.ReleaseReader;
    fCoverRecRW.ReleaseReader
  end
end;  }

{function TMainForm.FindCoverRec(artist, album, dbindex: integer): PCoverRec;
var
	i: integer;
//  cr: PCoverRec;
	rec: PRec;
begin
//	fCoverImgsRW.BeginRead;
//  fCoverRecRW.BeginRead;

//  try
		result := nil;
	  for i:=0 to fCoverImgs.Count-1 do
	  begin
      rec := PCoverRec(fCoverImgs.List^[i]).SourceRec;
      if (rec.ArtistSortOrder = artist) and (rec.Album = album) and (rec.Location = dbindex) then
	    begin
	    	result := fCoverImgs.List^[i];
	      exit
	    end
	  end
//    finally
//  	fCoverImgsRW.EndRead;
//    fCoverRecRW.EndRead
//  end
end; }

procedure TMainForm.ChangeGroupName(group: PGroupRec; newName: string);
var
	nameChanged, nameExists: Boolean;
	i, k, groupIndex: Integer;
  rec: PRec;
  lst, recs: TList;
  tagValues : PTagValues;
  tagValuesList, rollBackValuesList: Tlist;
begin
	Q_TrimInPlace(newName);
	if Q_SameStr(group.name, newName) then
  	exit;

  groupIndex := -1;
  for i:=0 to grouplist.count-1 do
  	if grouplist.Items[i] = group then
    	groupIndex := i;
  if groupIndex = -1 then
  	exit;

  //Check if there's another group with this name
  nameExists := false;
  for i:=0 to GroupList.Count-1 do
  	nameExists := nameExists or (Q_SameText(PGroupRec(GroupList.Items[i]).Name, newName) and (GroupList.Items[i] <> Group));
  if nameExists then
  begin
  	ShowmessageX('Cannot rename group - a group named "' + newName + '" already exists.');
    exit
  end;

  lst := TList.Create;
  for i:=0 to reclist.count-1 do
  begin
  	rec := reclist.Items[i];
    if HasGroup(rec, groupIndex) then
    	lst.Add(rec)
  end;

	if lst.Count > 0 then
  begin
    if YesNoBoxx('Change group name', 'This group contains ' + inttostr(lst.Count) + ' file(s). The group-information can be stored in the tags of these files.' + crlf +
    	'Do you want to change the tag of these files to reflect changes to the group name?', GETTEXT(TXT_YES), GETTEXT(TXT_NO), 1) then
    begin
      recs:= TList.Create;        	//These are free'd in updateRecvaluesMethod
      tagValuesList:= TList.Create;	//These are free'd in updateRecvaluesMethod
      rollBackValuesList := TList.Create; //These are free'd in updateRecvaluesMethod

    	for i:=0 to lst.Count-1 do
      begin
      	New(tagValues);
	    	SetLength(tagValues^, 1);
	      tagValues^[0].field := FRemoveGroup;
	      tagValues^[0].value := group.Name;
        recs.Add(lst.Items[i]);
        tagValuesList.Add(tagValues);
        //Rollback values
        New(tagValues);
	    	SetLength(tagValues^, 1);
	      tagValues^[0].field := FAddGroup;
	      tagValues^[0].value := group.Name;
        rollBackValuesList.Add(tagValues);
      end;

      if UpdateRecValues(recs, tagValuesList, rollBackValuesList, 'Renaming group... (Step 1/2)', true, true) <> UpdateRecValuesResult_Cancelled then
      begin
      	group.Name := newName;

      	recs:= TList.Create;            //These are free'd in updateRecvaluesMethod
	      tagValuesList:= TList.Create;   //These are free'd in updateRecvaluesMethod

	    	for i:=0 to lst.Count-1 do
	      begin
	        New(tagValues);
		    	SetLength(tagValues^, 1);
		      tagValues^[0].field := FAddGroup;
		      tagValues^[0].value := group.Name;

	        recs.Add(lst.Items[i]);
	        tagValuesList.Add(tagValues)
	      end;
	      UpdateRecValues(recs, tagValuesList, nil, 'Renaming group.. (Step 2/2)', false, true);
      end
    end
  end
  else
  begin
  	group.Name := newName;
  end;

  lst.Free;
end;

function TMainForm.HasGroup(const g:array of byte; groupIndex:integer):boolean;
var
	i:integer;
begin
  for i:=0 to length(g)-1 do
  	if g[i] = groupIndex then
    begin
    	result := true;
      exit
    end;
  result := false;
end;

Function TMainForm.HasGroup(rec: PRec; groupIndex:integer):boolean;
var
	i:integer;
begin
	for i:=0 to length(rec.Groups)-1 do
  	if rec.Groups[i] = groupIndex then
    begin
    	result := true;
      exit
    end;
  result := false;
end;

function TMainForm.GroupFilter(rec: Prec; includeGroupsSelectedInTree: boolean):Boolean;
var
  i: integer;
begin

	if length(Rec.Groups) = 0 then
  begin
  	if includeGroupsSelectedInTree then
    	result := not (FInvertGroupsChecked or FGroupSelectedInTree)
    else
    	result := not FInvertGroupsChecked
  end else
  begin
    result := fAndGroups;
    if fAndGroups then
    begin
      for i:=0 to groupList.count-1 do
        if ((PGroupRec(groupList.List^[i]).Checkstate = GroupCheckState_Checked) or (includeGroupsSelectedInTree and PGroupRec(groupList.List^[i]).Selected)) and not HasGroup(Rec, i) then
        begin
          result := false;
          break
        end
    end
    else
      for i:=0 to length(Rec.Groups)-1 do
        if ((PGroupRec(groupList.List^[Rec.Groups[i]]).Checkstate = GroupCheckState_Checked) or (includeGroupsSelectedInTree and PGroupRec(groupList.List^[Rec.Groups[i]]).Selected))  then
          result := true;

    //Added to support exclude groups (13-06-06):
    if result then
    begin
       for i:=0 to length(Rec.Groups)-1 do
        if PGroupRec(groupList.List^[Rec.Groups[i]]).Checkstate = GroupCheckState_Exclude then
          result := false
    end
  end;
end;

Procedure TMainForm.CleanThisString(var S:String; doEverything:Boolean=false);
var
	o:integer;
begin
  Q_TrimInPlace(s);
  if length(s) > 0 then
  begin
      //fjerner () fra (s)
      if (doEverything or pref.removeBrackets.checked) and ((length(s) > 3) and (((s[1] = '(') and (s[length(s)]=')') and (Q_StrScan(Q_CopyRange(s, 2, length(s)-1), ')')=0)) or ((s[1] = '[') and (s[length(s)]=']')))) then
      begin
        Q_CutLeft(s,1);
        Q_CutRight(s,1)
      end;
      Q_TrimInPlace(s);

      //fjerner leading '-'
      while (length(s)>1) and ((s[1] = '-') or (s[1] = '.')) do
        Q_cutLeft(s,1);

      //fjerner trailing '-'
      while (length(s)>1) and ((s[length(s)] = '-') or (s[length(s)] = ' ')) do
        Q_cutRight(s,1);

      if doEverything or pref.ConvertUnder.checked then
      Q_ReplaceChar(s, '_', ' ');

      Q_TrimInPlace(s);
      if doEverything or pref.CorrectCasing.Checked then
      begin
        s[1] := ansiuppercase(s[1])[1];
        if length(s) > 1 then
          s[2] := ansilowercase(s[2])[1];
        if length(s) > 2 then
          for o:=3 to length(s) do
            if (s[o -1] = ' ') or (s[o -1] = '.') or (s[o -1] = '-') or (s[o -1] = ')') or (s[o -1] = '(') or (s[o -1] = '"') then
              s[o] := ansiuppercase(s[o])[1]
            else
              s[o] := ansilowercase(s[o])[1]
      end;

      Q_TrimInPlace(s);
  end
end;

Function TMainForm.CleanString(const s:String; doEverything:Boolean=false):String;
begin
	result := s;
  CleanThisString(result, doEverything);
end;

Procedure TMainForm.SuggestFromFilename(const Scanpath : String; const Filename : String; var Artist : String; var Title : String; var Album : String; var Track : Integer; const filenames:TQ_StringList; CheckIfValueIsCroppedFromFileName: Boolean; playlistFiles: PPlaylistFiles);
//Begin Local Functions
function HasExt(const fn:string; const exts:array of string):boolean;
var
	i:integer;
  ext:string;
begin
  result := false;
  ext := getFileExt(fn);
  for i:=0 to length(exts)-1 do
  	result := result or Q_SameText(ext, exts[i])
end;

Procedure CreateFileList(const list:TStringlist; filename:string; exts:array of string; playlist:boolean=false);   //Avoid using this!
var
	i:integer;
begin
  list.clear;
  filename := getFilePath(filename);
  if assigned(filenames) and not playlist then
  begin
    for i:=0 to filenames.count-1 do
        if HasExt(filenames.Strings[i], exts) and Q_SameText(filename, getFilePath(filenames.strings[i])) then
           list.Add(filenames.strings[i])
  end else
  begin
    CreateFileListFF.Files.clear;
    CreateFileListFF.RootDirectory := filename;
    for i:=0 to length(exts)-1 do
  		CreateFileListFF.fileparams.filemasks.Add('*' + exts[i]);
    CreateFileListFF.Search;
    for i:=0 to CreateFileListFF.Files.count-1 do
    	list.add(CreateFileListFF.Files.strings[i]);
    CreateFileListFF.Files.Clear
  end
end;

Function GetTrackFromPlaylist(const filename : String; var track : Integer; var album : String) : Boolean;
var
  i, x, Tr : Integer;
  StrLst, flst : TStringlist;
  sArr:array of String;
begin
  result := false;

  if not pref.advTrackCalc.checked or not getFileAccess(filename, true, false) then
  	exit;

  if assigned(playlistFiles) then
  begin
		for i:=0 to length(playlistFiles.playlists)-1 do
    	if Q_SameText(getFilePath(filename), GetFilePath(playlistFiles.playlists[i].filename)) and UsePlaylistForTrackInfo(playlistFiles.playlists[i].filename) and playlistFiles.playlists[i].files.Find(filename, x) then
      begin
      	track := integer(playlistFiles.playlists[i].files.Objects[x]);
        if length(album) = 0 then
        	album := GetFilename(playlistFiles.playlists[i].filename, false);
        result := true;
        break
      end
  end
  else
  begin
    flst := TStringlist.create;

    setLength(sArr, 1);
    sArr[0] := '.m3u';

    CreateFileList(flst, filename, sArr, true);

    if flst.Count > 0 then
    begin
	    StrLst := TStringlist.create;
	    for i:=0 to flst.count-1 do
		    if UsePlaylistForTrackInfo(flst.strings[i]) then
		    begin
			    StrLst.LoadFromFile(flst.strings[i]);
			    Tr := 0;
			    for x:=0 to StrLst.count-1 do
			    begin
				    if StrLst.strings[x] <> '#' then
				    begin
					    inc(Tr);
					    if Q_PosText(getFilename(filename), StrLst.strings[x]) > 0 then
					    begin
						    if length(Album) = 0 then
						      Album := getFilename(flst.strings[i], false);

						    Track := Tr;
						    result := true;
						    break
              end;
				    end
			    end;
	    	if result then
	    		break
    	end;
	  	StrLst.free
	 	end;
		flst.free
	end
end;

Function CheckTrackFromOtherFiles(const filename : String; Track : Integer) : Boolean;
var
  ext, path : String;
  i: Integer;
begin
	result := false;
  if not pref.advTrackCalc.checked or not assigned(filenames) then
     exit;

	if filenames.Find(filename, i) then
  begin
    ext := GetFileExt(filename);
    path := GetFilePath(filename);
  	result := ((i > 0) and (track > 1) and Q_SameText(ext, GetFileExt(filenames.Strings[i-1])) and Q_SameText(path, GetFilePath(filenames.Strings[i-1]))
			    	and (Q_PosStr(intToStr(track-1), GetFilename(filenames.Strings[i-1], false)) > 0))
    	OR
      ((i < filenames.count-1) and Q_SameText(ext, GetFileExt(filenames.Strings[i+1])) and Q_SameText(path, GetFilePath(filenames.Strings[i+1]))
      			and (Q_PosStr(intToStr(track+1), GetFilename(filenames.Strings[i+1], false)) > 0))
  end

{
	//Old method - slow like hell!
flst := TStringlist.create;

  setLength(sArr, 1);
  sArr[0] := getfileext(filename);

  CreateFileList(flst, filename, sArr);
  flst.sort;
  x := 0;
  for i:=0 to flst.count-1 do
      if Q_SameText(Filename, flst.Strings[i]) then
  begin
       x:=i;
       break
  end;

  if x > 0 then
  begin
       prev := flst.Strings[x-1];
       prev := getfilename(prev);
       prev := copy(prev, 1, length(prev) - length(getfileext(prev)))
  end;
  if x < flst.count-1 then
  begin
       next := flst.Strings[x+1];
       next := getfilename(next);
       next := copy(next, 1, length(next) - length(getfileext(next)))
  end;
  result := (pos(inttostr(Track-1), prev) > 0) or (pos(inttostr(Track+1), next) > 0);
  flst.free    }
end;

Function FilesInSubDirCount(filename : String) : Integer;
var      lst:TQ_Stringlist;
         i, l:integer;
begin
  // TODO: optimize this
  filename := getFilePath(filename);
  Q_Cutright(filename, 1);
  filename := getFilePath(filename);

  if assigned(filenames) then
  begin
    lst := TQ_Stringlist.create;
    lst.sorted := true;
    lst.Duplicates := dupIgnore;

    l:=length(filename);
    for i:=0 to filenames.count-1 do
        if (length(filenames.strings[i])>l) and Q_SameTextL(filename, filenames.strings[i], l) and (Q_StrScan(filenames.strings[i], '\', l+1)>0) then
           lst.add(Q_CopyRange(filenames.strings[i], 1, Q_StrScan(filenames.strings[i], '\', l+1)));
    result := lst.count;
    lst.free;
  end else
  begin
  	FilesInSubdirCountFF.Directories.Clear;
    FilesInSubdirCountFF.RootDirectory := filename;
    FilesInSubdirCountFF.Search;
    result := FilesInSubdirCountFF.Directories.Count;
    FilesInSubdirCountFF.Directories.Clear
  end
end;

function EmptyTrack(t:string):boolean;
begin
  if length(t)>0 then
  begin
	  if Q_sameTextL(t, 'track', 5) then
	  begin
		  t := Q_ReplaceText(t, '.', ' ');
		  result := Q_isinteger(trim(Q_CopyFrom(t, 6)))
	  end
    else
    	result := false;
  end
  else result := true
end;

function GetIntsFrom(s:string; index:integer):String;   
begin
   Q_cutLeft(s, index);
   Q_TrimInPlace(s);
   result := '';
   while (length(s)>0) and Q_IsInteger(s[1]) do
   begin
        result := result + s[1];
        Q_CutLeft(s,1)
   end
end;
//MAIN
var
  i, j : Integer;
  s, fname : String;
  FirstSub, SecondSub : String;
  Tfname, TempArtist, TempAlbum, TempTitle, TempTrack : String;
  b, FoundArtistTitle, MightContainTrack : Boolean;
Begin
  fname := getFilename(Filename, false);

  //GetSubs:
  s := getfilepath(filename);
  Q_CutRight(s, 1);
  //removing dir that is scanned from
  if ScanPath <> '' then
  	Q_CutLeft(s, length(ScanPath));

  //Finding SubDirs
  while Q_StrScan(s, '\') > 0 do
  begin
    SecondSub := FirstSub;
    FirstSub := Q_CopyRange(s, 1, Q_StrScan(s, '\')-1);
    Q_CutLeft(s, Q_StrScan(s, '\'))
  end;

  if Q_sameText(s, 'mp3') then
  	s:='';
  SecondSub := FirstSub;
  FirstSub := s;
  SecondSub := CleanString(SecondSub);
  FirstSub := cleanString(FirstSub);

  FoundArtistTitle := false;
  MightContainTrack := false;
  TFname := CleanString(fname);        //For Temp use
  if (length(Artist) = 0) or emptyTrack(title) or (length(Album) = 0) or (Track <= 0) then     //Finder alle fields
  begin
	  // (Artist)-Title
  	i := Q_StrScan(TFname, '(');
    j := Q_PosStr(')-', TFname);
    if (i = 1) and (i < j) then
    begin
			tempArtist := Q_CopyRange(TFname, i+1, j-1);
      Q_CutLeft(TFname, j);
      if (length(TFname) > 2) and (TFname[1] = '-') then
      	Q_CutLeft(TFname, 1);
	    TempTitle := TFname;
	    FoundArtistTitle := true;
	    MightContainTrack := true
    end;

    {b := false; //'(' found before ')'
    for i:=1 to length(TFname) do
	  begin
	    if TFname[i] = '(' then
      	b := true;
	    if (not b) and (TFname[i] = ')') then
      	break;
	    tempArtist := tempArtist + TFname[i]
	  end;
	  if not b or (TFname = tempArtist) then
    	tempArtist := ''
    else
	  begin
	    Q_CutLeft(TFname, length(TempArtist)+2);
	    if (length(TFname) > 2) and (TFname[1] = '-') then
      	Q_CutLeft(TFname, 2);
	    TempTitle := TFname;
	    FoundArtistTitle := true;
	    MightContainTrack := true
  	end;                      }

    if not FoundArtistTitle then
    begin
      //Artist -- Title
      i := Q_PosStr('--', TFname);
      if i > 0 then
      begin
        TempArtist := Q_CopyRange(TFname, 1, i-1);
        TempTitle := Q_CopyFrom(TFname, i+2);
        MightContainTrack := true;
        FoundArtistTitle := true
      end
    end;

    if not FoundArtistTitle then
    begin
      // Artist - tracknum - title    (lngere nede)
      // tracknum - Artist - title
      b := false;
      if Q_CharCount(TFname, '-') in [2..3] then
      begin
        //is the first items integer?
        TempTrack := trim(Q_CopyRange(TFname, 1, Q_StrScan(TFname, '-')-1));
        if (length(TempTrack) < 3) and Q_IsInteger(TempTrack) then
          b := true;
        if b and ((TempTrack[1]='0') or CheckTrackFromOtherFiles(Filename, strtoint(TempTrack))) then       //Track is the first 1 or 2 chars (Hvis begyndende bogstav er 0, s er det hjst sansynligt et track nr
        begin
          // tracknum - Artist - title
          Q_CutLeft(TFName, Q_StrScan(TFName, '-'));
          Q_TrimInPlace(TFname);
          i := Q_PosStr(' - ', TFname);
          if i  > 0 then
          begin
            TempArtist := Q_CopyRange(TFname, 1, i-1);
            TempTitle := Q_CopyFrom(TFname, i+3)
          end else
          begin
            i := Q_PosStr('-', TFname);
            TempArtist := Q_CopyRange(TFname, 1, i-1);
            TempTitle := Q_CopyFrom(TFname, i+1)
          end;
          MightContainTrack := false;
          FoundArtistTitle := true
        end else
        begin
          // Artist - tracknum - title
          i := Q_StrScan(TFname, '-');
          j := Q_StrScan(TFname, '-', i+1);
          tempArtist := Q_CopyRange(TFname, 1, i-1);
          tempTrack := trim(Q_CopyRange(TFname, i+1, j-1));
          tempTitle := Q_CopyFrom(TFname, j+1);
          if Q_IsInteger(TempTrack) and CheckTrackFromOtherFiles(Filename, strtoint(TempTrack)) then
          begin
            FoundArtistTitle := true;
            MightContainTrack := false
          end
        end
      end;    //of x <=3
    end;

    If not FoundArtistTitle then
    begin
      //Artist _ Title  (' _ ' kun n gang)
      i := Q_PosStr(' _ ', fname);
      if (i > 0) and (Q_PosStr(' _ ', fname, i+1) = 0) then
      //if (Pos(' _ ', fname) > 0) and (pos(' _ ', copy(fname, pos(' _ ', fname)+3, 1024))=0) then
      begin
        TempArtist := Q_CopyRange(fname, 1, i-1); //trim(copy(fname, 1, pos(' _ ', fname)-1));
        TempTitle := Q_CopyFrom(fname, i+3);// trim(copy(fname, pos(' _ ', fname)+3, 1024));
        MightContainTrack := true;
        FoundArtistTitle := true
      end
    end;

    If not FoundArtistTitle then
    begin
    //Artist - Title
      i := Q_PosStr(' - ', TFname);
      if i > 0 then
      begin
        TempArtist := Q_CopyRange(TFname, 1, i-1);
        TempTitle := Q_CopyFrom(TFname, i+3);
        MightContainTrack := true;
        FoundArtistTitle := true
      end
    end;

    If not FoundArtistTitle then
    begin
      //Artist-Title
      i := Q_StrScan(TFname, '-');
      if i > 0 then
      begin
        TempArtist := Q_CopyRange(TFname, 1, i-1);
        TempTitle := Q_CopyFrom(TFname, i+1);
        MightContainTrack := true;
        FoundArtistTitle := true
      end
    end;

    If not FoundArtistTitle and pref.UseSubAlbum.checked then
    begin   //Artist\nn Track
      if (length(TFname) > 4) and (TFname[3]=' ') and (TFname[4]<>' ') and (length(FirstSub) > 0) and Q_IsInteger(Q_CopyRange(TFname, 1, 2)) then
      begin
        TempArtist := FirstSub;
        TempTitle := Q_CopyFrom(TFname, 4); //trim(copy(TFname, 4, 1024));
        TempTrack := Q_CopyRange(TFname, 1, 2);
        MightContainTrack := false;
        FoundArtistTitle := true
      end
    end;

    If not FoundArtistTitle and pref.UseSubAlbum.checked then
    begin   //Artist\nn Track  (Artist\nn-Trac)
      if (length(TFname) > 4) and (TFname[3]=' ') and (TFname[4]<>' ') and (length(FirstSub) > 0) and Q_IsInteger(Q_CopyRange(TFname, 1, 2)) then
      begin
        TempArtist := FirstSub;
        i := Q_PosStr(' - ', tempArtist);
        if i > 0 then
        begin
          TempAlbum := Q_CopyFrom(tempArtist, i+3); //copy(TempArtist, pos(' - ', TempArtist)+3, 1024);
          Q_CutLeft(TempArtist, i-1);	//TempArtist := copy(TempArtist, 1, pos(' - ', TempArtist)-1)
        end
        else
        if (length(SecondSub) > 0) and (FilesInSubDirCount(Filename) < 5) then   //Hvis der ikke er flere end 5 subdirs
        begin   //Artist\Album\nnTrack
          TempArtist := SecondSub;
          TempAlbum := FirstSub
        end;
        TempTitle := trim(Q_CopyFrom(TFname, 4));
        if (length(TempTitle) > 3) and ((TempTitle[1] = '-') or (TempTitle[1] = '.')) then
          Q_CutLeft(tempTitle, 1); //TempTitle := copy(TempTitle, 2, 1024);
        TempTrack := Q_CopyRange(TFname, 1, 2); //copy(TFname, 1, 2);
        MightContainTrack := false;
        FoundArtistTitle := true
      end
    end;

    If not FoundArtistTitle and pref.UseSubAlbum.checked then
    begin   //Artist\nnTrack
      if (length(TFname) > 3) and (TFname[3]<>' ') and (length(FirstSub) > 0) and Q_IsInteger(Q_CopyRange(TFname, 1, 2)) then
      begin
        tempArtist := FirstSub;
        i := Q_PosStr(' - ', tempArtist);
        if i > 0 then
        begin
          tempAlbum := Q_CopyFrom(tempArtist, i+3); //copy(TempArtist, pos(' - ', TempArtist)+3, 1024);
          tempArtist := Q_CopyRange(TempArtist, 1, i-1)
        end
        else
          if (length(SecondSub) > 0) and (FilesInSubDirCount(Filename) < 5) then   //Hvis der ikke er flere end 5 subdirs
          begin   //Artist\Album\nnTrack
            TempArtist := SecondSub;
            TempAlbum := FirstSub
          end;
        TempTitle := trim(Q_CopyFrom(TFname, 3)); //trim(copy(TFname, 3, 1024));
        if (length(TempTitle) > 3) and ((TempTitle[1] = '-') or (TempTitle[1] = '.')) then
          Q_CutLeft(tempTitle, 1);	//TempTitle := copy(TempTitle, 2, 1024);
        tempTrack :=Q_CopyRange(TFname, 1, 2);// copy(TFname, 1, 2);
        MightContainTrack := false;
        FoundArtistTitle := true
      end
	  end
	end;  //of if (Artist = '') and (title = '') then

  if not FoundArtistTitle and pref.UseSubAlbum.checked and ((length(Artist) = 0) or emptyTrack(title)) then
  //Der er ikke fundet noget. Kigger efter om filen mske er i en playlist. Hvis playlistens naven er identisk med
  //underbiblioteket er underunderbiblioteket artisten
  begin
    if GetTrackFromPlaylist(Filename, i, TempAlbum) then
    begin
      if Q_SameText(CleanString(TempAlbum), FirstSub) then
      begin
        TempArtist := SecondSub;
        TempTitle := TFname;
        TempTrack := inttostr(i);
        MightContainTrack := false;
        FoundArtistTitle := true
      end else
      if (Q_PosText(CleanString(TempAlbum), FirstSub) > 0) and (length(FirstSub) > length(cleanstring(TempAlbum)) +2) then
      begin
        TempArtist := Q_CopyRange(FirstSub, 1, length(FirstSub) - length(TempAlbum)); //copy(FirstSub, 1, length(FirstSub) - length(TempAlbum));
        TempTitle := TFname;
        TempTrack := inttostr(i);
        MightContainTrack := false;
        FoundArtistTitle := true
      end
    end
  end;

  if not FoundArtistTitle and pref.UseSubAlbum.checked and ((length(Artist) = 0) or emptyTrack(title)) then
  begin   //Der er ikke fundet noget
    if (length(Artist) = 0) and (length(firstSub)>0) then
    	Artist := firstSub;// else Artist := pref.unknown.text;
    if emptyTrack(title) then
    	Title := TFname
  end;

  if FoundArtistTitle then
  begin
	  CleanThisString(TempArtist);
	  CleanThisString(TempTitle);
	  CleanThisString(TempAlbum);
	  Q_TrimInPlace(TempTrack);
	  if not Q_IsInteger(TempTrack) then
    	TempTrack := '';

	  //Hvis artist er integer og er et tracknr
	  if (length(TempArtist) >= 2) and Q_IsInteger(TempArtist) and CheckTrackFromOtherFiles(Filename, strtoint(TempArtist)) then
	  begin
		  TempTrack := TempArtist;
		  TempArtist := ''
	  end;

	  //Finder Artist hvis den mangler.. baseret p underbibliotek
	  if pref.UseSubAlbum.checked and (length(Artist) = 0) and (length(TempArtist) = 0) then
	  begin
		  TempArtist := FirstSub;
      i := Q_PosStr(' - ', tempArtist);
		  if (i > 0) and (not Q_SameText(CleanString(TempArtist), Artist)) then
		  begin
			  TempAlbum := 	Q_CopyFrom(tempArtist, i+3); //copy(TempArtist, pos(' - ', TempArtist)+3, 1024);
			  Q_CutRight(TempArtist, length(tempArtist) - i+1) //copy(TempArtist, 1, pos(' - ', TempArtist)-1)
		  end
      else
      if (length(SecondSub) > 0) and (FilesInSubDirCount(Filename) < 5) then   //Hvis der ikke er flere end 5 subdirs
		  begin   //Artist\Album\nnTrack
			  TempArtist := SecondSub;
			  TempAlbum := FirstSub
		  end
	  end;

		//Finder track fra playlist position hvis den ikke er fundet endnu
    if (Track <= 0) and (length(TempTrack) = 0) then
    	if GetTrackFromPlaylist(Filename, i, TempAlbum) then
    		TempTrack := inttostr(i)
      else
      	if MightContainTrack then //title = nn. Title
		    begin
			    //nn. Title   // nn- title // nn-title // nn title
			    if (length(TempTitle) > 5) and Q_IsInteger(Q_CopyRange(tempTitle, 1, 2)) and ((TempTitle[3]='.') or (TempTitle[3]='-') or (TempTitle[3]=' ')) then
			    begin
				    TempTrack := Q_CopyRange(tempTitle, 1, 2);
            Q_CutLeft(tempTitle, 4);
				    TempTitle := CleanString(copy(TempTitle, 4, 1024));
				    MightContainTrack := false
			    end
		    end;

    if MightContainTrack then //artist = nn. Artist
    begin
      //nn. Artist   // nn- Artist // nn-Artist // nn Artist
      if (length(TempArtist) > 5) and Q_IsInteger(TempArtist[1]+TempArtist[2]) and ((TempArtist[3]='.') or (TempArtist[3]='-') or (TempArtist[3]=' ')) then
      begin
        TempTrack := Q_CopyRange(TempArtist, 1,2);
        Q_CutLeft(tempArtist, 3);
        CleanThisString(tempArtist);
        //TempArtist := CleanString(copy(TempArtist, 4, 1024));
        //compiler hints MightContainTrack := false
      end
    end;

    //Hvis UnderUnderbiblioteket er artisten, s er underbilbioteket Albummet
    if pref.UseSubAlbum.checked and (length(TempAlbum) = 0) and (Q_SameText(Artist, SecondSub) or Q_SameText(TempArtist, SecondSub)) and (length(SecondSub)>0) then
	    TempAlbum := FirstSub;

    //Hvis artisten er en del af FirstSub, s er resten af First Sub Album
    if pref.UseSubAlbum.checked and (length(TempAlbum) = 0) and (length(TempArtist) > 0) and Q_SameTextL(TempArtist, FirstSub, length(TempArtist)) and (length(TempArtist) < length(FirstSub)) then
    	TempAlbum := CleanString(Q_CopyFrom(FirstSub, length(TempArtist)+2));

    if pref.UseSubAlbum.checked and (length(TempAlbum) = 0) and (length(Artist) > 0) and Q_SameTextL(Artist, FirstSub, length(Artist)) and (length(Artist) < length(FirstSub)) then
    	TempAlbum := CleanString(Q_CopyFrom(FirstSub, length(Artist)+2));


    // Definerer
    if length(Artist) = 0 then
    	if length(TempArtist) > 0 then
	    	Artist := TempArtist
	    else
	    	Artist := pref.unknown.text;

    if emptyTrack(title) then
    	if length(TempTitle) > 0 then
      	Title := TempTitle
      else
      	Title := pref.unknown.text;

    if length(Album) = 0 then
    	Album := TempAlbum;  //skal vre ='' hvis den er tom, alts ikke unknown

    if (Track <= 0) and Q_IsInteger(TempTrack) then
    	Track := StrToInt(TempTrack);

    if not track in [0..255] then
    	Track := 0;       //fixer fx 666
    if inttostr(track) = Artist then
    	track := 0;    // --||--

    //if Artist = nnArtist
    if (length(Artist) > 2) then
    begin
    	s := Q_CopyRange(artist, 1, 2);
	    if Q_IsInteger(s) and CheckTrackFromOtherFiles(Filename, strtoint(s)) then
	    begin
	    	Track := strtoint(s);
	      Q_CutLeft(artist, 2);
	      CleanThisString(artist);	//Artist := CleanString(Q_CopyFrom(Artist, 3))
	    end;
    end;

    //if Title = nnTitle
   	if (length(Title) > 2) and Q_IsInteger(Title[1]+Title[2]) and CheckTrackFromOtherFiles(Filename, strtoint(Title[1]+Title[2])) then
    begin
	    Track := strtoint(Title[1]+Title[2]);
	    Title := CleanString(Q_CopyFrom(Title, 3))
    end
    else
    if (length(Title) > 2) and Q_IsInteger(Title[1]) and CheckTrackFromOtherFiles(Filename, strtoint(Title[1])) then
    begin
	    Track := strtoint(Title[1]);
	    Title := CleanString(Q_CopyFrom(Title, 2))
    end;

    //if Artist = Track + Artist
    if (length(Artist) > 3) and (Q_IsInteger(trim(Artist[1] + Artist[2]))) and (strtoint(trim(Artist[1] + Artist[2])) = track) then
    begin
    	Q_CutLeft(artist, 2);
      CleanThisString(artist);	//Artist := CleanString(copy(Artist, 3, 1024));
    end;

    //Fjerner Title = Tittel...Track n
    i := Q_PosText('track', Title);
    if i > 0 then
    begin
	    s := getIntsFrom(Title, i + 5);
	    if Q_IsInteger(s) and (length(trim(Q_CopyRange(Title, 1, i)))>0) then
      	Title := Q_CopyRange(Title, 1, i-1);
        CleanThisString(title)
	    end
      else
	    begin
		    i := Q_PosText('track', tempTitle);
		    if i > 0 then
		    begin
			    s := getIntsFrom(tempTitle, i + 5);
			    if Q_IsInteger(s) then
			    begin
				    if track <= 0 then
            	track := strtoint(s);
				    if Q_SameStrL(s, title, length(s)) and (s <> title) then
            	title := cleanString(Q_CopyFrom(title, length(s)+1))
			    end
		    end
   	 	end;

    //Fjerner timestamp fra Title [3.55]
    i := length(Title);
    if (i > 8) and (Title[i] = ']') and Q_IsInteger(Title[i-1]+Title[i-2]) and (Title[i-3] = '.') then
    begin
	    if (Title[i-6] = '[') and Q_IsInteger(Title[i-5]+Title[i-4]) then
      	title := Q_CopyRange(title, 1, i-7) //Title := copy(Title, 1, i-7)
      else //[nn:nn]
	    if (Title[i-5] = '[') and Q_IsInteger(Title[i-4]) then
      	Title := Q_CopyRange(title, 1, i-6) //copy(Title, 1, i-6)
    end;

    //if Title = Artist '-' Title, fjern Artist fra Title
    if Q_SameTextL(Artist, Title, length(Artist)) and not Q_SameText(Artist, Title) then
    begin
	    Title := cleanstring(Q_CopyFrom(Title, length(Artist)+1));
	    //check title for track igen, nu da den er ndret
	    if (length(title)>3) and Q_IsInteger(title[1]+title[2]) and (not Q_IsInteger(title[3])) and (strtoint(title[1]+title[2]) = track) then
      begin
		    Title := cleanstring(Q_CopyFrom(Title, 3));
        Q_TrimInPlace(title)
      end
    end;

    //if Album = Artist Track Albumtitle
    if (length(album) > length(artist)) and not Q_SameText(album, artist) and Q_SameText(Q_CopyRange(album,1,length(artist)+1), artist + ' ') then
    	album := cleanString(Q_CopyFrom(album, length(artist)+1));

    //if Title = Album Track Title
    if (length(title) > length(album)) and Q_SameTextL(title, album, length(album)) then
    begin
      s := trim(Q_CopyFrom(title, length(album)+1));
      if not ((length(s) >2) and (s[1] = '(') and (s[length(s)]=')')) then
        title := cleanString(s);

      if (length(Title) > 3) and Q_IsInteger(title[1] + title[2]) and (not Q_IsInteger(title[3])) and (track = 0) then
      begin
        track := strtoint(title[1]+title[2]);
        title := cleanString(Q_CopyFrom(title,3))
      end
    end;

    //if Artist = (artist)
    if (length(artist)>2) and (artist[1]='(') and (artist[length(artist)] = ')') then
    begin
    	Q_CutLeft(artist, 1);
      Q_CutRight(artist, 1);
			//artist := copy(artist,2,length(artist)-2)
    end
  end
  else
  begin
	  //Laver ekstra check p track (title = track Title)
    if (length(artist)>3) and Q_IsInteger(artist[1]+artist[2]) and (not Q_IsInteger(artist[3])) and (strtoint(artist[1]+artist[2]) = track) and not (((length(artist)>4) and Q_IsInteger(artist[4])) or (artist[3] = ',')) then
      Q_CutLeft(artist, 2);

    if (length(title)>3) and Q_IsInteger(title[1]+title[2]) and (not Q_IsInteger(title[3])) and (strtoint(title[1]+title[2]) = track) and not (((length(title)>4) and Q_IsInteger(title[4])) or (title[3] = ',')) then
      Q_CutLeft(title, 2)
	end;

  //title er cropped, og findes ogs i filnavn
  if CheckIfValueIsCroppedFromFileName and pref.correctTitle.checked and (Q_PosText(title, fName)>0) then
  begin
  	s := Q_CopyFrom(fName, Q_PosText(title, fName)+length(title));
    if (length(s)>0) and (s[1]<>'_') and (s[1]<>'(') and (s[1]<>')') and (s[1]<>'~') then
    	title := title + s
  end;

  if (length(Title)>4) and Q_SameText('.mp3', Q_CopyFrom(title, length(title)-3)) then
  	Q_CutRight(title, 4);

  CleanThisString(Artist);
  CleanThisString(Title);
  CleanThisString(Album);

  if Artist = '' then
    artist := pref.unknown.Text
end;

function SortStrings(List: TStringList; Index1, Index2: Integer): Integer;
begin
	result := Q_CompText(List.Strings[index1], List.Strings[Index2])
end;

procedure TMainForm.ScanShowScanMessage(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
var
	p: PIntAndString;
begin
	p := data;
  case p.i of
		master_MyMusic: begin
											pref.loadinglabel.caption := p.s;
											forceRepaint(pref.loadinglabel)
										end;
    master_addLoc: if assigned(dbpref) then
										begin
											dbpref.loadinglabel.caption := p.s;
											forceRepaint(dbpref.loadinglabel)
										end;
    master_dbPref: if assigned(dbpref) then
										begin
											dbpref.loadinglabel.caption := p.s;
											forceRepaint(dbpref.loadinglabel)
										end;
    master_ScanForChanges:
                    begin
                      TopImageText := p.s;
                      RepaintTopImage
                    end
	end;
  dispose(p);
end;

procedure TMainForm.Scan(master:integer; name:string; parentThread: TBMDExecuteThread; onlyNew: Boolean; calculateCRC: boolean; repairVBR: Boolean; UpdateTreeAndTabel:boolean);
{Function ValidPath(const s:string):boolean;
begin
	result := (length(s) > 2) and ((s[2] = ':') or (s[1]+s[2] = '\\'))
end;     }

Procedure UpdateScanLabel(master:integer; const s:string);
var
	p: PIntAndString;
begin
	new(p);	//disposes i ScanShowScanMessage
  p.i := master;
  p.s := s;
  {$ifndef ScanInMainThread}
  parentThread.Synchronize(ScanShowScanMessage, p)
  {$else}
  ScanShowScanMessage (nil, nil, Pointer(p))
  {$endif}
end;

Function CheckPlaylist(const fname:String):Boolean;
//      Checker om der er filer der existerer i playlisten
var     f:textfile;
        s, root:String;
begin
  result := false;
  if not fileexists(fname) then exit;
  root := getfilepath(fName);
  assignfile(f,fname);
  Filemode := 0;
  reset(f);
  while not eof(f) do
  begin
     readln(f,s);
     if (length(s)>0) and (s[1] <> '#') then
     begin
       GetAbsoluteFilename(root, s);
       if fileexists(s) then
       	result := true
     end
  end;
  closefile(f)
end;

{procedure FreeDouble(const Strings: TStrings; index: Integer);
begin
  if assigned(Strings.Objects[index]) then
  begin
    freemem(pointer(Strings.Objects[index]), SizeOf(Double));
    Strings.Objects[index] := nil
  end;
end;

Procedure StringsDelete(const Strings: TStrings;index: Integer);
begin
  FreeDouble(Strings, index);
  Strings.Delete(index)
end;

Procedure StringsClear(const Strings: TStrings);
var
  i: Integer;
begin
  for i:= Strings.Count-1 downto 0 do
    StringsDelete(Strings, i)
end;       }

procedure removeTabel(rec: Prec);
var
	aNode, bNode: PVirtualNode;
begin
  aNode := tabel.GetLast;
  while aNode <> nil do
  begin
  	if GetRec(aNode) = rec then
    begin
			bNode := tabel.GetPrevious(aNode);
      tabel.DeleteNode(aNode);
      aNode := bNode;
      break
    end
    else
    	aNode := tabel.GetPrevious(aNode)
  end
end;

procedure RemovePlaylistNodeFromTree(PR: PplRec);
var
	aNode, bNode: PVirtualNode;
  TR: PTreeRec;
begin
	aNode := tree.GetLast;
  while aNode <> nil do
  begin
		TR := tree.GetNodeData(aNode);
    if (TR.Kind = TreeKind_Playlist) and (TR.PlRecRef = PR) then
    begin
    	bNode := Tree.GetPrevious(aNode);
    	tree.DeleteNode(aNode);
      aNode := bNode
    end
    else
    	aNode := Tree.GetPrevious(aNode)
  end
end;

///////MAIN   procedure TMainForm.Scan
var //    askPlaylist : TAskUsePlaylistform;
  status : string;
  i, i2, k, x, j, n, dbindex, freq, iTemp, removedFiles:integer;
  audioType:byte;
  addQ:word;
  groups:array of byte;
  s, s2, name2,LastArtist, ScanPath:string;
  b, FilesAdded: boolean;
  Flags: TRecFlags;
  art, ArtistSortOrder, tit,alb,com,fn, root, ext:string;
  PartOfSet, rating: Byte;
  yea,track,kbps,cha, LastTrack, TotalTracks:integer;
  crc: LongWord;
  Gen : String;
  duration, filesscanned : Cardinal;
  Fsize:Cardinal;
  plsf:TQ_StringList;
  rec : Prec;
  PR : PplRec;
  filenames, ExcludedFiles : TQ_StringList;
  ExcludedFileChanged: Boolean;
  newFilename: String;
  LastWriteTime:Integer;
  fIndex, rIndex : integer;
  p: Pointer;
  ShowMessageParams: PShowMessageParameters;
  playlistFiles: PPlaylistFiles;
  cr: PCoverRec;

  supportedExtensions: TQ_StringList;
//  recsToRemove: TListSorted;

  //cover vars
  coverFilenames, existingCoverFilenames: TQ_StringList;
  lastPath, hintIndex, coverToUse, coverIndex: integer;
  ArtistListHasEmptyString, AlbumListHasEmptyString: Boolean;
  coverExists: array of boolean;

  {$ifdef ScanInMainThread}
  ptr: Pointer;
  {$endif}
begin
  playlistFiles := nil;

  Inc(SafeToAutoScanCount);
  UpdateScanLabel(master, GetText(TXT_PleaseWait));

	waitForAutoScan;

  FonlyPL := false;
  FilesAdded := false;

  i := master;
  {$ifndef ScanInMainThread}
  ParentThread.Synchronize(DoBeforeScanSynced, @i);
  {$else}
  ptr := @i;
  DoBeforeScanSynced(nil, nil, ptr);
  {$endif}

  if i = 1 then
  begin
    ParentThread.terminate;
    Dec(SafeToAutoScanCount);
    exit
  end;

  filesscanned := 0;
  removedFiles := 0;
  name2:=name;

  if onlyNew then
  	UpdateScanLabel(master, GetText(TXT_SearchForNewFiles))
  else
  	UpdateScanLabel(master, GetText(TXT_SearchForFiles));

  dbindex := LocateDBname(name);

  supportedExtensions := TQ_StringList.Create;
  supportedExtensions.CaseSensitive := false;
  supportedExtensions.Sorted := true;

  FileFind1.Files.Clear;

  filefind1.FileParams.FileMasks.Clear;
  filefind1.FileParams.FileMasks.Add('*.m3u');
  filefind1.FileParams.FileMasks.Add('*.jpg'); //cover
  filefind1.FileParams.FileMasks.Add('*.jpeg'); //cover
  filefind1.FileParams.FileMasks.Add('*.png'); //cover

  for i:=0 to length(audioTypes)-1 do
  	for x:=0 to length(audioTypes[i].ext)-1 do
    begin
    	filefind1.FileParams.FileMasks.Add('*' + audioTypes[i].ext[x]);
      s := audioTypes[i].ext[x];
      Q_TrimChar(s, '.');
      supportedExtensions.Add(s)
    end;

  filefind1.Tag := 0;

  filenames:= TQ_StringList.Create;
  coverFilenames := TQ_StringList.Create;

  if master in [master_MyMusic, master_addLoc, master_dbpref, master_ScanForChanges] then
  begin
  	for i:=0 to length(dbs[dbindex].paths)-1 do
    begin
    	if directoryexists(dbs[dbindex].paths[i]) then
      begin
        UpdateScanLabel(master, GetText(TXT_SearchingDir, [dbs[dbIndex].paths[i]]));
        FileFind1.Files.Clear; //her skal ikke bruges FileFind1Clear !!
        filefind1.RootDirectory:=dbs[dbIndex].paths[i];

        if dbs[dbindex].recursive then
        	FileFind1.DirOption := doIncludeSubDirs
        else
        	Filefind1.DirOption := doExcludeSubDirs;

        filefind1.Search;
        if filefind1.tag = -1 then
        begin
        	FileFind1.Files.Clear;
        	break
        end;
        if length(dbs[dbindex].excl) > 0 then
        begin
          for i2:=0 to filefind1.files.count -1 do
          begin
          	b := true;
            for x:=0 to length(dbs[dbindex].excl)-1 do
            	if Q_PosText(dbs[dbindex].excl[x], filefind1.files.Strings[i2]) <> 0 then
              	b := false;
              if b then
              	filenames.addObject(filefind1.files.strings[i2], fileFind1.Files.Objects[i2])
//              else
//              	FreeDouble(FileFind1.Files, i2)
          end
        end
        else
        	filenames.AddStrings(filefind1.files)
      end
    end
  end;

  Filefind1.Files.Clear; //cleaning up - her skal ikke bruges FileFind1Clear !!

  ////////////Checker ExcludeFromDB filliste
  if fileExists(settingsdir + ExcludeFromDBFilename) then
  begin
    ExcludedFileChanged := false;
    ExcludedFiles := TQ_StringList.Create;
    ExcludedFiles.LoadFromFile(settingsdir + ExcludeFromDBFilename);
    if ExcludedFiles.Count > 0 then
    begin
      ExcludedFiles.CaseSensitive := false;
      ExcludedFiles.Sorted := true;

      filenames.Sort;
      for i:=ExcludedFiles.Count-1 downto 0 do
      begin
        if filenames.Find(ExcludedFiles.Strings[i], k) then
          filenames.Delete(k)	//den er fundet i de for nyligt scannede filer - og skal fjernes.
        else
          if not FileExists(ExcludedFiles.Strings[i]) then
          begin
            ExcludedFileChanged := true;
            ExcludedFiles.Delete(i)	//den er ikke lngere p harddisken - fjern den.
          end
      end;
      if ExcludedFileChanged then
        ExcludedFiles.SaveToFile(settingsdir + ExcludeFromDBFilename)
    end;
    ExcludedFiles.Free
  end
  else
    ExcludedFiles := nil;
  ////////////e.o. Checker ExcludeFromDB filliste

  {$ifndef ScanInMainthread}
  if not parentThread.Terminated then
  {$endif}
  begin
    if filenames.count = 0 then
    begin
      UpdateScanLabel(master, GetText(TXT_NoFilesFoundCancelling));
      screen.Cursor:=crdefault;
      filenames.free;
      Dec(SafeToAutoScanCount);
      exit
    end;

    tree.BeginUpdate;
    for i:=m3ulist.count-1 downto 0 do
    begin
    	PR := m3uList.Items[i];
      b := false;
      for x:=0 to length(dbs[dbindex].paths)-1 do
      	b := b or Q_SameTextL(PR.filename, dbs[dbindex].paths[x], length(dbs[dbindex].paths[x]));

      if (PR.location = dbindex) and (not onlyNew or not b or (not getFileAccess(PR.filename,true, false))) then
      begin
        if assigned(PR.cacheRef) then
          setLength(PPLcacheRec(PR.cacheRef).cache, 0);
        RemovePlaylistNodeFromTree(PR);
        dispose(PR);
        m3uList.delete(i)
      end
    end;
    Tree.EndUpdate;

    //Finder alle playlistene og images og lgger dem i en anden liste
    for i:=filenames.count-1 downto 0 do
    begin
			ext := getFileExt(filenames.Strings[i]);
      if Q_SameText(ext, '.m3u') then
      begin
        if CheckPlaylist(filenames.strings[i]) and not Q_SameTextL(filenames.strings[i], settingsdir + '-quicklist', length(settingsdir + '-quicklist')) and not assigned(GetPlayListRec(filenames.Strings[i])) then
        begin
          new(PR);
          fillChar(PR^, sizeOf(PR^), #0);
          PR.Name := Q_CopyLeft(getFilename(filenames.strings[i]),length(getFilename(filenames.strings[i]))-4);
          PR.Filename := filenames.Strings[i];

          PR.UseToSuggest := useToSuggest_Undefined;
          PR.location := dbindex;
          PR.CacheRef := nil;
          m3uList.Add(PR)
        end;
        filenames.Delete(i);
    	end      	//if Q_SameText(m3u
      else
      if Q_SameText(ext, '.jpg') or Q_SameText(ext, '.jpeg') or Q_SameText(ext, '.png') then
      begin
				coverFilenames.Add(filenames.Strings[i]);
        filenames.Delete(i)
      end;

      {$ifndef ScanInMainthread}
      if parentThread.Terminated then
      	break
      {$endif}
    end;	//for
  //Finder alle playlistene og lgger dem i en anden liste  --- SLUT

  {$ifndef ScanInMainthread}
  if not parentThread.Terminated then
  {$endif}
  begin
  	//Sprger om playlisterne m bruges

    {$ifndef ScanInMainthread}
    ParentThread.Synchronize(ScanThreadShowUsePlaylistDialog, nil);
    {$else}
    ptr := nil;
    ScanThreadShowUsePlaylistDialog(nil, nil, ptr);
    {$endif}

    //Fylder filer over fra playlisterne over i filenames
    if pref.scanplay.checked {$ifndef ScanInMainthread} and not parentThread.Terminated {$endif} then
    begin
      filenames.Sorted := true;
      filenames.Duplicates := dupignore;

      //PlaylistFiles
      new(playlistFiles);
      SetLength(playlistFiles.Playlists, 0);
      j := -1;

      plsf := TQ_StringList.create;
      for i:=0 to m3uList.count-1 do
      	if (PplRec(m3uList.items[i]).location = dbindex) and (PplRec(m3uList.items[i]).UseToSuggest = useToSuggest_use) and {((master <> master_StartUpScan) or ((master = master_StartUpScan) and AutoScanFiles.Find(PplRec(m3uList.Items[i]).filename, x))) and} getFileAccess(PplRec(m3uList.Items[i]).filename, true, false) then
        begin
        	//PlaylistFiles
          inc(j);
          SetLength(playlistFiles.Playlists, j+1);
          playlistFiles.playlists[j].filename := PplRec(m3uList.Items[i]).filename;
					playlistFiles.playlists[j].files := TQ_Stringlist.Create;
          playlistFiles.playlists[j].files.Sorted := true;
          n := 1;
          //e.o. PlaylistFiles

          root := GetFilePath(PplRec(m3uList.Items[i]).filename);
          plsf.LoadFromFile(PplRec(m3uList.Items[i]).filename);
          for x:=0 to plsf.count-1 do if (length(plsf.strings[x])>0) and (plsf.strings[x][1] <> '#') then
          begin
          	s := plsf.strings[x];
            GetAbsoluteFilename(root, s);
            playlistFiles.playlists[j].files.AddObject(s, TObject(n));
            inc(n);
	          if (supportedExtensions.IndexOf(ExtractFileExt(s)) >= 0) and fileexists(s) then
	          	filenames.add(s)
          end;

          plsf.clear
        end;
        plsf.free
    end;
    //Fylder filer over fra playlisterne over i filenames --- SLUT

    if onlynew then
       UpdateScanLabel(master, GetText(TXT_FoundFilesUpdatingList, [inttostr(filenames.count)]))
    else
    	UpdateScanLabel(master, GetText(TXT_OptimizingDatabase));

    if master <> master_ScanForChanges then
    begin
      CleanDoubles;  //fjerner dupes
    	tabel.RootNodeCount := 0
    end;

    //fjerner de filer der allerede er i databasen
    if reclist.count > 0 then
    begin
    	filenames.sort;
      BeginUseReclist;

      if onlynew then
      begin
        for i:=reclist.Count-1 downto 0 do
        begin
          {$ifndef ScanInMainthread}
        	if parentThread.Terminated then
        		break;
          {$endif}

          rec := Reclist.List^[i];
          if rec.Location = dbindex then
          begin
          	s := getFtextP(rec, fFilename);
            if filenames.find(s, x) then
            begin  //Den er allerede i databasen. Check om fildatoen har ndret sig.
            	if assigned(filenames.Objects[x]) then
              begin
                b := rec.LastWriteTime = Integer(Filenames.Objects[x])
              end
              else
              	b := rec.LastWriteTime = FileAge(filenames.strings[x]);

              if b then
              	filenames.Delete(x) //Den er allerede i databasen, og filen er ikke blevet ndret siden sidste aflsning
              else
              begin   // Filen har ndret sig. Slet den gamle index i databasen
              	Include(rec.Flags, rfDeletePending);
	              inc(removedFiles);
	              FilesAdded := true
              end
            end
            else   //Ikke fundet i de nyeste fundne filer, den er alts blevet slettet
            if dbs[dbIndex].exists then
            begin
              //if not fileexists(s) then, skal ikke vre med
              //Den kan dog vre blevet scannet af autoscan, og s skal den ikke slettes!
              b := false;
              for x:=0 to pref.AutoScanPaths.Items.Count-1 do
              begin
    	          if Q_SameTextL(s, pref.AutoScanPaths.Items[x], length(pref.AutoScanPaths.Items[x])) then
  	  	          if fileexists(s) then
        		      begin
            		    b := true;
                		break
              		end
              end;
              if not b then
              begin
              	//Filen existerer ikke, fjern den fra databasen
                Include(rec.Flags, rfDeletePending);
                inc(removedFiles);
                FilesAdded := true
              end   // checker om filen stadig er p harddisken (ellers slet fra DB)
            end
          end
				end
      end
      else  //Not Onlynew, sletter alle recsene s alt scannes forfra
      begin
      	for i:=0 to reclist.Count-1 do
      	begin
        	rec := reclist.List^[i];
          if rec.Location = dbindex then
          begin
            Include(rec.Flags, rfDeletePending);
            FilesAdded := true
          end;
          {$ifndef ScanInMainthread}
        	if parentThread.Terminated then
        		break
          {$endif}
        end;
    	end;

      //Release the recs marked with RF_ReleasePending
      if master = master_ScanForChanges then
      begin
     		EndUseReclist;
        {$ifndef ScanInMainthread}
        parentThread.Synchronize(RemoveFromTabel, nil);
        {$else}
        ptr := nil;
        RemoveFromTabel(nil, nil, ptr);
        {$endif}

     	end
      else
      begin
      	//This code should also be in "removeFromTabel" method:
	      ReleaseRecs(false, true);
        reclist.pack;
		    reclist.Capacity := reclist.count;
        EndUseReclist
      end;

    end; //of if reclist.count > 0 then

    case master of
    	master_MyMusic:	pref.pbar.max := filenames.count;
			master_addLoc, master_dbPref: if assigned(dbPref) then dbpref.pbar.max := filenames.count;
    end;

    if (master <> master_ScanForChanges) and (not onlyNew or (removedFiles + filenames.count > 80)) then
    	CleanLists; //<-rydder op i albumList, artistList, FtreeList

    status := '';

    for i:=0 to filenames.count -1 do     //SCANNER SKIDTET!
    begin
    	{$ifndef ScanInMainthread}
      if parentThread.Terminated then
        break;
      {$endif}

    	if not FilenameIncomplete(filenames.strings[i]) then
      begin
      	case master of
        	master_MyMusic, master_ScanForChanges:
          	UpdateScanLabel(master, GetText(TXT_FileOfFname, [inttostr(i+1), inttostr(filenames.count), filenames.strings[i]]));
          master_dbPref, master_addLoc:
          	UpdateScanLabel(master, filenames.strings[i]) //den duer ikke
        end;//of Case

        //Find ScanPath
        for x:=0 to length(dbs[dbindex].paths)-1 do
        	if (length(filenames.strings[i]) > length(dbs[dbindex].paths[x])) and (Q_CompTextL(filenames.strings[i], dbs[dbindex].paths[x], length(dbs[dbindex].paths[x])) = 0) then
          begin
          	ScanPath := dbs[dbindex].paths[x];
            break
          end;

        new(rec);
        fillChar(rec^, sizeOf(rec^), #0);
        SetLength(rec.Groups,0);
        SetLength(rec.Genre,0);
        rec.location:=dbindex;
        PartOfSet := 0;
        Flags := [];
        if not readid3(ParentThread, repairVBR, ScanPath, filenames.strings[i],master, audioType, addQ, art, ArtistSortOrder, tit, alb,com, PartOfSet, rating, yea, track, TotalTracks, kbps, cha, duration, Flags, Fsize, CRC, freq, {createTime,} LastWriteTime, calculateCRC, cr, rec, true, filenames, playlistFiles) then
        begin
        	status := status + #13 + GetText(TXT_ErrorReading, [filenames.strings[i]]);
          DisposeRec(rec);
          Continue
        end;
        try
        	BeginSetArtistAlbumFilename;
          try
          	BeginUseReclist;
            try
     					fn:=filenames.strings[i];
              rec.location:=dbindex;
              rec.AudioType := audioType;
              rec.addQuality := addQ;
              setFilename(rec, fn, master <> master_DirSpy);
              setArtist(rec, art, ArtistSortOrder);
              SetPCharString(rec.Title, tit);
//              rec.Title:= tit;
              rec.Album:= GetAlbumID(alb);
              rec.Rating := rating;
              rec.PartOfSet := PartOfSet;
              if (yea>=-1) and (yea<32767) then
              	rec.Year:= yea
              else
              	rec.Year := -1;
              rec.Comment:= com;

              if (track>=0) and (track<=high(Word)) then
              	rec.Track:= track
              else
              	rec.Track := 0;

              if (TotalTracks>=0) and (TotalTracks<=high(word)) then
              	rec.TotalTracks:= TotalTracks
              else
              	rec.TotalTracks := 0;

              if (kbps > -32767) and (kbps < 32767) then
              	rec.Kbps:= kbps
              else
              	rec.kbps := 0;

              rec.Length := duration; //ingen sammenligning ndvendig
              if cha in [0 .. 4] then
              	rec.Channels := Cha
              else
              	rec.Channels := 4;//unknown

              rec.LastWriteTime := LastWriteTime;
              rec.DatabaseTime := DateTimeToFileDate(Now);
              rec.PlayCount := 0;
              rec.Flags := Flags;

							if (crc > low(LongWord)) and (crc < high(LongWord)) then
              	rec.CRC := crc
              else
              	rec.CRC := 0;

              rec.FSize := Fsize;

              if (freq>=0) and (freq<=high(word)) then
              	rec.khz := freq
              else
              	rec.Khz := 0;

              Exclude(rec.Flags, rfPlaying);

              {if (master in [master_startupScan, master_MyMusic]) and (pref.AutoScanMoveToPath.text <> '') and AutoScanFiles.Find(fn, x) then
                  begin //renamer
                       newFilename := FilenameFromPattern(rec, pref.AutoScanMoveToPath.text, '');
                       if not fileexists(newFilename) and forcedirectories(getFilePath(newFilename)) and moveFile(pchar(fn), pchar(newFilename)) then
                          setFilename(rec, newFilename)
                  end;  }
              	reclist.add(rec);

                AddCoverRecToList(cr, rec)
              finally
              	EndUseReclist
              end;
              inc(filesscanned);
              FilesAdded := true
              //CreateNodeFromRec
            finally
            	EndSetArtistAlbumFilename
            end
            except
            	status := status + #13#13 + GetText(TXT_ErrorAssigningVal, [fn]);
              dispose(rec)
            end
          end;
          case master of
          	master_MyMusic:	pref.pbar.position := i+1;
						master_addLoc, master_dbPref: if assigned(dbPref) then dbpref.pbar.position := i+1
    			end
    		end
    end; // of filefind.cancelled
    filesAdded := FilesAdded or (tabel.rootNodeCount <> reclist.count);
    if filesAdded and UpdateTreeAndTabel then
    	reclisttotabel(true, true)
	end; //if not parentThread.Terminated

  BeginUseReclist;
  //COVERS	-----------------------------------------------
  fCoverImgsRw.BeginWrite;
  fCoverRecRw.BeginWrite;
  try
    //Remove the covers that doesn't exist anymore from the list AND Fill all the existing cover filenames to a sorted list
    coverFilenames.CaseSensitive := false;
    coverFilenames.Sort;
    existingCoverFilenames := TQ_StringList.Create;
    for i:=0 to fCoverImgs.Count-1 do
    begin
      cr := fCoverImgs.List^[i];
      if (cr.SourceRec.Location = dbindex) and (cr.SourceType = coverSource_imageFile) then
      begin
        //Is the cover image among the newly scanned files?
        s := GetFTextP(cr.SourceRec, FFilePath) + cr.ImageFilename;
        if coverFilenames.Find(s, j) then
          existingCoverFilenames.Add(s)
        else
        begin
          //The cover does not exists anymore - remove it
          Include(cr.Flags, crfDeletePending)
        end
      end
    end;
    ReleaseAndDisposeCoverRecs(true, true);

    //Find all path indexes of the new cover-image-files and put it in the "object" as an integer
    existingCoverFilenames.CaseSensitive := false;
    existingCoverFilenames.Sort;
    for i:=coverFilenames.Count-1 downto 0 do
    begin
      if fpathList.Find(getFilePath(coverFilenames.Strings[i]), j) then
        //the file is not in the existing list AND the path is found
        coverFilenames.Objects[i] := pointer(j)
      else
        coverFilenames.delete(i);
    end;

    ArtistListHasEmptyString := (ArtistList.Count > 0) and (Length(ArtistList.Strings[0]) = 0);
    AlbumListHasEmptyString := (AlbumList.Count > 0) and (Length(AlbumList.Strings[0]) = 0);

    lastPath := -1;
    coverIndex := -1;
    coverToUse := -1;

    for i:=0 to coverFilenames.Count do
    begin
      //Finish previous
      if (i = coverFilenames.Count) or ((i > 0) and (lastPath <> integer(coverFilenames.Objects[i]))) then
      begin
        if (coverToUse >= 0) then
        begin
          //Find rec to get file-path
          for j:=0 to recList.Count-1 do
          begin
            rec := recList.List^[j];
            if (rec.Location = dbindex) and (rec.Fpath = integer(coverFilenames.Objects[coverToUse])) and (not ArtistListHasEmptyString or (rec.Artist > 0)) and (not AlbumListHasEmptyString or (rec.Album > 0)) then
            begin
              //Check if there already is a coverRec in the cover list
              if not existingCoverFilenames.Find(coverFilenames.Strings[coverToUse], x) then
              begin
                new(cr);
                FillChar(cr^, SizeOf(cr^), 0);
                cr.SourceType := coverSource_imageFile;
                cr.SourceRec := rec;
                cr.ImageFilename := getFileName(coverFilenames.Strings[CoverToUse]);
                cr.State := notLoaded;
                fCoverImgs.Add(cr);

                break	//for reclist
              end
            end
          end
        end;
        //Reset data
        coverIndex := -1;
        coverToUse := -1;
      end;	//of Finish previous

      if i < coverFilenames.count then
      begin
        s := TheFix(GetFilename(coverFilenames.Strings[i], false));
        Q_ReplaceChar(s, '-', ' ');

        x := -1;	//new coverIndex
        for j:=0 to Length(coverHints)-1 do
        begin
          if (length(coverHints[j]) = 0) or (Q_PosText(coverHints[j], s) > 0) then
            x := j;
        end;

        if x > coverIndex then
        begin
          coverIndex := x;
          coverToUse := i
        end
      end;

      if i < coverFilenames.Count then lastPath := integer(coverFilenames.Objects[i])
    end;
  finally
  	SortCoverImgs;
	  fCoverImgsRw.EndWrite;
	  fCoverRecRw.EndWrite;
    UpdateHashedReclist;
    EndUseReclist
  end;

  supportedExtensions.Free;
  filenames.Clear;
	filenames.free;
  existingCoverFilenames.Free;
  coverFilenames.Free;
//  coverHints.Free;

  //playlistFiles
  if assigned(playlistFiles) then
  begin
  	for i:= 0 to length(playlistFiles.playlists)-1 do
    	playlistFiles.playlists[i].files.Free;
    SetLength(playlistFiles.Playlists, 0);
    dispose(playlistFiles)
  end;

  if filesAdded then
  	SaveAllNoRelease(true);

	b := FilesAdded and UpdateTreeAndTabel;

	UpdateScanLabel(master, GetText(TXT_Done));

  {$ifndef ScanInMainThread}
  ParentThread.Synchronize(DoAfterScanSynced, pointer(b));
  {$else}
  ptr := pointer(b);
  DoAfterScanSynced(nil, nil, ptr);
  {$endif}

	if length(status)>0 then
	begin
		new(ShowMessageParams);
		ShowMessageParams.text := status;
		ShowMessageParams.alignment := taLeftJustify;
		parentThread.Synchronize(ThreadShowMessage, ShowMessageParams);
		dispose(ShowMessageParams)
	end;
  Dec(SafeToAutoScanCount);
end;

function CompareCoverRec(Item1, Item2: Pointer): Integer;
function GetCoverHintIndex(cr: PCoverRec): Integer;
var
	i: integer;
begin
	result := 0;
  for i:=length(coverHints)-1 downto 0 do
  	if Q_PosText(coverHints[i], cr.ImageFilename) > 0 then
    begin
    	result := i+1;	//result should not be 0 based, but 1 based
      break
    end
end;
var
	cr1, cr2: PCoverRec;
begin
	cr1 := Item1;
  cr2 := Item2;
  if (cr1.SourceType = cr2.SourceType) and (cr1.SourceType = coverSource_imageFile) then
  begin
  	result := GetCoverHintIndex(cr2) - GetCoverHintIndex(cr1)	//sort descending
  end
  else
  	result := 0
end;

procedure TMainForm.SortCoverImgs;
begin
	fCoverImgs.Sort(CompareCoverRec)
end;

procedure TMainForm.RemoveRecsFromDB(list: TList);
var
  i, yPos: Integer;
  StoreInFile: Boolean;
  StrLst: TQ_StringList;
begin
  if list.Count = 0 then
  	exit;

  i := YesNoBox3Btn(GetText(TXT_RemoveFromDB), GetText(TXT_RemoveFromDBText), GetText(TXT_Yes), GetText(TXT_No), GetText(TXT_Cancel), 1);
  if i = 3 then	//cancel
  	exit;

  StoreInFile := i=1;
  if StoreInFile then
  begin
  	StrLst := TQ_StringList.Create;
    if fileExists(settingsdir + ExcludeFromDBFilename) then
    	StrLst.LoadFromFile(settingsdir + ExcludeFromDBFilename);
    StrLst.CaseSensitive := false;
    StrLst.Sorted := true;
    StrLst.Duplicates := dupIgnore
  end;

  yPos := tabel.OffsetY;

  screen.Cursor := crhourglass;

  tabel.beginupdate;
  for i:=0 to list.Count-1 do
  begin
  	if StoreInFile then
    	StrLst.Add(GetFTextP(list.List^[i], FFilename));

    Include(PRec(list.List^[i]).Flags, rfDeletePending);
  end;

  ReleaseRecs(false, true);

  reclisttotabel(false, true);
  ShowHideNodes;
  tabel.OffsetY := yPos;

  tabel.endupdate;

  if StoreInFile then
  begin
  	StrLst.SaveToFile(settingsdir + ExcludeFromDBFilename);
    StrLst.Free
  end;

  if pref.AutoResizeColumnHeaders.Checked then
  	AutoResizeAllColumnsToFit;

  UpdateTree(true);
  SaveAllNoRelease(true);

  screen.cursor := crdefault
end;

procedure TMainForm.Filenames1Click(Sender: TObject);
begin
        (sender as Tmenuitem).Checked := not (sender as Tmenuitem).checked
end;

Procedure TMainForm.createcolumns;
Begin
        colrez := true;
        coltabelcount := tabel.header.columns.count-1;
        colrez := false
End;

function TMainForm.GetYearAlbum(const rec: Prec): String;
begin
	if (rec.year <= 0) or (rfCompilation in rec.Flags) then
		result := GetFTextP(rec, FAlbum)
	else result := '[' + GetFTextP(rec, FYear) + '] ' +  GetFTextP(rec, FAlbum)
end;

{function CompareUpdateTreeArtistAlbum1(Item1, Item2: Pointer): integer;
begin
	if pref.ShowCompilations.Checked then
  begin
  	if (not GetFlag(Item1, RF_compilation)) and (not GetFlag(Item2, RF_compilation)) then
		begin
			result := Prec(Item1).artistWOT - Prec(Item2).artistWOT;
			if result = 0 then
			begin
				if MainFormInstance.ShowAlbumYearMenuItem.Checked then
					result := Q_CompText(MainFormInstance.GetYearAlbum(Item1), MainFormInstance.GetYearAlbum(Item2))
				else
					result := Prec(Item1).album - Prec(Item2).album
     	end
    end else
		if GetFlag(Item1, RF_compilation) and GetFlag(Item2, RF_compilation) then
		begin
			if MainFormInstance.ShowAlbumYearMenuItem.Checked then
				result := Q_CompText(MainFormInstance.GetYearAlbum(Item1), MainFormInstance.GetYearAlbum(Item2))
			else
				result := Prec(Item1).album - Prec(Item2).album
    end
		else
			if GetFlag(Item1, RF_compilation) and not GetFlag(Item2, RF_compilation) then
				result := -1
			else
				result := 1
  end
  else
  begin
			result := Prec(Item1).artistWOT - Prec(Item2).artistWOT;
			if result = 0 then
			begin
				if MainFormInstance.ShowAlbumYearMenuItem.Checked then
					result := Q_CompText(MainFormInstance.GetYearAlbum(Item1), MainFormInstance.GetYearAlbum(Item2))
				else
					result := Prec(Item1).album - Prec(Item2).album
     	end
    end
{		 if not pref.ShowCompilations.Checked or ((not GetFlag(Item1, RF_compilation)) and (not GetFlag(Item2, RF_compilation))) then
		 begin
			result := Prec(Item1).artistWOT - Prec(Item2).artistWOT;
			if result = 0 then
			begin
				if MainFormInstance.ShowAlbumYearMenuItem.Checked then
					result := Q_CompText(MainFormInstance.GetYearAlbum(Item1), MainFormInstance.GetYearAlbum(Item2))
				else
					result := Prec(Item1).album - Prec(Item2).album
			end
		 end else
		 if GetFlag(Item1, RF_compilation) and GetFlag(Item2, RF_compilation) then
		 begin
			if MainFormInstance.ShowAlbumYearMenuItem.Checked then
				result := Q_CompText(MainFormInstance.GetYearAlbum(Item1), MainFormInstance.GetYearAlbum(Item2))
			else
				result := Prec(Item1).album - Prec(Item2).album
		 end
		 else
			if GetFlag(Item1, RF_compilation) and not GetFlag(Item2, RF_compilation) then
				result := -1
			else
				result := 1
end;                       }

function TMainForm.getFileName(const S:string; includeExt:boolean):String;
begin
	result := Q_CopyFrom(s, Q_StrRScan(s, '\')+1);
	if not includeExt and (Q_StrRscan(result, '.') > 0) then
		result := Q_CopyLeft(result, Q_StrRscan(result, '.')-1)
end;

function TMainForm.getFilePath(const S:string):String;  //overload;
begin
	result := Q_CopyLeft(s, Q_StrRScan(s, '\'))
end;

function TMainForm.getFilePath(const p:pointer):String; //overload;
begin
	result := getFtextP(p, FFILEPATH)
end;

function TMainForm.getFileExt(const s:string):String;
begin
		 result := Q_CopyFrom(s, Q_StrRScan(s, '.'))
end;

function CompareUpdateTreeDrive(Item1, Item2: Pointer): integer;
begin
	result := Prec(Item1).fPath - Prec(Item2).Fpath
end;

function CompareYear(Item1, Item2: Pointer): integer;
begin
	result := Prec(Item1).Year - Prec(Item2).Year
end;

function CompareRating(Item1, Item2: Pointer): integer;
begin
	result := integer(Prec(Item1).Rating) - integer(Prec(Item2).Rating)
end;

{
function CompareUpdateTreeDir(Item1, Item2: Pointer): integer;
var
	s1, s2: String;
begin
	s1 := FPathList.Strings[Prec(Item1).fPath];
  s2 := FPathList.Strings[Prec(Item2).fPath];
	result := Q_CompText(Q_CopyFrom(s1, Q_StrScan(s1, '\', 3)+1), Q_CopyFrom(s2, Q_StrScan(s2, '\', 3)+1))
end;   }

function CompareUpdateTreeDir(Item1, Item2: Pointer): integer;
var
	i1, i2: Integer;
begin
	if Prec(Item1).fPath = Prec(Item2).fPath then
  	result := 0
  else
  begin
    i1 := Q_StrScan(FPathList.Strings[Prec(Item1).fPath], '\', 3);
    i2 := Q_StrScan(FPathList.Strings[Prec(Item2).fPath], '\', 3);
    if (i1 = i2) and Q_SameTextL(FPathList.Strings[Prec(Item1).fPath], FPathList.Strings[Prec(Item2).fPath], i1-1) then
    	result := Prec(Item1).fPath - Prec(Item2).Fpath
    else
    	result := Q_CompText(Q_CopyFrom(FPathList.Strings[Prec(Item1).fPath], i1+1), Q_CopyFrom(FPathList.Strings[Prec(Item2).fPath], i2+1))
    end
end;

{function CompareUpdateTreeAlbum(Item1, Item2: Pointer): integer;
begin
	if MainFormInstance.ShowAlbumYearMenuItem.Checked then
		result := Q_CompText(MainFormInstance.GetYearAlbum(Item1), MainFormInstance.GetYearAlbum(Item2))
	else
		result := Prec(Item1).album - Prec(Item2).album
end;      }

function CompareUpdateTreeArtistAlbum2(Item1, Item2: Pointer): integer;
begin
	result := Prec(Item1).ArtistSortOrder - Prec(Item2).ArtistSortOrder;
	if result = 0 then
		result := Prec(Item1).album - Prec(Item2).album
end;

procedure TMainForm.UpdateTreeGroups;
var
	aNode, pNode: PVirtualNode;
	expanded: Boolean;
	TR: PTreeRec;
	GR: PGroupRec;
	i: Integer;
begin
	expanded := false;
	tree.OnChecked := nil;

	tree.BeginUpdate;
	//fjerner den gamle
	aNode := tree.GetFirst;
	while aNode <> nil do
	begin
		TR := Tree.GetNodeData(aNode);
		if TR.Kind = TreeKind_GroupParent then
		begin
			expanded := Tree.Expanded[aNode];
			Tree.DeleteNode(aNode);
			break
		end;
		aNode := tree.GetNext(aNode)
	end;

	if pref.ShowGroupsInTree.Checked and (groupList.Count > 0) then
	begin
		pNode := tree.InsertNode(nil, amAddChildFirst);
		TR := tree.GetNodeData(pNode);
		FillChar(TR^, SizeOf(TR^), #0);

		TR.Kind := TreeKind_GroupParent;
    TR.SortField := -1;

		for i:=0 to groupList.Count-1 do
		begin
			GR := groupList.items[i];
			aNode := tree.AddChild(pNode);
			tree.CheckType[aNode] := ctTriStateCheckBox;
			TR := tree.GetNodedata(aNode);
			FillChar(TR^, SizeOf(TR^), #0);
			TR.Kind := TreeKind_Group;
			TR.PlRecRef := GR;
      TR.SortField := -1;
      TR.Tag := i;

      //tree.CheckState[aNode]
      case GR.Checkstate of
        GroupCheckState_Unchecked:
          aNode.CheckState := csUnCheckedNormal;

        GroupCheckState_Checked:
  				aNode.CheckState := csCheckedNormal;

        GroupCheckState_Exclude:
          aNode.CheckState := csMixedNormal;
      end;
		end;

		if pref.ShowGroupSettingsInTree.Checked then
		begin
			//Laver GroupSettings ting
			aNode := tree.AddChild(pNode);
			tree.CheckType[aNode] := ctCheckbox;
			TR := tree.GetNodedata(aNode);
			FillChar(TR^, SizeOf(TR^), #0);
			TR.Kind := TreeKind_GroupSetting;
			TR.Tag := 1;
      TR.SortField := -1;
			if FInvertGroupsChecked then
				tree.CheckState[aNode] := csCheckedNormal
			else
				tree.CheckState[aNode] := csUnCheckedNormal;

			aNode := tree.AddChild(pNode);
			tree.CheckType[aNode] := ctCheckbox;
			TR := tree.GetNodedata(aNode);
			FillChar(TR^, SizeOf(TR^), #0);
			TR.Kind := TreeKind_GroupSetting;
			TR.Tag := 2;
      TR.SortField := -1;
			if fAndGroups then
				tree.CheckState[aNode] := csCheckedNormal
			else
				tree.CheckState[aNode] := csUnCheckedNormal
		end;
		
		tree.Expanded[pNode] := Expanded
	end;
	tree.EndUpdate;
	tree.OnChecked := TreeChecked
end;

procedure TMainForm.SaveTree(tree: TVirtualStringTree; Stream: TStream);
procedure SaveNodeLevel(topNode: PVirtualNode; sortedCoverImgs: TList);
var
  flag: Byte;
  nodeHeight: Cardinal;
begin
	while topNode <> nil do
  begin
    flag := 0;
    if tree.Selected[topNode] then
      flag := flag or $1;
    if tree.IsVisible[topNode] then
      flag := flag or $2;
    if tree.Expanded[topNode] then
      flag := flag or $4;
    if Assigned(topNode.FirstChild) then
      flag := flag or $8;
    if Assigned(topNode.NextSibling) then
    	flag := flag or $10;

    Stream.Write(flag, SizeOf(flag));

    nodeHeight := tree.NodeHeight[topNode];
    if nodeHeight > high(word) then
      nodeHeight := 0;
    Stream.Write(nodeHeight, 2);

    treeSaveNode(topNode, Stream, sortedCoverImgs);

    if Assigned(topNode.FirstChild) then
      SaveNodeLevel(topNode.FirstChild, sortedCoverImgs);

    topNode := topNode.NextSibling
  end
end;
var
	Count: Cardinal;
  sortedCoverImgs: TList;
  pi: PPointerAndInt;
  i: integer;
begin
	sortedCoverImgs := TList.Create;
  sortedCoverImgs.Capacity := fCoverImgs.Count;
  for i:=0 to fCoverImgs.Count-1 do
  begin
  	new(pi);
    pi.p := fCoverImgs.List^[i];
    pi.i := i;
    sortedCoverImgs.Add(pi)
  end;
  sortedCoverImgs.Sort(SortPointerIntByPointer);

	Count := tree.TotalCount;
  Stream.Write(Count, SizeOf(tree.TotalCount));

  if tree.GetFirst <> nil then
 		SaveNodeLevel(tree.GetFirst, sortedCoverImgs);

  for i:=0 to sortedCoverImgs.Count-1 do
  begin
  	pi := sortedCoverImgs.List^[i];
		Dispose(pi)
  end;
  sortedCoverImgs.Free;
end;

procedure TMainForm.LoadTree(tree: TVirtualStringTree; Stream: TStream);
procedure LoadNodeLevel(parentNode: PVirtualNode);
var
	aNode: PVirtualNode;
  flag: Byte;
  nodeHeight: Word;
begin
	repeat
	  Stream.Read(flag, SizeOf(flag));
	  Stream.Read(nodeHeight, 2);

	  aNode := tree.AddChild(parentNode);
	  Include(aNode.States, vsHeightMeasured);

	  tree.NodeHeight[aNode] := nodeHeight;
	  tree.IsVisible[aNode] := flag and $2 = $2;
	  tree.Selected[aNode] := flag and $1 = $1;

	  if assigned(tree.OnLoadNode) then
	    tree.OnLoadNode(tree, aNode, Stream);

    if flag and $8 = $8 then
    	LoadNodeLevel(aNode);

    tree.Expanded[aNode] := flag and $4 = $4;

  until flag and $10 <> $10
end;

var
	count: cardinal;
begin
 	tree.BeginUpdate;
 	tree.Clear;
 	try
    Stream.Read(Count, SizeOf(Count));
    if Count > 0 then
	    LoadNodeLevel(tree.RootNode);

    if count <> tree.TotalCount then
    	 UpdateTree(false)
  finally
  	tree.TreeStates := tree.TreeStates - [tsChangePending];
	  tree.EndUpdate
  end
end;

Procedure TMainForm.UpdateTree(skipCheckDrives: boolean);
Function GetDefaultData(TreeStructure: PTreeStructureNode): Integer;
begin
  if TreeStructure.Content = tscCustomField then
  	result := TreeStructure.CustomFieldIndex
  else
  	result := -1
end;

Function FillTree(list: TSortPartList; TreeStructure: PTreeStructureNode; Location: Integer; ParentNode: PVirtualNode; FirstIndex, LastIndex: Integer; ArtistListHasEmptyString, AlbumListHasEmptyString: Boolean; ParentContents: TTreeStructureContents; SendData: Integer; pCoverArr: pointer): Boolean;

Function GetCustomFieldData(rec: PRec): Pointer;
var
	i: Integer;
begin
	result := nil;
	for i:=0 to length(rec.CustomFields)-1 do
  	if rec.CustomFields[i].FieldIndex = SendData then
    begin
   		result := rec.CustomFields[i].data;
      break
    end
end;

procedure MoveToNextGenre(var Data, Start: Integer; const ListArr: Array of TSortPartList);
begin
	repeat
  	Inc(Data)
  until (Data >= GenreList.Count) or (ListArr[Data].Count > 0);

  if Data < GenreList.Count then
  begin
  	List := ListArr[Data];
    LastIndex := List.Count-1;
    Start := 0
  end
  else
  begin
    //Make it stop the while-loop:
  	Start := 0;
    LastIndex := -1
  end
end;

Function GetDirectoryAtLevel(p:pointer; level:integer; toTheRoot:boolean = false):string;
var
	i, x, k:integer;
begin
  if level < 0 then result := '' else
  begin
  	result := getFtextP(p, FFILEPATH);
  	if toTheRoot then
  	begin
  		x:=1;
  		for i:=0 to level do
  			x := Q_StrScan(result, '\', x)+1;
  		result := Q_CopyLeft(result, x-2)
  	end
  	else
  	begin
    	if level = 0 then
      	result := Q_CopyLeft(result, Q_StrScan(result, '\', 3)-1)
      else
      begin
	    	k := 3;
	  		for i:=0 to level-1 do
	      	k := Q_StrScan(result, '\', k)+1;

        result := Q_CopyRange(result, k, Q_StrScan(result, '\', k)-1)
      end
  	end
  end
end;

Procedure FindStart(var Start: Integer; LastIndex, Data: Integer);
var
	StartFound: Boolean;
begin
	StartFound := false;
	while (Start <= LastIndex) and not StartFound do
  begin
  	case TreeStructure.Content of
    	tscArtistsSortOrder: StartFound := not ArtistListHasEmptyString or (Prec(List.List^[Start]).ArtistSortOrder > 0);
      tscArtists: StartFound := not ArtistListHasEmptyString or (Prec(List.List^[Start]).Artist > 0);
      tscAlbums, tscYear_Albums: StartFound := not AlbumListHasEmptyString or (Prec(List.List^[Start]).Album > 0);
      tscSets: StartFound := not AlbumListHasEmptyString or (self.GetPartOfSet(List.List^[Start]) > 0);
      tscCompilationContainer: StartFound := rfCompilation in PRec(List.List^[Start]).Flags;
      tscCompilations: StartFound := (not AlbumListHasEmptyString or (Prec(List.List^[Start]).Album > 0)) and (rfCompilation in PRec(List.List^[Start]).Flags);
      tscArtist_albums: StartFound := (not ArtistListHasEmptyString or (Prec(List.List^[Start]).ArtistSortOrder > 0)) and (not AlbumListHasEmptyString or (Prec(List.List^[Start]).Album > 0));
      tscGenres, tscDrives, tscDrivesRecursive: StartFound := true;
      tscDirectories, tscDirectoriesRecursive, tscTrimmedDirectories, tscTrimmedDirectoriesRecursive: StartFound := length(GetDirectoryAtLevel(List.List^[Start], Data)) > 0;
      tscCustomField: StartFound := Assigned(GetCustomFieldData(List.List^[Start]));
      tscYears, tscDecades: startFound := Prec(List.List^[Start]).Year > 0;
      tscRatings: startFound := true ;//	Prec(List.List^[Start]).Rating > 0;	-Also draw 0 stars
  	end;
    if not StartFound then
    	Inc(Start)
  end
end;

function SameData(rec1, rec2: Prec; Data: Integer): Boolean;
begin
	case TreeStructure.Content of
  	tscArtistsSortOrder: result := rec1.ArtistSortOrder = rec2.ArtistSortOrder;
    tscArtists: result := rec1.Artist = rec2.Artist;
    tscAlbums, tscYear_Albums: result := rec1.Album = rec2.Album;
    tscSets: result := (rec1.Album = rec2.Album) and (self.GetPartOfSet(rec1) = self.GetPartOfSet(rec2));
    tscCompilationContainer: result := (rfCompilation in Rec1.Flags) = (rfCompilation in Rec2.Flags);
    tscCompilations: result := (rec1.Album = rec2.Album) and (rfCompilation in rec2.Flags);
    tscArtist_albums: result := (rec1.ArtistSortOrder = rec2.ArtistSortOrder) and (rec1.Album = rec2.Album);
    tscGenres: result := true;
    tscYears: result := rec1.Year = rec2.Year;
    tscDecades: result := (rec1.Year div 10) = (rec2.Year div 10);
    tscDrives, tscDrivesRecursive:
    begin
    	result := Q_SameTextL(fPathList.Strings[rec1.Fpath], fPathList.Strings[rec2.Fpath], Q_StrScan(fPathList.Strings[rec1.Fpath], '\', 3));
		end;
    tscDirectories, tscDirectoriesRecursive, tscTrimmedDirectories, tscTrimmedDirectoriesRecursive: result := Q_SameText(GetDirectoryAtLevel(rec1, Data), GetDirectoryAtLevel(rec2, Data));
    tscRatings: result := Round(rec1.Rating*StarNrFactor) = Round(rec2.Rating*StarNrFactor);
    tscCustomField:
    begin
    	doTabelCompareNodes(rec1, rec2, FCustomField + Data, Data);
      Result := Data = 0
    end;
  end
end;

function AddNode(parentNode: PVirtualNode; out TR: PTreeRec): PVirtualNode;
begin
	result := Tree.AddChild(parentNode);
  Exclude(result.States, vsHeightMeasured);
  TR := Tree.GetNodeData(result);
  FillChar(TR^, SizeOf(TR^), 0);
  TR.Location := Location;
end;

function CalculateLevels(const path: String): Integer;
var
	i: Integer;
begin
	result := 0;
  i := 3;
  while i < length(path) do
  begin
  	i := Q_StrScan(path, '\', i) + 1;
    inc(result)
  end
end;

function IsFullAlbum(pArr: pointer): Integer; //0 = unknown, 1=full, 2=partial
var
	arr: array of array of boolean;
  i, k: Integer;
  FullAlbum: boolean;
begin
	arr := pArr;

  if length(arr) > 0 then
  begin
  	if length(arr) > 1 then
    begin
    	//sets are defined
      FullAlbum := true;
      for k:=1 to length(arr)-1 do
      begin
      	for i:=0 to length(arr[k])-1 do
        	FullAlbum := FullAlbum and arr[k][i];
        if not FullAlbum then
        	break
      end
    end
    else
    begin
    	if length(arr[0]) = 0 then
      begin
      	result := 0;
        exit
      end;

      FullAlbum := true;
      for i:=0 to length(arr[0]) -1 do
      	FullAlbum := FullAlbum and arr[0][i]
    end;

    if FullAlbum then
    	result := 1
    else
    	result := 2
  end
  else
  	result := 0
end;

function FindCoverRec(pCoverArr: pointer; rec: PRec; compilation: boolean): PCoverRec;
var
	i: integer;
  coverArr: array of array of PCoverRec;
  cr: PCoverRec;
begin
	result := nil;
	coverArr := pCoverArr;

  for i:=0 to length(coverArr[rec.Album])-1 do
  begin
  	cr := coverArr[rec.Album][i];
  	if (compilation or (cr.SourceRec.Artist = rec.Artist)) and (cr.SourceRec.Location = rec.Location) then
    begin
    	result := cr;
      exit
    end
  end
end;

var
	aNode: PVirtualNode;
  StartRec, StopRec: PRec;
  TR: PTreeRec;
  i, j, k, Start, Stop, count, Data, FirstIndexBackup, LastIndexBackup: Integer;
  c: Cardinal;
  SameYears: Boolean; 	//Used with tscYear_Albums
  AlbumCheck: array of array of Boolean;	//1st dimension is set, 2nd dimension is tracknr (AlbumCheck[0] is for tracks without set)
	ListBackup: TSortPartList;
	ListArr: Array of TSortPartList;
  TotalTime: Int64;
begin
  result := false;
  Data := 0;
  Start := FirstIndex;

	//Sort
  if (TreeStructure.Content <> ParentContents) or (TreeStructure.Content in [tscCustomField, tscDirectories, tscDirectoriesRecursive, tscTrimmedDirectories, tscTrimmedDirectoriesRecursive]) then
  case TreeStructure.Content of
  	tscArtistsSortOrder:	list.SortPart(SortRecsByArtistSortOrder, FirstIndex, LastIndex);
  	tscArtists:	list.SortPart(SortRecsByArtist, FirstIndex, LastIndex);
    tscAlbums, tscYear_Albums: list.SortPart(SortRecsByAlbum, FirstIndex, LastIndex);
    tscSets: list.SortPart(SortRecsBySet, FirstIndex, LastIndex);
    tscArtist_albums: list.SortPart(SortRecsByArtist_Album, FirstIndex, LastIndex);
    tscCompilationContainer: list.SortPart(SortRecsByCompilation, FirstIndex, LastIndex);
    tscCompilations: list.SortPart(SortRecsByCompilationAlbum, FirstIndex, LastIndex);
    tscDrives, tscDrivesRecursive: list.SortPart(CompareUpdateTreeDrive, FirstIndex, LastIndex);
    tscYears, tscDecades: list.SortPart(CompareYear, FirstIndex, LastIndex);
    tscRatings: list.SortPart(CompareRating, FirstIndex, LastIndex);
    tscDirectories, tscDirectoriesRecursive, tscTrimmedDirectories, tscTrimmedDirectoriesRecursive:
		begin
    	if not (ParentContents in [tscDrives, tscDrivesRecursive, tscDirectories, tscDirectoriesRecursive, tscTrimmedDirectories, tscTrimmedDirectoriesRecursive]) then
				list.SortPart(CompareUpdateTreeDir, FirstIndex, LastIndex);
      if SendData = -1 then
	      Data := 1	//LEVEL
      else
      	Data := SendData
    end;
    tscGenres:
    begin
    	SetLength(ListArr, Genrelist.Count);
      for c:=0 to length(ListArr)-1 do
      begin
      	ListArr[c] := TSortPartList.Create;
        ListArr[c].Capacity := Genrelist.Count
      end;

      for j:=FirstIndex to LastIndex do
      	for i:=0 to length(Prec(List.Items[j]).Genre)-1 do
        	ListArr[Prec(List.List^[j]).Genre[i]].Add(List.Items[j]);

      ListBackup := List;
      FirstIndexBackup := FirstIndex;
      LastIndexBackup := LastIndex;

      Start := 0;
      Data := -1;	//CURRENT GENRE-INDEX
  		MoveToNextGenre(Data, Start, ListArr)
    end;
    tscCustomField:
    begin
    	Data := SendData;
    	list.SortPart(SortRecsByCustomField, FirstIndex, LastIndex, Data)
    end
  end;

  FindStart(Start, LastIndex, Data);
  while Start <= LastIndex do
  begin
    StartRec := list.List^[Start];

    //Reset values
    Stop := Start;
    Count := 0;
    TotalTime := 0;
    SameYears := true;
    repeat
      StopRec := list.List^[Stop];

      if TreeStructure.IncludeCompilation or not (rfCompilation in StopRec.Flags) then
      begin
        Inc(Count);
        Inc(TotalTime, StopRec.Length);

        if TreeStructure.Content in [tscAlbums, tscYear_Albums, tscArtist_Albums, tscCompilations] then
        begin
        	//Check year
        	if SameYears and (TreeStructure.Content = tscYear_Albums) and (StartRec.Year <> stopRec.Year) then
          	SameYears := false;

          //Check full album
        	k := Max(GetTotalParts(StopRec)+1, GetPartOfSet(StopRec)+1);
        	if Length(AlbumCheck) < k then
          	setLength(AlbumCheck, k);

          k := GetPartOfSet(StopRec);
        	if Length(AlbumCheck[k]) < StopRec.TotalTracks then
          begin
          	SetLength(AlbumCheck[k], 0);
          	SetLength(AlbumCheck[k], StopRec.TotalTracks)
          end;

          //range check:
          if (StopRec.Track > 0) and (StopRec.Track <= Length(AlbumCheck[k])) then
          	AlbumCheck[k][StopRec.Track-1] := true
        end
      end;
      Inc(Stop);
    until (Stop > LastIndex) or not SameData(StartRec, List.List^[Stop], Data);
    Dec(Stop);

    if (Count >= TreeStructure.MinCount) then // and (not (TreeStructure.Content in [tscArtists]) or (Count >= pref.minimumartists.Value)) then
    begin
    	result := true;
      //Create Node
      aNode := AddNode(parentNode, TR);
      TR.Count := Count;
      TR.TotalTime := TotalTime;
      TR.SortField := TreeStructure.SortColumnField;
      TR.Contents := TreeStructure.Content;

      case TreeStructure.Content of
        tscArtistsSortOrder:
        begin
          TR.Kind := TreeKind_Artist;
          TR.Tag := StartRec.ArtistSortOrder;
        end;
        tscArtists:
        begin
          TR.Kind := TreeKind_Artist;
          TR.Tag := StartRec.Artist;
        end;
        tscAlbums, tscYear_Albums, tscArtist_albums:
        begin
        	//Check full album
          case IsFullAlbum(pointer(AlbumCheck)) of
          	0: TR.Kind := TreeKind_Album;
            1: TR.Kind := TreeKind_FullAlbum;
            2: TR.Kind := TreeKind_PartialAlbum
          end;

          TR.Tag := StartRec.Album;

          if (TreeStructure.Content = tscYear_Albums) and SameYears and (StartRec.year > 0) then
          begin
          	TR.Text := GetYearAlbum(StartRec);
            case TR.Kind of
            	TreeKind_Album: TR.Kind := TreeKind_YearAlbum;
              TreeKind_FullAlbum: TR.Kind :=TreeKind_FullYearAlbum;
              TreeKind_PartialAlbum: TR.Kind := TreeKind_PartialYearAlbum;
            end
          end
          else
          if TreeStructure.Content in [tscArtist_albums] then
          begin
          	TR.Text := getFtextP(StartRec, FArtistSortOrder) + ' - ' + getFtextP(StartRec, FAlbum);
            case TR.Kind of
            	TreeKind_Album: TR.Kind := TreeKind_ArtistAlbum;
              TreeKind_FullAlbum: TR.Kind :=TreeKind_FullArtistAlbum;
              TreeKind_PartialAlbum: TR.Kind := TreeKind_PartialArtistAlbum;
            end
          end;
        end;

        tscSets:
        begin
					TR.Kind := TreeKind_Set;
          TR.Tag := StartRec.PartOfSet
        end;

        tscGenres:
        begin
        	TR.Kind := TreeKind_Genre;
          TR.Tag := Data
        end;

        tscDrives:
        begin
        	TR.Kind := TreeKind_Drive;
          TR.Text := GetDirectoryAtLevel(StartRec, 0);
          TR.Tag := 0;
          TR.PathListIndex := StartRec.FPath;
          if CalculateLevels(FPathList.Strings[StartRec.FPath]) <> 1 then
          begin
            TR.Count := 0;
            TR.TotalTime := 0
          end
        end;
        tscDrivesRecursive:
        begin
        	TR.Kind := TreeKind_DriveRecursive;
          TR.Text := GetDirectoryAtLevel(StartRec, 0);
          TR.Tag := 0;
          TR.PathListIndex := StartRec.FPath
        end;
        tscDirectories:
        begin
        	TR.Kind := TreeKind_Directory;
          TR.Text := GetDirectoryAtLevel(StartRec, Data);
          TR.Tag := Data;
          TR.PathListIndex := StartRec.FPath;
          if Data <> CalculateLevels(FPathList.Strings[StartRec.FPath])-1 then
          begin
            TR.Count := 0;
            TR.TotalTime := 0
          end
        end;
        tscDirectoriesRecursive:
        begin
        	TR.Kind := TreeKind_DirectoryRecursive;
          TR.Text := GetDirectoryAtLevel(StartRec, Data);
          TR.Tag := Data;
          TR.PathListIndex := StartRec.FPath
        end;
        tscTrimmedDirectories:
        begin
        	TR.Kind := TreeKind_TrimmedDirectory;
          TR.Text := GetDirectoryAtLevel(StartRec, Data);
          TR.Tag := Data;
          TR.PathListIndex := StartRec.FPath;
          if Data <> CalculateLevels(FPathList.Strings[StartRec.FPath])-1 then
          begin
            TR.Count := 0;
            TR.TotalTime := 0
          end
        end;
        tscTrimmedDirectoriesRecursive:
        begin
        	TR.Kind := TreeKind_TrimmedDirectoryRecursive;
          TR.Text := GetDirectoryAtLevel(StartRec, Data);
          TR.Tag := Data;
          TR.PathListIndex := StartRec.FPath
        end;
        tscCompilationContainer:
        begin
          TR.Kind := TreeKind_CompilationParent;
          TR.Tag := 0
        end;

        tscCompilations:
        begin
        	//Check full album
           case IsFullAlbum(pointer(AlbumCheck)) of
          	0: TR.Kind := TreeKind_CompilationAlbum;
            1: TR.Kind := TreeKind_FullCompilationAlbum;
            2: TR.Kind := TreeKind_PartialCompilationAlbum
          end;

          TR.Tag := startRec.Album
        end;

        tscYears:
        begin
          TR.Kind := TreeKind_Year;
          TR.Tag := startRec.Year
        end;

        tscDecades:
        begin
          TR.Kind := TreeKind_Decade;
          TR.Tag := (startRec.Year div 10) * 10
        end;

        tscRatings:
        begin
        	TR.Kind := TreeKind_Rating;
          TR.Tag := Round(startRec.Rating*StarNrFactor)
        end;

        tscCustomField:
        begin
        	TR.Kind := TreeKind_CustomField;
          TR.Text := GetFTextP(StartRec, FCustomField + Data);
          TR.Tag := Data
        end;
      end;

    	if (TreeStructure.Content in [tscAlbums, tscYear_Albums, tscArtist_albums, tscCompilations]) then
      begin
        TR.CoverRec := FindCoverRec(pCoverArr, startRec, TreeStructure.Content = tscCompilations);
        //If the cover has been loaded before with an error, reset the error flag so that the cover can be loaded again
        if assigned(TR.CoverRec) and (TR.CoverRec.State = ErrorLoading) then
          TR.CoverRec.State := NotLoaded
      end;

      SetLength(AlbumCheck, 0);

      if Assigned(TreeStructure.Child) then
      	FillTree(List, TreeStructure.Child, Location, aNode, Start, Stop, ArtistListHasEmptyString, AlbumListHasEmptyString, TreeStructure.Content, GetDefaultData(TreeStructure.Child), pCoverArr);

    end;

    SetLength(AlbumCheck, 0);

    case TreeStructure.Content of
    	tscGenres:	MoveToNextGenre(Data, Start, ListArr);
      tscCompilationContainer:	break;
      tscDirectories, tscDirectoriesRecursive, tscTrimmedDirectories, tscTrimmedDirectoriesRecursive:
        begin
        	if Count > 0 then
            FillTree(List, TreeStructure, Location, aNode, Start, Stop, ArtistListHasEmptyString, AlbumListHasEmptyString, TreeStructure.Content, Data + 1, pCoverArr);
          Start := Stop + 1;
        end
    else
    	Start := Stop + 1;
    end;

		FindStart(Start, LastIndex, Data)
  end; //End of "While Start < LastIndex"

  //Clean if nessecary
  case TreeStructure.Content of
    	tscGenres:
      begin
      	List := ListBackup;
        FirstIndex := FirstIndexBackup;
      	LastIndex := LastIndexBackup;

      	for i:=0 to length(ListArr)-1 do
        	ListArr[i].Free;
        SetLength(ListArr, 0)
      end
  end;

  if Assigned(TreeStructure.NextSibling) then
  begin
  	FillTree(List, TreeStructure.NextSibling, Location, ParentNode, FirstIndex, LastIndex, ArtistListHasEmptyString, AlbumListHasEmptyString, ParentContents, GetDefaultData(TreeStructure.NextSibling), pCoverArr);

//		if not Assigned(TreeStructure.PrevSibling) then	//This is first node in several siblings on the same levels. Sort the parentnode
//    	Tree.Sort(ParentNode, 500, sdAscending)
  end
end;

Function NodePath(aNode:PVirtualNode):String;
const delimiter: WideChar = '\';
var
	nodeText: WideString;
  fPos, fStart, fEnd, fNew: PWideChar;
  ln, textLength: integer;
begin
	if (aNode = nil) or (aNode = tree.RootNode) then
  	result := delimiter
  else
  begin
    fStart := nil;
    ReallocMem(fStart, 512);
    fEnd := pointer(integer(fStart) + 512);
    fPos := fEnd;
    textLength := 0;

    while aNode <> tree.rootnode do
    begin
      TreeGetText(Tree, aNode, 500, ttStatic, nodeText);
      ln := length(nodeText);

      //if integer(fPos) - integer(fStart) <= (ln+1)*2 then
      if fPos - fStart <= ln+1 then
      begin
        //Allocate some more memory (512 bytes)
        fNew := nil;
        ReallocMem(fNew, 2*(fEnd - fStart) + 512);
        fEnd := fNew + (fEnd - fStart) + 256;

        Move(PWideChar(fPos)^, PWideChar(fEnd-textLength)^, textLength*2);
        fPos := fEnd-textLength;

        FreeMem(fStart);
        fStart := fNew
      end;

      Move(delimiter, PWideChar(fPos-1)^, 2);
      Dec(fPos, ln+1);
      Move(PWideChar(nodeText)^, fPos^, ln*2);

      inc(textLength, ln+1);

      aNode := aNode.parent
    end;

   SetString(result, fPos, textLength);
   FreeMem(fStart)
  end;
end;

function CountDirectoryLevels(const path: String): Integer;
var
	i: Integer;
begin
  result := -1;
  i := 3;
  while i > 1 do
  begin
    i := Q_StrScan(path, '\', i)+1;
    inc(result)
  end
end;

function MyParentHasOtherTrimmedDirs(Node: PVirtualNode): Boolean;
var
	aNode: PVirtualNode;
  NodeDrive: String;
  TR: PTreeRec;
begin
	result := false;
	aNode := Node.Parent.FirstChild;
  TR := Tree.GetNodeData(Node);
  NodeDrive := Q_CopyRange(FPathList.Strings[TR.PathListIndex], 1, Q_StrScan(FPathList.Strings[TR.PathListIndex], '\', 3));
  while (aNode <> nil) and not result do
  begin
  	TR := Tree.GetNodeData(aNode);
  	if (aNode <> Node) and (TR.Kind in [TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive]) and Q_SameText(NodeDrive, Q_CopyRange(FPathList.Strings[TR.PathListIndex], 1, Q_StrScan(FPathList.Strings[TR.PathListIndex], '\', 3))) then
    	result := true
    else
    	aNode := aNode.NextSibling
  end
end;

procedure DoFixTrimmedDirectories(aNode: PVirtualNode);
var
	bNode: PVirtualNode;
  TR: PTreeRec;
begin
	TR := Tree.GetNodeData(aNode);
	while Assigned(aNode) and (aNode.ChildCount > 0) and (CountDirectoryLevels(FPathList.Strings[TR.PathListIndex]) > TR.Tag + 1) and not MyParentHasOtherTrimmedDirs(aNode) do
  begin
    Tree.MoveTo(aNode, aNode.Parent, amAddChildFirst, true);
    bNode := aNode.Parent.FirstChild;
    tree.DeleteNode(aNode);
    aNode := bNode;
    if Assigned(aNode) then
	    TR := Tree.GetNodeData(aNode)
  end
end;

procedure FixTrimmedDirectories;
var
	aNode, bNode: PVirtualNode;
  aNodeLevel: Integer;
  TR: PTreeRec;
begin
	aNode := Tree.GetFirst;
  while aNode <> nil do
  begin
		TR := Tree.GetNodeData(aNode);
    if TR.Kind in [TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive] then
    begin
    	bNode := Tree.GetNext(aNode);
      aNodeLevel := Tree.GetNodeLevel(aNode);
      while assigned(bNode) and (Tree.GetNodeLevel(bNode) > aNodeLevel) do
      	bNode := Tree.GetNext(bNode);
      DoFixTrimmedDirectories(aNode);
      aNode := bNode
    end
    else
    	aNode := Tree.GetNext(aNode)
  end;
{	aNode := tree.GetFirst;
  while (aNode <> nil) and (aNode <> tree.RootNode) do
  begin
  	TR := tree.GetNodeData(aNode);
    if TR.Kind = TreeKind_TrimmedDirectory then
    	if (aNode.ChildCount > 0) and not MyParentHasOtherTrimmedDirs(aNode) and (CountDirectoryLevels(FPathList.Strings[TR.PathListIndex]) > TR.Tag + 1) then
	    begin
      	SetChildKindToTrimmedDirectoryMoved(aNode);
	    	Tree.MoveTo(aNode, aNode.Parent, amAddChildFirst, true);
	      bNode := aNode.Parent.FirstChild;
	      tree.DeleteNode(aNode);
	      aNode := bNode
	    end
	    else
	    	//do NOT get first child!
	      if Assigned(aNode.nextSibling) then
	      	aNode := tree.GetNextSibling(aNode)
	      else
        	if Assigned(aNode.Parent) then
          	aNode := aNode.Parent.NextSibling
        	else
    else
    	aNode := tree.GetNext(aNode)
  end;

  aNode := Tree.GetFirst;
  while aNode <> nil do
  begin
  	TR := tree.GetNodeData(aNode);
    if TR.Kind = TreeKind_TrimmedDirectoryMoved then
    	TR.Kind := TreeKind_TrimmedDirectory;
    aNode := Tree.GetNext(aNode)
  end    }
end;

{procedure ValidateTreeStructureNode(tn: PTreeStructureNode);
begin
	if not assigned(tn) then
  	exit;

	if assigned(tn.NextSibling) then
  begin
  	tn.NextSibling.PrevSibling := tn;
    ValidateTreeStructureNode(tn.NextSibling)
  end;

  ValidateTreeStructureNode(tn.Child)
end;  }


//.UpdateTree; - method
var
	sortList: TSortPartList;
  SLselected,SLexpanded: TQ_Stringlist;
  i, dbIndex, start, stop, Count: Integer;
  TotalTime: Int64;
  aNode, rnode: PVirtualNode;
  TreeStructure: PTreeStructure;
  TR: PTreeRec;
  s, TopRow: String;
  PL : PPlRec;
  ArtistListHasEmptyString, AlbumListHasEmptyString, GroupParentExpanded: Boolean;
  TS: PTreeStructure;
  coverArr: array of array of PCoverRec;
  cr: PCoverRec;
begin
  screen.cursor := crAppStart;

  tree.OnChange := nil;
  //UpdateTreeGroups;	This one is moved down, so that it is remembered what was selected
  MakeFtreePath;

  if Pref.TreeStructureList.RootNodeCount = 0 then
  with Pref do
	  for i:=0 to PreDefinedTreeStructureCount-1 do
		begin
    	aNode := TreeStructureList.AddChild(nil);
	    ts := GetPreDefinedTreeStructureFromIndex(i);
	    ts.Index := aNode.Index;
	    PTreeData(TreeStructureList.GetNodeData(aNode)).p := ts
	  end;

	//Cache values
  ArtistListHasEmptyString := (ArtistList.Count > 0) and (Length(ArtistList.Strings[0]) = 0);
  AlbumListHasEmptyString := (AlbumList.Count > 0) and (Length(AlbumList.Strings[0]) = 0);

  //Lists
  SLselected:=TQ_Stringlist.create;
  SLselected.CaseSensitive := true;
  SLselected.Capacity := tree.RootNodeCount;
  SLexpanded:=TQ_Stringlist.create;
  SLexpanded.CaseSensitive := true;
  SLexpanded.Capacity := tree.RootNodeCount;
  //Husk hvilke der er selected / expanded (START)
  GroupParentExpanded := false;
  if tree.rootnodecount > 0 then
  with Tree do
  begin
  	aNode := GetFirst;
    While aNode<>nil do
    begin
    	if vsSelected in aNode.states then
      	if OldsmChecked then
        begin
        	i:=SLselected.add(NodePath(anode));
          if not showmedia1.checked then
          	SLselected.strings[i] := Q_CopyFrom(SLselected.strings[i], Q_StrScan(SLselected.strings[i], '\')+1)
        end
      	else
        begin
        	i:=SLselected.add(NodePath(anode));
          if showmedia1.checked and (PTreeRec(tree.getNodeData(aNode)).Location >= 0) then
          	SLselected.strings[i] := dbs[PTreeRec(tree.getNodeData(aNode)).Location].Name + '\' + SLselected.strings[i]
        end;
      	if vsExpanded in aNode.states then
      	begin
      		if PTreeRec(tree.GetNodeData(aNode)).Kind = TreeKind_GroupParent then
        		GroupParentExpanded := true;
        	if OldsmChecked then
	        begin
	        	i:=SLexpanded.add(NodePath(anode));
	          if not showmedia1.checked then
	          	SLexpanded.strings[i] := Q_CopyFrom(SLexpanded.strings[i], Q_StrScan(SLexpanded.strings[i], '\')+1)
	        end
	        else
	        begin
	        	i:=SLexpanded.add(NodePath(anode));
	          if showmedia1.checked and (PTreeRec(tree.getNodeData(aNode)).Location >= 0) then
	          	SLexpanded.strings[i] := dbs[PTreeRec(tree.getNodeData(aNode)).Location].Name + '\' + SLexpanded.strings[i]
	        end
	      end;
	    aNode := tree.getnext(aNode)
  	end //of while aNode <> nil
  end; //of if tree.rootnodecount > 0

  if tree.topnode <> nil then
  	toprow := nodepath(tree.topnode);

  //Clear Tree
  Tree.BeginUpdate;
  Tree.Clear;
  BeginUseReclist;
  fCoverRecRw.BeginRead;
  fCoverImgsRw.BeginRead;

  SetLength(coverArr, AlbumList.Count);
  for i:=0 to fCoverImgs.Count-1 do
  begin
  	cr := fCoverImgs.List^[i];
  	SetLength(coverArr[cr.SourceRec.Album], length(coverArr[cr.SourceRec.Album])+1);
    coverArr[cr.SourceRec.Album][length(coverArr[cr.SourceRec.Album])-1] := cr
  end;

	//Fill sortList with recList contents. Filter by groups
  sortList := TSortPartList.Create;
  try
    sortList.Capacity := reclist.Count;
    for i:=0 to reclist.Count-1 do
      if GroupFilter(reclist.List^[i], false) then
        sortList.Add(reclist.List^[i]);

//    starttime := gettickcount;

    if ShowMedia1.Checked then
    begin
      sortList.Sort(SortRecsByLocation);
      Start := 0;
      for dbIndex:=0 to length(dbs)-1 do
      begin
        //Find "Stop"
        Count := 0;
        TotalTime := 0;
        Stop := Start;

        if (Stop < sortList.Count) and (Prec(sortList.List^[Stop]).Location = dbIndex) then
          repeat
            Inc(Count);
            Inc(TotalTime, Prec(sortList.List^[Stop]).Length);
            Inc(Stop);
          until (Stop = sortList.Count) or (Prec(sortList.List^[Stop]).Location <> dbIndex);
        Dec(Stop);

        aNode := Tree.AddChild(nil);
        TR := PTreeRec(tree.GetNodeData(aNode));

        TR.Text := dbs[dbindex].name;
        case dbs[dbindex].media of
          media_Harddisk: TR.Kind := TreeKind_Harddisk;
          media_cdrom: TR.Kind := TreeKind_Cdrom;
          media_removable: TR.Kind := TreeKind_Zip;
          media_network: TR.Kind := TreeKind_Network;
        end;
        TR.Tag := -1;
        TR.Location := dbIndex;
        TR.Count := Count;
        TR.TotalTime := TotalTime;
        TR.SortField := -1;

        TreeStructure := GetTreeStructureFromIndex(dbs[dbindex].TreeStructureIndex);
//        ValidateTreeStructureNode(TreeStructure.Head);

        if (start < SortList.Count) and assigned(TreeStructure) and assigned(TreeStructure.Head) then
          FillTree(SortList, TreeStructure.Head, dbIndex, aNode, Start, Stop, ArtistListHasEmptyString, AlbumListHasEmptyString, tscLocation, GetDefaultData(TreeStructure.Head), coverArr);

        Start := Stop + 1
      end;
    end
    else
    if length(dbs) > 0 then
    begin
    	// not ShowMedia
    	aNode := tree.RootNode;
      TreeStructure := GetTreeStructureFromIndex(dbs[0].TreeStructureIndex);
//      ValidateTreeStructureNode(TreeStructure.Head);

      if (SortList.Count > 0) and assigned(TreeStructure) and assigned(TreeStructure.Head) then
      	FillTree(SortList, TreeStructure.Head, -1, aNode, 0, SortList.Count - 1, ArtistListHasEmptyString, AlbumListHasEmptyString, tscNone, GetDefaultData(TreeStructure.Head), coverArr);
    end;

//    OutputDebugString(pchar('FillTree: ' + inttostr(gettickcount-startTime)));
//    starttime := gettickcount;

    FixTrimmedDirectories;

    //Playlists:
    if pref.ScanPlay.Checked and (m3uList.count > 0) then
    begin
	    with tree do
	    begin
		    rnode := AddChild(nil); //Playlists
		    with PTreeRec(tree.GetNodeData(rNode))^ do
		    begin
			    Kind := TreeKind_PlaylistParent;
			    Count := 0;
			    TotalTime := 0
		     end
	    end;

	    for i:=0 to m3uList.count-1 do
	    begin
		    PL := m3uList.List^[i];
		    aNode :=  tree.AddChild(rNode);
		    with PTreeRec(tree.GetNodeData(aNode))^ do
		    begin
			    Kind := TreeKind_Playlist;
			    Tag := -1;
			    Count := 0;
			    TotalTime := 0;
			    PlRecRef := PL
		    end
	    end
    end;
    //EO Playlist

//    starttime := gettickcount;

    tree.SortTree(0, sdAscending);	//This has been removed (17/7-05) with the introduction of PrevSibling in TreeStructureNode
//    tree.Sort(tree.RootNode, 500, sdAscending);		 //Sort first level only

//    OutputDebugString(pchar('total: ' + inttostr(gettickcount-starttime)));
//  	starttime := gettickcount;

    UpdateTreeGroups;

    //Expander og selecter de gamle
    SLselected.Sort;
    SLexpanded.Sort;
    with Tree do
    begin
      aNode := GetFirst;
      While aNode<>nil do
      begin
        s := NodePath(aNode);
        tree.Expanded[aNode] := SLexpanded.Find(s,i);
        tree.Selected[aNode] := SLselected.Find(s,i);
        if Q_SameStr(S, TopRow) then
          tree.TopNode := aNode;
        aNode := tree.getnext(aNode)
      end
    end;

//    OutputDebugString(pchar('Expander: ' + inttostr(gettickcount-starttime)));
//  	starttime := gettickcount;

  finally
  	Finalize(coverArr);
  	fCoverRecRw.EndRead;
    fCoverImgsRw.EndRead;
  	EndUseReclist;
	  SortList.Free;
    SLselected.Free;
  	SLexpanded.Free;
	  Tree.EndUpdate;
    tree.OnChange := treeChange;
    SetFilterFlags;
  	ApplyFilter(false);
	  OldsmChecked := showmedia1.checked;
	  screen.cursor := crdefault;
    if skipCheckDrives then
    	UpdateTreeExistsFlag(true)
    else
		  checkdrives(true);
  end;
//  OutputDebugString(pchar('UpdateTree-2: ' + inttostr(gettickcount-starttime)));
end;

procedure TMainForm.SetFilterFlags;
function InGenre(const genre:cardinal; const arr: Array of Cardinal):Boolean;
var      i:integer;
begin
  result := false;
  for i:=0 to length(arr)-1 do
  	if arr[i] = genre then
    begin
	  	result := true;
      break
    end
end;

function GetDirLevelIndex(const path: String; level: Integer): Integer;
var
	i: Integer;
begin
	i := 0;
  if level = 0 then
  	result := 1
  else
  begin
	  result := 3;
		while i < level do
	  begin
			result := Q_StrScan(path, '\', result)+1;
	    inc(i)
	  end
  end
end;

var
	i, j, k, l, m: integer;
  rec: PRec;
  filter, filterSet, groupTreeFilter, groupsSelectedInTree: boolean;
begin
	BeginUseReclist;

	MakeFtreePath;

	for j:=0 to reclist.Count-1 do
  begin
  	rec := reclist.List^[j];
    {
    //FILTER GROUPS
  	if length(rec.Groups) = 0 then
	  begin
	  	filter := not fInvertGroups
	  end
	  else
	  begin
	  	filter := fAndGroups;
		  if fAndGroups then
		  begin
			  for i:=0 to groupList.count-1 do
				  if PGroupRec(groupList.List^[i]).Filter and not HasGroup(rec, i) then
				  begin
				    filter := false;
				    break
				  end
		  end
		  else
			  for i:=0 to length(Rec.Groups)-1 do
				  if PGroupRec(groupList.List^[Rec.Groups[i]]).Filter then
				    filter := true
		end;    }

    if GroupFilter(rec, true) then
    	Include(rec.Flags, rfGroupFiltered)
    else
    	Exclude(rec.Flags, rfGroupFiltered);
    //END OF FILTER GROUPS


    //FILTER TREE

    //groupTreeFilter is used to create this: behaivour
    //	If an artist is selected in the tree and also a group is selected: then all songs in that album that are in that selected groups is shown.
    groupTreeFilter := fAndGroups;
    groupsSelectedInTree := false;		//This is set to true if there is a group-node selected in the tree.
    filterSet := false; 	//This actually says if there is anything else than groups selected in the tree.

    if length(fTreeFilter) = 0 then
    begin
    	filter := true;
      filterSet := true
    end
    else
    begin
      filter := false;
      for i:=0 to length(fTreeFilter)-1 do
      begin
        if (fTreeFilter[i, 0].i = -1) or (fTreeFilter[i, 0].i = Rec.Location) then	//Is this the right location or is the node "location-less"
        begin
          k := length(fTreeFilter[i])-1;
          if k = 0 then
          begin
            filter := true;
            filterSet := true
          end
          else    //hvis k = 0 er det fordi fx myMusic er valgt, derfor skal den vre true
            for l:=1 to k do
              case fTreeFilter[i, l].i of
                -1: filter := true;
                -2: filter := false;
              else
              begin
              	filterSet := fTreeFilter[i, l].kind in [TreeKind_genre, TreeKind_artist, TreeKind_album,
                	TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_Set,
                  TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_CompilationParent,
                  TreeKind_artistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum, TreeKind_DirectoryRecursive, TreeKind_Directory,
                  TreeKind_CustomField, TreeKind_Year, TreeKind_Decade, TreeKind_Rating];	//Groups must not be in this list - everything else

                case fTreeFilter[i, l].kind of
                  TreeKind_genre:
                    filter := InGenre(fTreeFilter[i, l].i, Rec.genre);

                  TreeKind_artist:
                    filter := (Rec.ArtistSortOrder = fTreeFilter[i, l].i) or (Rec.artist = fTreeFilter[i, l].i);

                  TreeKind_album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum:
                    filter := Rec.album = fTreeFilter[i, l].i;

                  TreeKind_Set:
                    filter := fTreeFilter[i, l].i = GetPartOfSet(Rec);

                  TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum:
                    filter := (rfCompilation in rec.Flags) and (Rec.album = fTreeFilter[i, l].i);

                  TreeKind_CompilationParent:
                    filter := rfCompilation in Rec.Flags;

                  TreeKind_artistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum:
                    filter := Q_SameText(getFtextP(Rec, FArtistSortOrder) + ' - ' + getFtextP(Rec, Falbum), FTreePath.strings[fTreeFilter[i, l].i]);

                  TreeKind_DirectoryRecursive:
                    filter := Q_MatchText(FTreePath.strings[fTreeFilter[i, l].i], FPathList.Strings[rec.FPath], GetDirLevelIndex(FPathList.Strings[rec.FPath], fTreeFilter[i, l].Tag));

                  TreeKind_Directory:
                    filter := fTreeFilter[i, l].i = rec.FPath;

                  TreeKind_CustomField:
                    filter := Q_SameText(GetFTextP(rec, FCustomField + fTreeFilter[i, l].Tag), FTreePath.strings[fTreeFilter[i, l].i]);

                  TreeKind_Year:
                    filter := fTreeFilter[i, l].i = rec.Year;

                  TreeKind_Decade:
                    filter := fTreeFilter[i, l].i = (rec.Year div 10) * 10;

                  TreeKind_Rating:
                  	filter := fTreeFilter[i, 1].i = Round(rec.Rating*StarNrFactor);

                  TreeKind_Group:
                   	begin
                  		//filter := rfGroupFiltered in rec.Flags;
                      //filter := HasGroup(rec, fTreeFilter[i, l].i);
                    	groupsSelectedInTree := true;
                    	if fAndGroups then
                      	groupTreeFilter := groupTreeFilter and HasGroup(rec, fTreeFilter[i, l].i)
                      else
                      	groupTreeFilter := groupTreeFilter or HasGroup(rec, fTreeFilter[i, l].i)
                    end
                	end;	// of case
              	end;

                if not filter then
                  break
              end
          end
          else
	        begin
						//Okay, we tested that this rec is not in the right location...
	          filterSet := true
	        end;

          if filter then
          	break
        end
    end;

   if (groupsSelectedInTree and not filterSet and groupTreeFilter)     			//if there is only groups selected in the tree
    OR (filterSet and filter and not groupsSelectedInTree)                  //if there is no groups selected in the tree
    OR (filterSet and filter and groupsSelectedInTree and groupTreeFilter)  //if both groups and others are selected in the tree
    then
	  	Include(rec.Flags, rfTreeFiltered)
    else
    	Exclude(rec.Flags, rfTreeFiltered)
  end;

  EndUseReclist
end;

procedure TMainForm.ApplyFilter(ScrollToTop: Boolean = true);
var
	i, j:integer;
  s, filterString: string;
  filterWords: TStringList;
  topNode, aNode : PVirtualNode;
  rec: PRec;
begin
  topNode := nil;
  filtertimer.Enabled := false;
  dontfilter := false;
  searchlabel.font.color := clyellow;

  SetLength(FFilters, PREDEFINED_SEARCHINFIELDCOUNT + FieldList.Count);
  for i:=0 to Length(FFilters) - 1 do
		FFilters[i] := Pref.SearchInFields.Checked[i];

  FNorm.clear;
  FAdd.Clear;
  FSubst.Clear;
  FwholeWord.Clear;
  s := f0.text;
  Q_trimInPlace(s);
  if length(s) > 0 then
  begin
    if s[1] = '+' then
  	  filterString :=  ansilowercase(Q_copyFrom(s,2))
    else
	    filterString :=  ansilowercase(s);

    filterWords := TStringList.Create();
    SplitString(filterString, ' ', filterWords, false, true);

    for i:=0 to filterWords.count -1 do //sorterer sgeord
    begin
      if pref.DeOp.ItemIndex = 1 then
        if (not (filterWords.strings[i][1] in ['-','+','@','~'])) and (i>0) then
          filterWords.strings[i] := '+' + filterWords.strings[i];

      if (filterWords.strings[i][1] = '-') and (length(filterWords.strings[i]) > 1) then
        Fsubst.add(Q_copyFrom(filterWords.strings[i],2)) else

      if (filterWords.strings[i][1] = '+') and (length(filterWords.strings[i]) > 1) then
        Fadd.add(Q_copyFrom(filterWords.strings[i],2)) else

      if (length(filterWords.strings[i]) > 2) and (filterWords.strings[i][1] = '|') and (filterWords.strings[i][length(filterWords.strings[i])] = '|') then
        FwholeWord.add(Q_CopyRange(filterWords.strings[i], 2, length(filterWords.strings[i])-1)) else

      if (filterWords.strings[i][1] <> '-') and (filterWords.strings[i][1] <> '+') then
        Fnorm.add(filterWords.strings[i]);

      if (filterWords.strings[i][1] <> '@') and (filterWords.strings[i][1] = '~') and (Fadd.count > 0) and (Fnorm.count = 0) then
      begin
      	Fnorm.add(Fadd.strings[0]);
        FAdd.Delete(0)
      end
    end;
    filterWords.Free;
  end;

	filterstrings := not ((Fnorm.count=0) and (Fadd.count=0) and (Fsubst.count=0) and (FwholeWord.count=0));

	if filterstrings then
  begin
    FArtistFilter.Size := ArtistList.Count * (2 + fAdd.Count);
    FArtistFilter.SetAllToFalse;
    FArtistFilter.BlockSize := ArtistList.Count;

    FAlbumFilter.Size := AlbumList.Count * (2 + fAdd.Count);
    FAlbumFilter.SetAllToFalse;
    FAlbumFilter.BlockSize := AlbumList.Count;

    FFilepathFilter.Size := fpathList.Count * (2 + fAdd.Count);
    FFilepathFilter.SetAllToFalse;
    FFilepathFilter.BlockSize := fpathList.Count;

    FGenreFilter.Size := GenreList.Count * (2 + fAdd.Count);
    FGenreFilter.SetAllToFalse;
    FGenreFilter.BlockSize := GenreList.Count;

    for i:=0 to reclist.Count-1 do
    begin
      rec := reclist.list^[i];
      if [rfTreeFiltered, rfGroupFiltered] <= rec.Flags then
      begin
        if FFilters[0] then FArtistFilter.Bits[rec.Artist] := true;
        if FFilters[2] then FAlbumFilter.Bits[rec.Album] := true;
        if FFilters[5] then FFilepathFilter.Bits[rec.Fpath] := true;

        if FFilters[4] then
          for j:=0 to Length(rec.Genre)-1 do
            FGenreFilter.Bits[rec.Genre[j]] := true
      end
    end;

    //Artist
    if FFilters[0] then
      for i:=0 to ArtistList.Count-1 do
      begin
        if FArtistFilter.Bits[i] then
        begin
          FArtistFilter.Bits[i] := false;

          for j:=0 to fNorm.Count-1 do
            if Q_PosTextFuzzy(fNorm.Strings[j], artistList.strings[i])>0 then
            begin
              FArtistFilter.Bits[i] := true;
              break
            end;

           for j:=0 to Fsubst.Count-1 do
            if Q_PosTextFuzzy(Fsubst.Strings[j], artistList.strings[i])>0 then
            begin
              FArtistFilter.BitsInBlock[i, 1] := true;
              break
            end;

          for j:=0 to FAdd.Count-1 do
          	FArtistFilter.BitsInBlock[i, 2+j] := Q_PosTextFuzzy(FAdd.Strings[j], artistList.strings[i])>0;

        end
      end;

    //Album
    if FFilters[2] then
      for i:=0 to AlbumList.Count-1 do
      begin
        if FAlbumFilter.Bits[i] then
        begin
          FAlbumFilter.Bits[i] := false;

          for j:=0 to fNorm.Count-1 do
            if Q_PosTextFuzzy(fNorm.Strings[j], AlbumList.strings[i])>0 then
            begin
              FAlbumFilter.Bits[i] := true;
              break
            end;

          for j:=0 to Fsubst.Count-1 do
            if Q_PosTextFuzzy(Fsubst.Strings[j], AlbumList.strings[i])>0 then
            begin
              FAlbumFilter.BitsInBlock[i, 1] := true;
              break
            end;

          for j:=0 to FAdd.Count-1 do
             FAlbumFilter.BitsInBlock[i, 2+j] := Q_PosTextFuzzy(FAdd.Strings[j], AlbumList.strings[i])>0;
        end
      end;

    //Filepath
    if FFilters[5] then
      for i:=0 to fpathList.Count-1 do
      begin
        if FFilepathFilter.Bits[i] then
        begin
          FFilepathFilter.Bits[i] := false;

          for j:=0 to fNorm.Count-1 do
            if Q_PosTextFuzzy(fNorm.Strings[j], fpathList.strings[i])>0 then
            begin
              FFilepathFilter.Bits[i] := true;
              break
            end;

          for j:=0 to Fsubst.Count-1 do
            if Q_PosTextFuzzy(Fsubst.Strings[j], fpathList.strings[i])>0 then
            begin
              FFilepathFilter.BitsInBlock[i, 1] := true;
              break
            end;

          for j:=0 to FAdd.Count-1 do
           	FFilepathFilter.BitsInBlock[i, 2+j] := Q_PosTextFuzzy(FAdd.Strings[j], fpathList.strings[i])>0;
        end
      end;

     //Genre
     if FFilters[4] then
      for i:=0 to GenreList.Count-1 do
      begin
        if FGenreFilter.Bits[i] then
        begin
          FGenreFilter.Bits[i] := false;

          for j:=0 to fNorm.Count-1 do
            if Q_PosTextFuzzy(fNorm.Strings[j], GenreList.strings[i])>0 then
            begin
              FGenreFilter.Bits[i] := true;
              break
            end;

          for j:=0 to Fsubst.Count-1 do
            if Q_PosTextFuzzy(Fsubst.Strings[j], GenreList.strings[i])>0 then
            begin
              FGenreFilter.BitsInBlock[i, 1] := true;
              break
            end;

          for j:=0 to FAdd.Count-1 do
          	FGenreFilter.BitsInBlock[i, 2+j] := Q_PosTextFuzzy(FAdd.Strings[j], GenreList.strings[i])>0;
        end
      end;
	end;


  tabel.BeginUpdate;

  //Save selected nodes
{  SetLength(selectedNodes, tabel.SelectedCount);
  aNode := nil;
  for i:=0 to tabel.SelectedCount-1 do
  begin
  	aNode := tabel.GetNextSelected(aNode);
    selectedNodes[i] := aNode
  end;

  tabel.ClearSelection;   simply dont' clear the selection   }
  topNode := tabel.TopNode;
  ShowHideNodes;

  //Re-select nodes

  if not ScrollToTop and assigned(topNode) and NodeBelongsToTree(topNode, tabel, true) and (tabel.IsVisible[topNode]) then
  begin
  	tabel.Endupdate;
  	tabel.TopNode := topNode
  end
  else
  begin
  	tabel.OffsetY := 0;
  	tabel.endupdate
  end;
  if assigned(tabel.FocusedNode) and tabel.IsVisible[tabel.FocusedNode] then
  	tabel.FocusedNode := tabel.FocusedNode
  else
  	if tabel.VisibleCount > 0 then
  		tabel.FocusedNode := tabel.GetFirstVisible;

  if assigned(tabel.FocusedNode) then
  	tabel.Selected[tabel.FocusedNode] := true;

  searchlabel.font.color := grouplabel.Font.color;
end;

procedure TMainForm.CreateParams(var Params: TCreateParams);
begin
	inherited CreateParams(Params);

//  params.WndParent := GetDesktopwindow;

{	Params.ExStyle :=Params.ExStyle or WS_EX_DLGMODALFRAME;
	params.Style := params.Style or WS_Overlapped or WS_POPUP;
	Params.WndParent := GetDesktopwindow;
                   }
	//with Params do
	//begin
	 //	Style := style;// or WS_THICKFRAME;// or WS_OVERLAPPED;//Style or ws_Overlapped;
	 //	style := style or WS_EX_TOOLWINDOW and not WS_EX_APPWINDOW;
	//	WndParent := 0//Application.Handle
	//end;    }
end;

procedure TMainForm.FormCreate(Sender: TObject);
var
	r : Trect;
	i, x:integer;
begin
  {$ifdef MEXPBuilding}
  	N17.Visible := true;
  	N17.OnClick := N17Click;
	{$endif MEXPBuilding}

//  fRecManager := TRecMemoryManager.Create;

  fCoverImgs := TList.Create;
  fCoverImgsRW := TMultiReadExclusiveWriteSynchronizer.Create;
  fCoverRecRW := TMultiReadExclusiveWriteSynchronizer.Create;
  fCoverLoadPriority := 0;
  WakeCoverThread := CreateEvent(nil, False, False, nil);

  ChangedDirsToAutoScan := TStrings.Create;
  ChangedDirsToAutoScanLock := TCriticalSection.Create;

  Randomize;
  SafeToAutoScanCount := 0;
	TimeAtAutoFocusPlayingNodeInWinplaylist := GetTickCount;
  tabelMouseRightMouseButtonDown := false;
  Resizing := false;
  SliderTimerRunning := 0;
  WinampPlaylistJustChangedByMEXP := false;
  capturing := false;
  FThumbTrackVisible := false;
  WinplaylistClickTime := 0;
  MLClickTime := 0;
	PlayingSongPlayCountIncreased := false;

	ConfigImageShown := false;
	PartyHookSet := false;
	TimeViewMode := TWM_Both;

//  application.HintPause := 1000;	//this line seems to destroy hints
  application.HintHidePause := 10000;
  application.HintShortPause := 500;

	PartyModePassword := '';
  FCurrentBackgroundImage := '';

	CurrentPlayPos := high(Integer);

	//skin billeder:
	imglowerleft := TBitmap.Create;
	imgLowerRight := TBitmap.Create;
	imgLower := TBitmap.Create;

	iUpLeft := TBitmap.Create;
	iUpLeftShade := TBitmap.Create;
	iUpRight := TBitmap.Create;
	iUpRightShade := TBitmap.Create;
	iUp := TBitmap.Create;
	iUpShade := TBitmap.Create;
	iUpBlank := TBitmap.Create;

	iArc := TBitmap.Create;
	iArcShade := TBitmap.Create;

	imgLeft := TBitmap.Create;
	imgRight := TBitmap.Create;

	imgVolSliderBtn := TBitmap.Create;

	imgRepeat := TBitmap.create;
	imgShuffle := TBitmap.create;
	imgConfig := TBitmap.Create;

	imgSlider := TBitmap.Create;
	imgSliderBtn := TBitmap.Create;

  FCurPlayBitmap := TBitmap.Create;

	PositionSliderBuffer := TBitmap.Create;

	panel1.doublebuffered := true;
	filterbar.doublebuffered := true;
	tabelBar.doublebuffered := true;
	WPbar.doublebuffered := true;
	WPbarLow.doublebuffered := true;

  TempCanvas := TBitmap.Create;

		 for i:=1 to 12 do
			ScrollBarImgs[i] := TBitmap.Create;

		 listpanelheight := -1;
				deltaPlaylist := 0;
				tabelCurrentColumn := -1;
				tabelEditting := false;
				SequelTabelEditting := false;
        TopImageBuffer := TBitmap.create;
				appactivated:=false;
        AutoScanInProcess := false;
        QueSpyScan := false;
				WinplayCanUndo := false;
				FCurPlay := '';
				FoldPosi := -1;

        TreeScrollbarsNeedsUpdate := false;
//				fInvertGroups := false;
				FInvertGroupsChecked := false;
        fOnlyPL := false;
        UpdTimer := GetTickCount;
        tabel.NodeDataSize := SizeOf(TTreeData);
				tree.NodeDataSize := SizeOf(TTreeRec);
				winplaylist.NodeDataSize := SizeOf(TplstRec);
				plCon.NodeDataSize := SizeOf(TPLconRec);
				Playlistbox.NodeDataSize := SizeOf(TPlBoxData);

				rez2 := false;
        doneclear := true;
        rezborder := false;
				forcedirectories(settingsdir + '-quicklist');
				forcedirectories(plugindir + AppName);
				forceDirectories(undoDir);

				MainFormInstance.Icon := Icon1.Picture.Icon;

				//Columns default visible:
        SetLength(TabelColumnsVisible, tabel.Header.Columns.Count);
				for i:=0 to tabel.Header.Columns.Count-1 do
					TabelColumnsVisible[i] := coVisible in tabel.Header.Columns[i].Options;

				if Settings.ValueExists('aot') then
					aot.checked := Settings.readBool('aot')
				else aot.checked := false;

				reclist := Tlist.create;
				fHashedRecList := TRecHashTable.create;
        AddRecList := Tlist.create;
        groupList := Tlist.create;
        m3uList := Tlist.create;
        FieldList := TList.Create;
        WinplayUndoList := TList.create;
        fileUndoList := TList.create;
        filters := TQ_StringList.create;
        FPlayList := TList.create;
        FTreePath := TQ_StringList.create;
				FNorm := TQ_Stringlist.create;
				FwholeWord := TQ_Stringlist.create;
				FNorm.Sorted := true;
        FAdd := TQ_StringList.create;
        FSubst := TQ_StringList.create;

        FArtistFilter := TMyTBits.Create;
        FAlbumFilter := TMyTBits.Create;
		  	FFilepathFilter := TMyTBits.Create;
        FGenreFilter := TMyTBits.Create;

        FDeleteGroupsFromTagList := TQ_StringList.Create;
        FDeleteGroupsFromTagList.Sorted := true;
        FIgnoreGroupList := TQ_StringList.Create;
        FIgnoreGroupList.Sorted := true;
        FUseGroupInsteadList := TQ_StringList.Create;
        FUseGroupInsteadList.Sorted := true;

				artistList := TQ_StringList.create;
				albumList := TQ_StringList.create;
				fPathList := TQ_StringList.create;
				artistList.Sorted := true;
				artistList.CaseSensitive := true;
				albumList.Sorted := true;
				albumList.CaseSensitive := true;
				fPathList.Sorted := true;

        GenreList := TQ_Stringlist.create;
        genreList.sorted := false;
				for i:=0 to Maxgenres do GenreList.add(genres[i]);

				if Settings.ValueExists('search') then
					x:= Settings.readInteger('search')
				else x := 0;

        if x = 1 then
        begin
             filters.Add('');
             filters.Add('');
						 filters.Add('');
             filters.Add('');
             filters.Add('');
             filters.Add('');
             filters.Add('')
        end;
        DBinitiated := false;
        colsizing := false;
        GetWindowRect(hwnd_winamp,r);
        MainFormInstance.Constraints.minWidth :=275;

        LoadLanguageGUI;
				FCurPlayText := ''
end;

procedure TMainForm.FixAudioTypesSortOrder;
var
	strlist: TQ_Stringlist;
	i: Integer;
begin
	strList := TQ_Stringlist.Create;
  strList.CaseSensitive := false;
  for i:=0 to length(audioTypes)-1 do
  	strList.AddObject(audioTypes[i].shortName, @audioTypes[i]);
  strList.Sort;
  for i:=0 to strList.Count-1 do
  	TAudioType(pointer(strList.Objects[i])^).SortIndex := i+1;
  strList.Free
end;

procedure TMainForm.CopyAudioType(fromIndex, toIndex: Integer);
var
	i: Integer;
begin
	AudioTypes[toIndex].SortIndex := AudioTypes[fromIndex].SortIndex;

  AudioTypes[toIndex].longName := AudioTypes[fromIndex].longName;
  AudioTypes[toIndex].shortName := AudioTypes[fromIndex].shortName;
  AudioTypes[toIndex].StopWinampWhenEdit := AudioTypes[fromIndex].StopWinampWhenEdit;
  AudioTypes[toIndex].Id3v1 := AudioTypes[fromIndex].Id3v1;
  AudioTypes[toIndex].Id3v2 := AudioTypes[fromIndex].Id3v2;
  AudioTypes[toIndex].Ogg := AudioTypes[fromIndex].Ogg;
  AudioTypes[toIndex].ApeV1 := AudioTypes[fromIndex].ApeV1;
  AudioTypes[toIndex].ApeV2 := AudioTypes[fromIndex].ApeV2;
  AudioTypes[toIndex].WMA := AudioTypes[fromIndex].WMA;
  AudioTypes[toIndex].audio := AudioTypes[fromIndex].audio;
  AudioTypes[toIndex].video := AudioTypes[fromIndex].video;

  SetLength(AudioTypes[toIndex].ext, length(AudioTypes[fromIndex].ext));
  for i:=0 to length(AudioTypes[fromIndex].ext)-1 do
  	AudioTypes[toIndex].ext[i] := AudioTypes[fromIndex].ext[i];

  SetLength(AudioTypes[toIndex].channelNames, length(AudioTypes[fromIndex].channelNames));
  for i:=0 to length(AudioTypes[fromIndex].channelNames)-1 do
  	AudioTypes[toIndex].channelNames[i] := AudioTypes[fromIndex].channelNames[i];
end;

procedure TMainForm.RemoveAudioType(index: Integer);
var
	i: Integer;
begin
	for i:=index to length(AudioTypes) -2 do
  	CopyAudioType(i + 1, i);

  SetLength(AudioTypes, length(AudioTypes)-1);
end;

procedure TMainForm.InitDB;
Procedure ReadString(Str: TStream; var s: String);
var
	Size : word;
begin
	Str.Read(Size, SizeOf(Size));
  SetLength(s, Size);
  if Size > 0 then
  	Str.Read(s[1], Size)
end;

Function getdbindex(const name:string):string;
var i:integer;
begin
	i:= locateDBname(name);
	if i > -1 then
		result :=inttostr(i)
end;

procedure LoadCoverCache;
var
	mstr: TMemoryStream;
  cr: PCoverRec;
  fv: cardinal;
  j: integer;
  ok: boolean;
  sortedReclist: TQ_StringList;	//Todo: Remove this in some later version. Introduced in Beta 9.1
begin
	sortedReclist := nil;
	if getFileAccess(settingsDir + 'Covers.dat', true, false) then
  begin
  	fCoverImgsRW.BeginWrite;
    fCoverRecRW.BeginWrite;
  	try
      mstr := TMemoryStream.Create;
      mstr.LoadFromFile(settingsDir + 'Covers.dat');
      mstr.Position := 0;
      //lser fileVersion
      mstr.Read(FV, sizeOf(FV));
      if FV in [1, 2, COVERCACHE_FileVer] then //rigtig filever
      begin
      	if FV in [1, 2] then
        begin
        	//Generate list with sorted filenames for backward compability
          sortedReclist := TQ_StringList.Create;
          sortedReclist.CaseSensitive := false;
          sortedReclist.Capacity := reclist.Count;
          for j:=0 to reclist.Count-1 do
          	sortedReclist.AddObject(GetFTextP(reclist.List^[j], FFilename), TObject(reclist.List^[j]));
          sortedReclist.Sort;
        end;
        while mstr.Position <> mstr.Size do
        begin
        	ok := true;
          new(cr);
          FillChar(cr^, SizeOf(cr^), 0);
          cr.State := NotLoaded;
          mstr.Read(cr.SourceType, SizeOf(cr.SourceType));
          mstr.Read(cr.ThumbnailWidth, SizeOf(cr.ThumbnailWidth));
	        mstr.Read(cr.ThumbnailHeight, SizeOf(cr.ThumbnailHeight));

          mstr.Read(j, SizeOf(j));
          if FV in [1, 2] then
          begin
          	if (j >= 0) and (j < sortedReclist.count) then
	          	cr.SourceRec := pointer(sortedReclist.Objects[j])
	          else
	          	ok := false;
          end
          else
          begin
	          if (j >= 0) and (j < fHashedRecList.count) then
	          	cr.SourceRec := fHashedRecList.List^[j]
	          else
	          	ok := false;
          end;

          ReadString(mstr, cr.ThumbCacheFilename);
          if cr.SourceType = coverSource_imageFile then
		      	ReadString(mstr, cr.ImageFilename);

          if ok then
          	fCoverImgs.Add(cr)
          else
          	Dispose(cr)
        end
      end;
      mstr.Free
    finally
    	fCoverImgsRW.EndWrite;
      fCoverRecRW.EndWrite
    end
  end;
  
  if assigned(sortedReclist) then
  	sortedReclist.Free
end;

Function LoadWPL : PVirtualNode;	//returnerer playingNode / nil
var
  WPL:TMemoryStream;
  aNode:PVirtualNode;
  PL:PplstRec;
  FV, c:cardinal;
  i:integer;
  b:boolean;
  Size : word;
  s : array[0..MaxSavedChars] of char;
begin
  result := nil;
  if getFileAccess(settingsDir + 'winplaylist.dat', true, false) then
  begin
    WPL := TMemoryStream.Create;
    WPL.LoadFromFile(settingsDir + 'winplaylist.dat');
    WPL.Position := 0;

    //lser fileVersion
    WPL.Read(FV, sizeOf(FV));
    if FV = WPL_FileVer then //rigtig filever
    begin
      WPL.Read(ShuffleEnabled, SizeOf(ShuffleEnabled));

      WinampPlaylistRealCount := SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH);

      winplaylist.beginupdate;
      WPL.Read(c, sizeOf(c));
      winplaylist.RootNodeCount := c;

      aNode := winplaylist.GetFirst;
      while aNode <> nil do
      begin
        PL := winplaylist.GetNodeData(aNode);
        fillChar(PL^, sizeOf(PL^), #0);
        WPL.Read(b, sizeOf(b));
        if b then
        begin
           //der findes en reference til entrien
           WPL.Read(i, sizeOf(i));
           if (i >= 0) and (i < fHashedRecList.count) then
              PL.Rec := fHashedRecList.List^[i]
           else
           begin
            //der er sket en fejl...
            winplaylist.RootNodecount := aNode.index;
            break //breaker while
           end
        end else
        begin
          //der er ingen ref til entrien.. lser filename og text
          WPL.Read(size, sizeOf(size));   //filename
          WPL.Read(s, Size);
          PL.Filename := Q_CopyLeft(s, size);

          WPL.Read(size, sizeOf(size));   //text
          WPL.Read(s, Size);
          PL.Text := Q_CopyLeft(s, size);

          WPL.Read(PL.Seconds, sizeOf(PL.Seconds)) //seconds
        end;

      WPL.Read(PL.playing, sizeOf(PL.Playing));
      WPL.Read(PL.Kill, sizeOf(PL.Kill));
      WPL.Read(PL.ShuffleValue, sizeOf(PL.shuffleValue));
      WPL.Read(PL.EnqueueNo, sizeOf(PL.EnqueueNo));

      if PL.Playing then
	      result := aNode;

      aNode := winplaylist.GetNext(aNode)
    end;

      winplaylist.EndUpdate;
    end;
    WPL.free
  end
end;

/// main - InitDB
var
	dbpresent, b:boolean;
  name: String;
  FV:Cardinal;
  mstr : TMemoryStream;
  PR : PplRec;
  Size, i, x, posi, k : integer;
  MexpPlaying: PVirtualNode;
  GR : PGroupRec;
  SGR: TSaveGroupRec;
  CF: PCustomField;
  pt:Tpoint;
  w:word;
  dateTime: TDateTime;
  s : array[0..MaxSavedChars] of char;
  treeNeedsUpdate:Boolean;
  CurrentFormBackup : TForm;
  aNode: PVirtualNode;
  DirList: TStrings;
  vtColumn: TVirtualTreeColumn;
  start: DWord;
begin
  DBinitiated := true;
  treeNeedsUpdate := false;

  setlength(dbs,0);
  //Load Start:
  dbpresent :=false;
  if fileexists(settingsdir + 'dbs.dat') then
  begin
		mstr := TMemoryStream.Create;
    mstr.LoadFromFile(settingsdir + 'dbs.dat');
    mstr.position := 0;
   	mstr.Read(FV, sizeof(FV));     //fileVersion
    if FV in [1..DBS_FileVer] then
	  begin
    	if FV >= 4 then
      begin
      	mstr.Read(dateTime, SizeOf(dateTime));
        dateTime := dateTime * -1;
        AddAppStartDate(dateTime)
      end;

      if FV >= 9 then
        begin
        	//Read custom fields
          mstr.Read(size, sizeOf(integer));
          for i:=0 to Size-1 do
          begin
            new(CF);
            FillChar(CF^, SizeOf(CF^), 0);
            mstr.Read(CF.DataType, SizeOf(CF.DataType));
            mstr.Read(CF.IconIndex, SizeOf(CF.IconIndex));
            mstr.Read(CF.Filter, SizeOf(CF.Filter));
            ReadString(mstr, CF.name);
            ReadString(mstr, CF.id3v2FieldName);
            if FV >= 11 then
            begin
            	ReadString(mstr, CF.id3v2Description);
      				ReadString(mstr, CF.id3v2DefaultLanguage);
      				mstr.Read(CF.id3v2ReadAllLanguages, 1);
            end;
            ReadString(mstr, CF.oggFieldName);
            ReadString(mstr, CF.apeFieldName);
            ReadString(mstr, CF.wmaFieldName);
            FieldList.Add(CF);
            pref.SearchInFields.Items.Add(CF.Name);
            pref.SearchInFields.Checked[pref.SearchInFields.Items.Count - 1] := CF.Filter;

            vtColumn := tabel.Header.Columns.Add;
            vtColumn.Text := CF.name;
            vtColumn.Tag := FCustomField + FieldList.Count - 1;
            vtColumn.Style := vsOwnerDraw
          end;
    		end;

        if FV >= 6 then
        begin
        	//Read AudioTypes
          mstr.Read(size, sizeOf(integer));
					SetLength(audioTypes, Length(audioTypes) + size);
          for i:= PREDEFINED_AUDIOTYPESCOUNT to length(audioTypes)-1 do
          with audioTypes[i] do
          begin
						mstr.Read(w, sizeof(w));
            mstr.Read(s, w);
            longName := Q_CopyLeft(s, w);

            mstr.Read(w, sizeof(w));
            mstr.Read(s, w);
            shortName := Q_CopyLeft(s, w);

            mstr.Read(size, sizeOf(integer));
						SetLength(ext, size);
            for k:=0 to length(ext)-1 do
            begin
            	mstr.Read(w, sizeof(w));
            	mstr.Read(s, w);
            	ext[k] := Q_CopyLeft(s, w)
            end;

            mstr.Read(size, sizeOf(integer));
						SetLength(channelNames, size);
            for k:=0 to length(channelNames)-1 do
            begin
            	mstr.Read(w, sizeof(w));
            	mstr.Read(s, w);
            	channelNames[k] := Q_CopyLeft(s, w)
            end;

            mstr.Read(StopWinampWhenEdit, SizeOf(boolean));
            mstr.Read(Id3v1, SizeOf(boolean));
            mstr.Read(Id3v2, SizeOf(boolean));
            mstr.Read(Ogg, SizeOf(boolean));
            mstr.Read(ApeV1, SizeOf(boolean));
            mstr.Read(ApeV2, SizeOf(boolean));
            mstr.Read(WMA, SizeOf(boolean));
            mstr.Read(audio, SizeOf(boolean));
            mstr.Read(video, SizeOf(boolean))
          end;
          fixAudioTypesSortOrder
        end;

        //Read TreeStructures
        if FV >= 8 then
        begin
			    mstr.Read(i, SizeOf(i));
			    with Pref.TreeStructureList do
			    begin
          	Clear;
          	RootNodeCount := i;
			    	aNode := GetFirst;
			      while aNode <> nil do
			      begin
			      	PTreeData(GetNodeData(aNode)).p := LoadTreeStructure(mstr);
			        aNode := GetNext(aNode)
			      end
			    end
        end
        else
        begin
       		with Pref.TreeStructureList do
			    begin
          	Clear;
						for i:=0 to PreDefinedTreeStructureCount-1 do
            begin
			    		aNode := AddChild(nil);
              PTreeData(GetNodeData(aNode)).p := GetPreDefinedTreeStructureFromIndex(i)
            end
			    end
        end;

        //reading groups
        mstr.Read(size, sizeof(integer));
        for i:=0 to size-1 do
        begin
             new(GR);
             fillChar(GR^, sizeOf(GR^), #0);
             mstr.Read(SGR, sizeof(TSaveGroupRec));
             GR.Name := SGR.Name;
             GR.Checkstate := SGR.Checkstate;
             GroupList.add(GR)
        end;//of load groups
        //reading genres
        mstr.Read(size, sizeof(integer));
        for i:=0 to size-1 do
        begin
             mstr.Read(w, sizeof(w));
             mstr.Read(s, w);
             genreList.add(Q_CopyLeft(s, w));
        end;//of load genres
        //reading Artists
        mstr.Read(size, sizeof(integer));
        for i:=0 to size-1 do
        begin
             mstr.Read(w, sizeof(w));
             mstr.Read(s, w);
             artistList.add(Q_CopyLeft(s, w));
        end;//of load artists
        //reading Albums
        mstr.Read(size, sizeof(integer));
        for i:=0 to size-1 do
        begin
             mstr.Read(w, sizeof(w));
             mstr.Read(s, w);
             albumList.add(Q_CopyLeft(s, w));
        end;//of load albums
       //reading fPaths
        mstr.Read(size, sizeof(integer));
        for i:=0 to size-1 do
        begin
             mstr.Read(w, sizeof(w));
             mstr.Read(s, w);
             FpathList.add(Q_CopyLeft(s, w))
        end;//of load fPaths
        //Load Autoscan paths
        mstr.Read(size, sizeof(integer));
        for i:=0 to size-1 do
        begin
             mstr.Read(w, sizeof(w));
             mstr.Read(s, w);
             mstr.Read(b, sizeof(b));
             x := pref.AutoScanPaths.Items.Add(Q_CopyLeft(s, w));
             pref.AutoScanPaths.Checked [x] := b
        end;

       while mstr.Position <> mstr.Size do
       begin
       		setlength(dbs,length(dbs)+1);
         	LoadToDBS(mstr, length(dbs)-1, FV);
          if not fileexists(settingsdir + dbs[length(dbs)-1].filename) then
          begin
          	setLength(dbs, length(dbs)-1);    //databasefilen mangler!
            treeNeedsUpdate := true
          end
       end
   end; //of filever
   mstr.free;

   if (length(dbs) > 0) and fileexists(settingsdir + dbs[0].Filename) then dbpresent := true
  //             updatelocationnames;
  end; //of fileexists dbs.dat

  m3uList.Clear;
  if fileexists(settingsdir + 'dbpl.dat') then
  begin
  	mstr := TMemoryStream.Create;
    mstr.LoadFromFile(settingsdir + 'dbpl.dat');
    mstr.Position := 0;

    mstr.Read(FV, sizeof(FV));     //fileVersion
    if FV = DBPL_FileVer then
    begin
      if FV >= 2 then
      begin
        mstr.Read(dateTime, SizeOf(dateTime));
        dateTime := dateTime * -1;
        AddAppStartDate(dateTime)
      end;
      while mstr.Position <> mstr.Size do
      begin
         new(PR);
         mstr.Read(PR^, sizeOf(TplRec));
         PR.CacheRef := nil; //Da denne ikke er gemt
         m3uList.Add(PR)
      end
    end;
    mstr.free
  end;

  LoadColumnSettings;	//skal frst loades her, s vi fr eventuelle custom fields med.

  if not dbpresent then
  begin
    application.processmessages;
    if YesNoBoxx(AppName, GetText(TXT_NoDatabaseFound) ,GetText(TXT_Yes), GetText(TXT_No), 1) then
    begin   //hvis ok
      pref.PC.activepage := pref.TSMyMusic;
      disableAOT;;
      CurrentFormBackup := CurrentActiveForm;
      CurrentActiveForm := pref;
      if pref.ShowModal = mrcancel then
      begin
        DBinitiated:=false;
        quitting := false;
        CurrentActiveForm := CurrentFormBackup;
        restoreAOT;
        exit
      end
      else //hvis pref er vist
      begin
        restoreAOT;
        CurrentActiveForm := CurrentFormBackup;
        dbpresent := reclist.count > 0;
        if not dbpresent then
        begin
          DBinitiated:=false;
          quitting := false;
          exit
        end
      end
    end
    else
    begin
      DBinitiated:=false;
      quitting := false;
      exit
    end
  end;
  screen.cursor:=crappstart;
  updateplaylistbox;
  dontfilter := true;

  if Settings.ValueExists('searchstring') and pref.savesearch.checked then
	  f0.text := Settings.readString('searchstring');

  LoadAllDBs;

  UpdateHashedReclist;
  LoadCoverCache;

    if pref.ControlPlaylist.checked then
  begin
    MexpPlaying := LoadWPL; //lser winplaylist (WPL)   (dette skal gres fr der scannes efter nye filer, da der i filen henvises til indexnr. i sortedreclist
    if MexpPlaying <> nil then
    begin
    Posi := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
    name := pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTFILE));
    if Q_SameText(name, GetWinplayFilename(Winplaylist.GetNodeData(MexpPlaying))) then
    if shuffleEnabled then
      Posi := ValidateWinplaylist(-1, MexpPlaying)
    else
      Posi := ValidateWinplaylist(MexpPlaying.Index, MexpPlaying);
    end
  end;

  //Tree
  if fileexists(settingsdir + 'treeStruct.dat') then
  begin
//    FS := TfileStream.create(settingsdir + 'treeStruct.dat', fmOpenRead or fmShareDenyNone);
		mstr := TMemoryStream.Create;
    mstr.LoadFromFile(settingsdir + 'treeStruct.dat');
    mstr.Read(FV, sizeof(FV));     //fileVersion
    if FV = TREE_FileVer then
    	begin
	    if FV >= 3 then
	    begin
	      mstr.Read(dateTime, SizeOf(dateTime));
	      dateTime := dateTime * -1;
	      AddAppStartDate(dateTime)
	    end;

	    mstr.read(b, sizeOf(boolean));
	    showMedia1.checked := b;
	    OldsmChecked := b;

	    //henter scrollinfo
	    mstr.Read(pt, sizeOf(Tpoint));
	    if treeNeedsUpdate then
      	updateTree(true)
	    else
		    try
		    begin
		    	tree.OnNewText := nil;
		      LoadTree(Tree, mstr);
		    	tree.OnNewText := treeNewText
		    end;
		    except
		    	updatetree(true)
		    end;
	    UpdateTreeGroups;
      tree.UpdateScrollBars(false);
	    tree.OffsetXY := pt
    end
    else
    begin
      showMedia1.checked := true;
      OldsmChecked := true;
      updatetree(true)
    end;
    mstr.free
    end
    else
    begin
	    showMedia1.checked := true;
	    OldsmChecked := true;
	    updatetree(true)
    end;
    //EO Tree

    if tree.RootNodeCount = 0 then
    begin
     showMedia1.checked := true;
     OldsmChecked := true;
     updatetree(true)
    end;

  //Scanner nye:
  if (pref.AutoScanPaths.Items.Count>0) and not AutoScanInProcess then
  begin
  	Inc(SafeToAutoScanCount);
    DirList := TStrings.Create;	// Set Free in AutoscanThreadExecute
    for i:=0 to pref.AutoScanPaths.Items.Count-1 do
    	DirList.Add(pref.AutoScanPaths.Items[i]);

    if pref.OnlyScanOnceADay.checked and Settings.ValueExists('lastscandate') then
    begin
    	if date <> Settings.readDate('lastscandate') then
      begin
      	dirSpyTimer.Enabled := false;
        AutoScanInProcess := true;
        Dec(SafeToAutoScanCount);
        AutoscanThread.Start(DirList)
      end
    end else
    begin
    	dirSpyTimer.Enabled := false;
      AutoScanInProcess := true;
      Dec(SafeToAutoScanCount);
      AutoscanThread.Start(DirList)
    end;
    Settings.writeDate('lastscandate',date)
  end;
  //EO Scanner nye

  Checkdrives(false);

  MakeFtreePath;
  tabel.beginupdate;
  reclisttotabel(false, true);

//  if tree.SelectedCount = 0 then
//	  ApplyFilter;    this was commented out 23/06/2005	(just before the release of 9.4) as I don't know what it's for

  tabel.endupdate;
  tabelpanel.visible:=true;
  screen.Cursor:=crdefault;
  slidertimertimer(nil);
  sliderr.visible := true;
  WinplaylistCurrentTimeLabel.Visible := true;
  slidertimer.enabled := true;
  colrez := false;
  dontfilter := false;
  CreateDirSpys;
  // Checkdrives(false);
  CoverLoadThread.Start
end;

procedure TMainForm.Image1MouseDown(Sender: TObject; Button: TMouseButton; //gr "Caption move" muligt
	Shift: TShiftState; X, Y: Integer);
var
	r: TRect;
begin
	if PartyMode1.Checked then
		exit;

	if (mbRight = Button) and ScanThread.Runing then
	begin
		MainFormInstance.StopScanning;
		exit
	end;

	if winmaximized then exit;
        pm.x:=x + MainFormInstance.left;
        pm.y:=y + MainFormInstance.Top;
        GetWindowRect(hwnd_winamp,r);
        p.x := r.left;
        p.y := r.Top;
        c.x := r.Right;
        c.y := r.Bottom;


    ReleaseCapture;
    SendMessage(MainFormInstance.Handle, WM_SYSCOMMAND, 61458, 0);
   {$IFNDEF WIN32}
    GetCursorPos(pt);
    SendMessage(MainFormInstance.Handle,
								WM_LBUTTONUP,
                MK_CONTROL,
                Longint(pt));
   {$ENDIF}
end;


procedure TMainForm.minimizeClick(Sender: TObject);
begin
	SetMainFormVisible(false)
end;

procedure TMainForm.WindowShadeClicked;
var
	r:Trect;
begin
  GetWindowRect(hwnd_winamp,r);
  if MainFormInstance.clientheight = WindowShadeHeight then
  begin  //normalize
    MainFormInstance.Constraints.maxheight := 0;//r2.Bottom-r2.Top;
    MainFormInstance.Constraints.MaxWidth := 0;//r2.Right - r2.left;
    MainFormInstance.clientheight:=normalsize.y;
    MainFormInstance.ClientWidth:=normalsize.x;
    MainFormInstance.Constraints.MinHeight := 180;
  end else
  begin   //windowshare
    MainFormInstance.constraints.minheight := WindowShadeHeight;
    normalsize.x := MainFormInstance.ClientWidth;
    normalsize.y := MainFormInstance.clientheight;
    normalpos.x := MainFormInstance.Left;
    normalpos.y := MainFormInstance.top;
    clientHeight:=WindowShadeHeight;
    constraints.maxheight := WindowShadeHeight
  end
end;

procedure TMainForm.minibarDblClick(Sender: TObject);
begin
	SwitchMaximized
end;

procedure TMainForm.configClick(Sender: TObject);
begin
        configmenu.Popup(mouse.cursorpos.x, mouse.cursorpos.y)
end;

Function TMainForm.TabelSelCount : Integer;
Begin
        result := tabel.SelectedCount
end;

Function TMainForm.GetWinplayPlaying:PVirtualNode;
begin
     result := winplaylist.GetFirst;
     while result <> nil do
     begin
          if PplstRec(winplaylist.GetNodeData(result)).playing then
             break
          else result := winplaylist.GetNext(result)
     end
end;

procedure TMainForm.TabelDblClick(Sender: TObject);
var
	pp : integer;
  p: Pointer;
	aNode, pNode : PvirtualNode;
	listCleared, PlayExisting: Boolean;
begin
  MLClickTime := GetTickCount;
	aNode := tabel.GetFirstSelected;
	if aNode = nil then
  	exit;

	saveWinplayUndo;
	//Punch in
	if (pref.dblclick.ItemIndex in [3..4]) and (winplaylist.rootnodecount > 0) and not (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked) then
	begin
		winplaylist.beginupdate;
		pNode := GetWinplayPlaying;
		winplayInsert(GetRec(aNode), pNode, amInsertAfter, GetKill);
		if continuousPlay1.checked then
    	CheckConPlay;
    if pref.dblclick.ItemIndex = 4 then   {Punch In and Play}
		begin
			WinPlaySave(pNode.index+1);
      if playbackstatus(hwnd_winamp) = 3 then //paused
				button4(hwnd_winamp);
			button2(hwnd_winamp)
    end
		else
			WinPlaySave;
		winplaylist.endupdate;
		exit;  //skal vre der : )
	end;
	//Play
	winplaylist.beginupdate;
	if continuousPlay1.checked then
  	removeConPlay;

  pp := -1;
  PlayExisting := false;

	ListCleared := (pref.dblclick.ItemIndex = 0) and not (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked);

  if ListCleared and (pref.dblclick.ItemIndex = 0) and pref.dontAddIfExistsInWinplay.Checked and (tabel.SelectedCount = 1) then
  begin	//checker om noden der skal afspilles allerede er i winplaylist
    p := GetRec(aNode);
  	pNode := winplaylist.GetFirst;
  	while pNode <> nil do
    begin
    	if p = PplstRec(winplaylist.GetNodeData(pNode)).Rec then
      begin
      	pp := pNode.Index;
        PlayExisting := true;
        break
      end;
      pNode := Winplaylist.GetNext(pNode)
    end;
    ListCleared := pp = -1	//skal listen stadig cleares?
  end;

	if ListCleared then
		winplaylist.clear;

	if not PlayExisting then
  	while aNode <> nil do
		begin
			pp := winplayAdd(getrec(aNode), GetKill, not ListCleared).index;
    	aNode := tabel.GetNextSelected(aNode)
		end;

	if continuousPlay1.checked then
		CheckConPlay;

	if PlayExisting or ((pref.dblclick.ItemIndex = 2) and not (partyMode1.Checked and pref.AlwaysEnqueueToWP.Checked)) then
  	WinPlaySave(pp)
	else
  	WinPlaySave;

	winplaylist.endupdate;

	if (not (partyMode1.Checked and pref.AlwaysEnqueueToWP.Checked) and (pref.dblclick.itemindex <> 1)) or (partyMode1.Checked and pref.AlwaysEnqueueToWP.Checked and (playbackstatus(hwnd_winamp) <> 1)) then
  begin
    PlayWinamp;
{  	if playbackstatus(hwnd_winamp) = 3 then //paused
			button4(hwnd_winamp);
		button2(hwnd_winamp) //play  }
  end
end;

procedure TMainForm.UpdateCurrentTimeLabel(const UsePercent: Boolean; const Percent: Double=0);
var
	sec: Int64;                 
begin
	if UsePercent then
		sec := Round(Percent * SliderMax)
	else
		sec := getoutputtime(0, (hwnd_winamp));

  if (TimeViewMode = TWM_CountUp) or not FThumbTrackVisible then
		WinplaylistCurrentTimeLabel.Caption := IntTimeToStr(sec, true, false)
	else
	if TimeViewMode = TWM_Both then
		WinplaylistCurrentTimeLabel.Caption := IntTimeToStr(sec, true, false)  + '    -' + IntTimeToStr(SliderMax - sec, true, false)
	else
	if TimeViewMode = TWM_CountDown then
		WinplaylistCurrentTimeLabel.Caption := '- ' + IntTimeToStr(SliderMax - sec, true, false)
end;

procedure TMainForm.WaitForSliderTimer(SetSliderTimerRunning: Boolean=true);
begin
	while(SliderTimerRunning > 0) do
  	application.Processmessages;
  if SetSliderTimerRunning then
  	inc(SliderTimerRunning)
end;

procedure TMainForm.slidertimerTimer(Sender: TObject);
begin
	doSliderTimerTimer(nil)
end;

procedure TMainForm.doSliderTimerTimer(playingNode:PVirtualNode);
var
	Name,nametitle:String;
	Posi: LongInt;
	audioType:byte;
	i:integer;
	inlist,b, updatedOnce, needUpdate, wasStopped, updatePlayingTimeLabel, oldShuffle, oldRepeat : boolean;
  Flags: TRecFlags;
	art,ArtistSortOrder, tit,alb,com :string;
  PartOfSet, rating: Byte;
	track,TotalTracks,kbps, cha,yea,freq: Integer;
	duration : Cardinal;
	percent:double;
	Fsize:Cardinal;
	crc:LongWord;
	aNode, bNode : PvirtualNode;
	rec:PREC;
	pl : PplstRec;
	addQ:word;
	LastWriteTime:Integer;
  rectangle: TRect;
  cr: PCoverRec;
  playbackStat: Integer;
begin
  if(not MainFormInstance.enabled) then
    exit;

  if SliderTimerRunning > 0 then
    exit;
  inc(SliderTimerRunning);

  slidertimer.enabled := false;
  updatePlayingTimeLabel := false;

  if partymode1.checked and pref.PartyLimitMouse.Checked then
  begin
  	rectangle := MainFormInstance.BoundsRect;
  	ClipCursor(@rectangle)
  end;

  try	//kmpe try
			CheckAutoSkin;

      playbackStat := playbackstatus(hwnd_winamp);

			//Checker hvilken sang winamp spiller:
	 		if (SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH)=0) and (playbackStat <> 0) then
			begin
					 button4(hwnd_winamp);
					 posi := 0;
					 name := ''
			end
			else
			begin
					 if assigned(playingNode) then
					 begin
								posi := playingNode.index - deltaPlaylist;
								name := GetWinplayFilename(winplaylist.GetNodeData(playingNode))
					 end else
					 begin
								Posi := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
								name := pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTFILE));
								if pref.ControlPlaylist.checked and RepeatEnabled and (posi=0) and (deltaPlaylist=-1) then
									 posi := winplaylist.RootNodeCount
								else
                	if pref.ControlPlaylist.checked and RepeatEnabled and (Posi=WinampPlaylistRealCount-1) and (deltaPlaylist=winplaylist.RootNodeCount-WinampPlaylistRealCount+1) then
                  	posi := deltaPlaylist*-1
					 end
			end;
			if FoldPosi = -1 then
				 FoldPosi := Posi;

			if playbackStat = 0 then ///den er stoppet med at spille
			begin
				wasStopped := true;
				if sliderr.visible then
				begin
					sliderr.Visible := false;
					WinplaylistCurrentTimeLabel.Visible := false;

					if winplaylist.RootNodeCount = 1 then
					begin
						aNode := winplaylist.GetFirst;
						pl := winplaylist.getNodeData(aNode);
						if (pl.kill>0) and pl.Playing and (CurrentPlayPos > -1) and assigned(pl.Rec) and (pl.Rec.Length - CurrentPlayPos <= 3*slidertimer.Interval) then
						begin
              WinplayDequeue(aNode);
							winplaylist.DeleteNode(aNode);
							WinPlaySave
						end
					end
				end
			end
			else
			begin
        wasStopped := not sliderr.Visible;
        sliderMax:=GetOutPutTime(1, hwnd_winamp) * 1000;

        CurrentPlayPos := GetOutPutTime(0, hwnd_winamp);
        updatePlayingTimeLabel := playbackstat <> 3;
        if sliderMax > 0 then
        	percent := CurrentPlayPos / slidermax
        else
        	percent := 0;

        if not PlayingSongPlayCountIncreased and (percent > 0.80) then
        begin
          PlayingSongPlayCountIncreased := true;
          rec := FindInReclist(name);
          if assigned(rec) then
            inc(rec.PlayCount)
          end;

        try
          b := capturing or ptInRect(Rect(MainFormInstance.Left+sliderr.left, MainFormInstance.Top+sliderr.top,MainFormInstance.Left +sliderr.left+sliderr.Width,MainFormInstance.Top + sliderr.Height+sliderr.top),mouse.cursorpos)
        except
          //her giver der fejl hvis den er i partymode og der trykkes Ctrl+Alt+Del.
          //den skal derfor ikke prves i debug mode!
          b := false;
        end;

        if not b then
          UpdateCurrentTimeLabel(false);

        FThumbTrackVisible := sliderMax > 0;
        PaintSlider(percent,true, FThumbTrackVisible, capturing);

        sliderr.visible := true;
        WinplaylistCurrentTimeLabel.Visible := true
  		end;

			//Opdaterer playlist:
			oldRepeat := repeatEnabled;
			oldShuffle := shuffleEnabled;
			RepeatEnabled := boolean(SendMessage(hwnd_winamp, WM_WA_IPC, 0, 251));
			b := boolean(SendMessage(hwnd_winamp, WM_WA_IPC, 0, 250));

      if pref.ControlPlaylist.Checked then
      begin
	      if b then
	      begin
	      	shuffleEnabled := true;
					SendMessage(hwnd_winamp,WM_COMMAND,40023,0);	//skifter shuffle tilbage p disabled
	      end
      end
      else
				shuffleEnabled := b;

			if (oldRepeat <> RepeatEnabled) or (oldShuffle <> shuffleEnabled) or (GetVolume <> FPaintedVolume) then
				volbarPaint(nil, Canvas);

			if SongChangedInWinamp or WinPlayListChanged(name) then
				 updwinplaylist;
      SongChangedInWinamp := false;

      //Checker om ny sang afspilles
			if assigned(playingNode) or ((Posi<>FoldPosi) or not Q_sameText(name, Fcurplay) or (not (playbackStat in [0, 3]) and (trim(FCurPlayText) =''))) then
			begin  //Der afspilles en ny sang:
						 // Opdaterer Winplaylist
						 rec := nil;
						 needUpdate := false;
						 updatedOnce := false;
						 PlayingSongPlayCountIncreased := false;
						 WinPlayListTimeUntilPlayingNode := 0;
						 WinPlayListTimeTotal := 0;
						 CurrentPlayingIndex := 0;
						 updatePlayingTimeLabel := true;
						 aNode := Winplaylist.GetFirst;
						 while aNode <> nil do
						 begin
									pl := winplaylist.getNodeData(aNode);

                  //shuffleValue
                  if pl.shuffleValue > 0 then
                  	dec(pl.shuffleValue);

									if pl.Playing and (pl.kill>0) and not wasStopped and (posi+deltaPlaylist <> aNode.index) then    //fjerner den der blev spillet sidst, hvis den har kill
									begin
											 needUpdate := true;
											 if posi+deltaPlaylist>aNode.index then
													dec(posi);
											 bNode := Winplaylist.GetNext(aNode);
                       WinplayDequeue(aNode);
											 Winplaylist.DeleteNode(aNode);
											 aNode := bNode;
											 continue
									end;

                  if pref.ControlPlaylist.Checked then//and ShuffleEnabled then
                  	pl.Playing := Q_SameText(name, GetWinplayFilename(pl))
                  else
										pl.Playing := posi+deltaPlaylist = aNode.index;

									if pl.Playing then
									begin
                  	pl.shuffleValue := 255;      //strste vrdi
                    playingNode := aNode;

										if pref.FollowPlayingWA.Checked and (GetTickCount - WinplaylistClickTime > 500) then
										begin
                      Winplaylist.ScrollIntoView(aNode, true);
											TimeAtAutoFocusPlayingNodeInWinplaylist := GetTickCount
										end;
										WinPlayListTimeUntilPlayingNode := WinPlayListTimeTotal;
										CurrentPlayingIndex := aNode.Index +1
									end;

									if assigned(pl.Rec) then
										inc(WinPlayListTimeTotal, pl.Rec.Length)
									else inc(WinPlayListTimeTotal, pl.Seconds * 1000);

									// Hvis shuffle er enabled og der spilles en conplay-sang skal shuffle fjernes
									if ShuffleEnabled and pl.Playing and not pref.ControlPlaylist.Checked and (pl.kill = kill_conPlay) then
                  	SendMessage(hwnd_winamp,WM_COMMAND,40023,0);

									if pl.Playing and assigned(pl.Rec) then
                  begin
                    rec := pl.Rec;
                    if not Q_SameText(getFtextP(rec, fFilename), name) then
                    begin
                      if updatedOnce then
                      begin
                      	rec := nil;
                        aNode := winplaylist.getNext(aNode)
                      end
                      else
                      begin
                        updwinplaylist;
                        playingNode := nil;
                        rec := nil;
                        Posi := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
                        updatedOnce := true;
                        aNode := winplaylist.getfirst
                      end
                    end
                    else
                    	aNode := winplaylist.getNext(aNode)
                  end
                  else
                  	aNode := winplaylist.getNext(aNode)
						 end;

             //EnqueueNo
            if pref.ControlPlaylist.Checked and assigned(playingNode) then
      			begin
							pl := winplaylist.GetNodeData(playingNode);
              if pl.EnqueueNo = 1 then
              begin
              	aNode := winplaylist.GetFirst;
                while aNode <> nil do
                begin
									pl := winplaylist.GetNodeData(aNode);
		             	if pl.EnqueueNo > 0 then
		             	begin
                 		dec(pl.EnqueueNo);
              			winplaylist.InvalidateNode(aNode)
             			end;
                  aNode := Winplaylist.GetNext(aNode)
                end;
                AdjustWinplaylistEnqueueNoColumnWidth
              end
            end;
            //end of EnqueueNo

						 b := continuousPlay1.checked and checkConPlay(true);      //skal ALTID kres, derfor m den ikke vre i if needUpdate...

						 if pref.ControlPlaylist.checked then
						 begin
              if WinampPlaylistJustChangedByMEXP then
              begin
              	Posi := WinampPlaylistJustChangedByMEXPrealPos;
                if Posi >= 0 then
                	name := WinampPlaylistFiles[Posi]
              end
              else
              begin
								if shuffleEnabled then
             			Posi := ValidateWinplaylist(-1, playingNode)
              	else
	             		Posi := ValidateWinplaylist(Posi+deltaPlaylist, playingNode);
								name := pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTFILE))
              end
						 end
						 else
             	if needUpdate or b then
             		Winplaysave;

						 FOldPosi := Posi;
						 FcurPlay := name;
						 inlist := false;
						 for i:=0 to reclist.count-1 do
						 begin
									if (assigned(rec) and (rec = reclist.List^[i])) or (not assigned(rec) and Q_SameText(getFtextP(reclist.List^[i], ffilename),FcurPlay)) then
									begin
											 rec := reclist.List^[i];
											 //Checker om filen er ndret
//											 if playbackstatus(hwnd_winamp) <> 0 then
//													inc(rec.Playcount);	//bliver gjort lngere oppe...

											 if not AutoScanInProcess and fileexists(FcurPlay) then if rec.LastWriteTime <> FileAge(FcurPlay) then
											 begin
                       			flags := rec.flags;
                          	PartOfSet := rec.PartOfSet;
                            if readid3(nil, false, GetFTextP(rec, fScanPath), getFtextP(rec, fFilename),master_MyMusic, audioType, addQ, art,ArtistSortOrder,tit,alb,com, PartOfSet, Rating, yea,track,TotalTracks,kbps,cha,duration, Flags,Fsize,crc,freq,{ CreateTime,} LastWriteTime, dbs[rec.location].calculateCRC, cr, rec, false) then
														begin
                                 Inc(SafeToAutoScanCount);
                                 WaitForAutoScan;
                                 try
                                 	 BeginSetArtistAlbumFilename;
                                   try
                                     setArtist(rec, art, ArtistSortOrder);
                                     rec.AudioType := audioType;
                                     rec.addQuality := addQ;
                                     SetPCharString(rec.Title, tit);
//                                     rec.Title:= tit;
                                     rec.flags := flags;
                                     rec.Album:= GetAlbumID(alb);
                                     rec.Rating := Rating;
                                     rec.PartOfSet := PartOfSet;
                                     if (yea>=-1) and (yea<32767) then rec.Year:= yea else rec.Year := -1;
                                     rec.Comment:= com;
                                     if (track>=0) and (track<=high(word)) then rec.Track:= track else rec.Track := 0;
                                     if (TotalTracks>=0) and (TotalTracks<=high(word)) then rec.TotalTracks:= TotalTracks else rec.TotalTracks := 0;
                                     if (kbps > -32767) and (kbps < 32767) then rec.Kbps:= kbps else rec.kbps := 0;
                                     rec.Length := duration;
                                     if cha in [0 .. 4] then rec.Channels := Cha else rec.Channels := 4;//unknown
                                     // nej, denne skal gemmes! rec.Compilation := compilation;
                                     if (crc > low(cardinal)) and (crc < high(cardinal)) then
                                     	rec.CRC := crc
                                     else
                                     	rec.CRC := 0;
                                     rec.FSize := Fsize;
                                     rec.LastWriteTime := LastWriteTime;
                                     AddCoverRecToList(cr, rec);
//                                     rec.CreateTime := CreateTime;
                                     if (freq>=0) and (freq<=high(word)) then rec.khz := freq else rec.Khz := 0
                                   finally
	  																Dec(SafeToAutoScanCount);
                                    EndSetArtistAlbumFilename
                                   end
                            		except
                                end
														end;
											 end; //ikke ndret, fil existserer,
											 FCurPlayText := GetFtextP(rec, FartistTitle);
                       SetSystrayIconToolTip(FCurPlayText);
                       prepareCurPlayText(true, true);
                       MainFormInstance.Caption := FCurPlayText;
                       Include(rec.Flags, rfPlaying);
											 inlist := true
									end
									else
                  	Exclude(PRec(reclist.List^[i]).Flags, rfPlaying)
						 end;//for
						 winplaylist.repaint;

						 if pref.FollowPlayingML.Checked and (GetTickCount - MLClickTime > 500) then
						 begin
							aNode := tabel.GetFirstVisible;
							while aNode <> nil do
							begin
								if rfPlaying in GetRec(aNode).Flags then
								begin
                  tabel.ScrollIntoView(aNode, true);
									tabel.FocusedNode := aNode;
									break
								end;
								aNode := tabel.GetNextVisible(aNode)
							end
						 end;

						 if pref.AutoResizeColumnHeaders.Checked then
							AutoResizeAllColumnsToFit;
						 tabel.repaint;
						 if not inlist then
						 begin
							nametitle := Pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTTITLE));
							FCurPlayText := nametitle;
              SetSystrayIconToolTip(FCurPlayText);
              prepareCurPlayText(true, true);
              MainFormInstance.Caption := FCurPlayText
						 end;

						if pref.ShowCover.Checked then
            begin
            	if CoverThread.Runing then
              begin
                try
              		CoverThread.Thread.Terminate;
                	CoverThread.Thread.WaitFor
                except
                end
              end;
              coverThread.Start
            end
			end //of ny sang afspilles
      else
      	//Check om det er en http-stream etc. der afspilles. I s fald skal caption opdateres.
				if Q_PosStr('://', name)>0 then
        begin
          nametitle := Pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTTITLE));
          if not Q_SameStr(nameTitle, FCurPlayText) then
          begin
	        	FCurPlayText := Pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTTITLE));
	          SetSystrayIconToolTip(FCurPlayText);
	          prepareCurPlayText(true, true);
	          MainFormInstance.Caption := FCurPlayText;
	          winplaylist.invalidate
          end
        end;

      WinampPlaylistJustChangedByMEXP := false;	//nulstiller

			if updatePlayingTimeLabel then
				PaintPlayingTimeLabel(CurrentPlayPos);
			PaintFileInfoLabel;
      prepareCurPlayText(true, false);
	except
  	//gr ingenting hvis der er fejl!
  end;
  slidertimer.enabled := true;
  dec(SliderTimerRunning)
end;

{Procedure TMainForm.CheckForNewSong;
var       rec:Prec;
					Name,nametitle:String;
					Posi: LongInt;
					audioType:byte;
					cardinalPosi:Cardinal;
          i:integer;
          inlist,compilation,b, updatedOnce : boolean;
          art,tit,alb,com,s:string;
          track,kbps, sec,cha,yea,freq:integer;
          duration : Cardinal;
          percent:double;
          Fsize:Cardinal;
          crc, delta:integer; //delta bruges at slette kill nodes
					aNode, bNode : PvirtualNode;
          pl : PplstRec;
          addQ:word;
          CreateTime, LastWriteTime:TDateTime;
begin
     if (SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH)=0) and (playbackstatus(hwnd_winamp) <> 0) then
      begin
           button4(hwnd_winamp);
           posi := 0;
           name := ''
      end
			else
      begin
           Posi := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
           name := pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTFILE));
      end;
      //if SongChanged or ((not Q_sameText(name, curplay)) or ((playbackstatus(hwnd_winamp) <> 0) and (trim(curplaylabel.caption) =''))) then
      begin  //Der afspilles en ny sang:
             // Opdaterer Winplaylist

             rec := nil;
             if posi >=0 then cardinalPosi := posi else cardinalPosi := 0; //to prevent 64bit comparison
             updatedOnce := false;
             delta := 0;
             aNode := Winplaylist.GetFirst;
             while aNode <> nil do
             begin
                  pl := winplaylist.getNodeData(aNode);
                  if pl.Playing and (pl.kill>0) then
                  begin
                       inc(delta);
                       bNode := Winplaylist.GetNext(aNode);
                       Winplaylist.DeleteNode(aNode);
                       aNode := bNode;
                       continue
                  end;

                  pl.Playing := (posi>=0) and (cardinalPosi = aNode.index+delta);
                  if pl.Playing and assigned(pl.ref) then
                  begin
                       rec := pl.ref;
                       if not Q_SameText(getFtextP(rec, fFilename), name) then
                       begin
                            if updatedOnce then
                            begin
                                 rec := nil;
                                 aNode := winplaylist.getNext(aNode)
                            end
                            else
                            begin
                                 updwinplaylist;
                                 updatedOnce := true;
                                 aNode := winplaylist.getfirst
                            end
                       end else aNode := winplaylist.getNext(aNode)
                  end else aNode := winplaylist.getNext(aNode)
             end;

             curplay := name;
             inlist := false;
             application.processmessages;
             for i:=0 to reclist.count-1 do
             begin
                  if (assigned(rec) and (rec = reclist.items[i])) or (not assigned(rec) and Q_SameText(getFtextP(reclist.items[i], ffilename),curplay)) then
									begin
                       rec := reclist.items[i];
                       //Checker om filen er ndret
                       if playbackstatus(hwnd_winamp) <> 0 then inc(rec.Playcount);
											 application.processmessages;

                       if fileexists(curplay) then if rec.LastWriteTime <> FiledatetoDateTime(FileAge(curplay)) then
                       begin
                            if readid3(GetFTextP(rec, fScanPath), getFtextP(rec, fFilename),master_MyMusic, audioType, addQ, art,tit,alb,com,yea,track,kbps,cha,duration, compilation,Fsize,crc,freq, CreateTime, LastWriteTime, rec, false) then
                            begin
                                 setArtist(rec, art);
                                 rec.AudioType := audioType;
                                 rec.addQuality := addQ;
                                 rec.Title:= tit;
                                 rec.Album:= setAlbum(alb);
                                 if (yea>=-1) and (yea<32767) then rec.Year:= yea else rec.Year := -1;
                                 rec.Comment:= com;
                                 if (track>=0) and (track<=255) then rec.Track:= track else rec.Track := 0;
                                 if (kbps > -32767) and (kbps < 32767) then rec.Kbps:= kbps else rec.kbps := 0;
                                 rec.Length := duration;
                                 if cha in [0 .. 4] then rec.Channels := Cha else rec.Channels := 4;//unknown
                                 // nej, denne skal gemmes! rec.Compilation := compilation;
                                 if (crc > low(integer)) and (crc < high(integer)) then rec.CRC := crc else rec.CRC := -1;
                                 rec.FSize := Fsize;
                                 rec.LastWriteTime := LastWriteTime;
                                 rec.CreateTime := CreateTime;
                                 if (freq>=0) and (freq<=high(word)) then rec.khz := freq else rec.Khz := 0
                            end;
                       end; //ikke ndret, fil existserer,
                       curplaylabel.caption := GetFtextP(rec, Fartist) + ' - ' +  GetFtextP(rec, fTitle);
                       rec.Playing := true;
                       inlist := true
                  end
                  else
                      Prec(reclist.items[i]).playing := false
             end;//for

             if delta>0 then
                Winplaysave(true);
             winplaylist.repaint;
             tabel.repaint;
             application.processmessages;
             if not inlist then
             begin
                  nametitle := Pchar(SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_GETPLAYLISTTITLE));
                  curplaylabel.caption:= nametitle
						 end;
             if continuousPlay1.checked then CheckConPlay
      end; //of ny sang afspilles
      slidertimerTimer(nil)
end;
        }

Procedure TMainForm.updwinplaylist;
var       count:cardinal;
begin
  count := SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH);
  if pref.ControlPlaylist.checked and (count<>1) and not SongChangedInWinamp then
    DoUpdwinplaylistMEXPControlPlaylist(count)
  else DoUpdwinplaylist(count)
end;

procedure TMainForm.CopyFromRealWinampPlaylist;
var       count:cardinal;
begin
	count := SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH);
  DoUpdwinplaylist(count)
end;

Procedure TMainForm.DoUpdwinplaylist(count:cardinal);
const   FindInListLimit = 50000;
var     playingPos,x:integer;
        cardinalPos, toprow, filenr:cardinal;
        s, fn, s2:string;
        aNode, TN:pVirtualNode;
        PL:PplstRec;
        f:textfile;
        r:prec;
        added: Boolean;
begin
				deltaPlaylist := 0;
        TN := nil;
        if count = 0 then
        begin
             Winplaylist.clear
        end
        else
        begin
						 fileNr:=0;
             writeplaylist(hwnd_winamp);
						 PlayingPos := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
             if playingPos >= 0 then
             	cardinalPos := playingPos
             else
             	cardinalPos := high(cardinal);

             Filemode := 0;
             assignfile(f,winampdir + 'Winamp.m3u');
						 reset(f);

						 if winplaylist.topnode <> nil then
             	 TopRow := winplaylist.topnode.Index
             else
             	toprow := high(cardinal);

						 winplaylist.BeginUpdate;
             winplaylist.RootNodeCount := count;
						 aNode := Winplaylist.GetFirst;
             readln(f);
             while not eof(f) do
             begin
                  added := false;
                  readln(f,s);
									if Q_SameStrL(s, '#EXTINF', 7) then
                  begin
											 readln(f,fn);
                       if length(fn) = 0 then
                       	continue;
                       GetAbsoluteFilename(winampdir, fn);
                       PL := winplaylist.GetNodeData(aNode);
                       FillChar(PL^, sizeof(PL^), #0);
                       PL.Kill := GetKill;
                       PL.Playing := fileNr = cardinalPos; //to prevent 64bit comp
                       if filenr < FindInListLimit then
                       	r := findInRecList(fn)
                       else
                       	r := nil;
                       if assigned(r) then
                       begin
														PL.Rec := r
                       end else
                       begin
														pl.Text := Q_CopyFrom(s, Q_StrScan(s, ',')+1);
                            x:= Q_StrScan(s, ':');
                            s2 := Q_CopyRange(s, x+1, Q_StrScan(s, ',', x)-1);
                            if Q_IsInteger(s2) then
                            	x:=strToInt(s2)
                            else
                            	x:=0;
                            if (x>=0) and (x<=high(word)) then
                            	pl.Seconds := x
                            else
                            	pl.seconds := 0;
														pl.Filename := fn
                       end;
                       inc(filenr);
                       added := true
                  end
                  else
                  if length(s) > 0 then
                  begin
                       PL := winplaylist.GetNodeData(aNode);
                       FillChar(PL^, sizeof(PL^), #0);
                       PL.Kill := GetKill;
                       PL.Playing := fileNr = cardinalPos;
                       GetAbsoluteFilename(WinampDir, s);
                       if filenr < FindInListLimit then
                       	r := findInRecList(s)
                       else
                       	r := nil;
                       if assigned(r) then
                       begin
                            PL.Rec := r
                       end else
                       begin
                            pl.text := getFileName(s, false);
                            pl.filename := s
                       end;
                       inc(filenr);
                       added := true
                  end;
                  if added then
                  begin
	                  if aNode.Index = TopRow then TN := aNode;
	                  aNode := winplaylist.GetNext(aNode)
                  end
             end;

             closefile(f);
             if (toprow < high(cardinal)) and (TN <> nil) then winplaylist.TopNode := TN;
             if continuousPlay1.checked then
								if CheckConplay then
                begin
                     aNode := winplaylist.GetLast;
                     if assigned(aNode) then
                     begin
                          PL := winplaylist.GetNodeData(aNode);
													if assigned(PL.Rec) then
														 InsertFileToWinampPlaylist(getFtextP(pl.Rec, fFilename))
                          else InsertFileToWinampPlaylist(PL.filename)
                     end
								end;
						 winplaylist.endupdate;
             WinampPlaylistRealCount := count
        end
end;

Procedure TMainForm.doUpdwinplaylistMEXPControlPlaylist(count:cardinal);	//param: count er antallet af sange i den rigtige WA playlist
const   FindInListLimit = 50000;
var     playingPos,x, i, filesToSkip: Integer;
				cardinalPos, filenr:cardinal;
				s, fn, s2:string;
				aNode:pVirtualNode;
        PL:PplstRec;
				f:textfile;
        r:prec;
        enqueued, BrainPlayAdded: boolean;
//        files: TThreeStrings;
begin
  if count < WinampPlaylistRealCount then
  begin
	  WinampPlaylistRealCount := count;
	  doUpdwinplaylist(count)
  end
  else
  begin
//	  doValidateWinplaylist(-1, files);    //Henter files

	  fileNr:=0;

	  PlayingPos := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
    cardinalPos := PlayingPos;

	  aNode := Winplaylist.GetFirst;
	  i:=0;
	  while (i<deltaPlaylist) and assigned(aNode) do
	  begin
  	  aNode := winplaylist.GetNext(aNode);
	    inc(i)
	  end;

    enqueued := false;
    BrainPlayAdded := false;
    i:=0;
    while not enqueued and (i<count) and assigned(aNode) do
    begin
      fn := GetWinplayFilename(winplaylist.GetNodeData(aNode));

      //Check if the "Brain plugin" has added a song to the end of the list
      if (i = count-2) and Q_SameText(fn, BRAINFILENAME) and Q_SameText(pchar(SendMessage(hwnd_winamp, WM_WA_IPC, i+1, IPC_GETPLAYLISTFILE)), BRAINFILENAME) then
      begin
      	BrainPlayAdded := true;
      	WinplayInsertFname(pchar(SendMessage(hwnd_winamp, WM_WA_IPC, i, IPC_GETPLAYLISTFILE)), Winplaylist.GetLast, amInsertBefore, KILL_none);
        break
      end;

      if not Q_SameText(pchar(SendMessage(hwnd_winamp, WM_WA_IPC, i, IPC_GETPLAYLISTFILE)), fn) then
      if (i<WinampPlaylistRealCount) then
      	break	//break lkken - Enqueue bliver ikke sat - der skal kopieres fra den rigtige winamp playlist
      else
      	enqueued := true;
      aNode := winplaylist.GetNext(aNode);
      inc(i)
    end;
    SendMessage(hwnd_winamp, WM_WA_IPC, PlayingPos, IPC_GETPLAYLISTFILE);	//Skal vre der pga. fejl i winamp

    if not BrainPlayAdded and not assigned(aNode) and (i<count) then
    	enqueued := true;

    if enqueued or BrainPlayAdded then
    begin
      winplaylist.BeginUpdate;
      if continuousPlay1.checked then
      	RemoveConplay;

      if enqueued then
      begin
        //Der er blevet enqued nogle filer.. tilfj dem:
        //    Sg til hen i winamp.m3u hvor count er, og tilfj derfra...
        filesToSkip := WinampPlaylistRealCount;

        writeplaylist(hwnd_winamp);
        Filemode := 0;
        assignfile(f,winampdir + 'Winamp.m3u');
        reset(f);

        readln(f);
        while not eof(f) do
        begin
          dec(filesToSkip);
          readln(f,s);
          Q_TrimInPlace(s);

          if Q_SameStrL(s, '#EXTINF', 7) then
          begin
            readln(f,fn);
            if filesToSkip >= 0 then
              continue;
            Q_TrimInPlace(fn);
            GetAbsoluteFilename(WinampDir, fn);
            PL := winplaylist.GetNodeData(winplaylist.AddChild(nil));
            FillChar(PL^, sizeof(PL^), #0);
            PL.Kill := GetKill;
            PL.Playing := fileNr = cardinalPos; //to prevent 64bit comp
            if filenr < FindInListLimit then
              r := findInRecList(fn)
            else
              r := nil;

            if assigned(r) then
              PL.Rec := r
            else
            begin
              pl.Text := Q_CopyFrom(s, Q_StrScan(s, ',')+1);
              x:= Q_StrScan(s, ':');
              s2 := Q_CopyRange(s, x+1, Q_StrScan(s, ',', x)-1);
              if
                Q_IsInteger(s2)
              then
                x:=strToInt(s2)
              else
                x:=0;

              if (x>=0) and (x<=high(word)) then
                pl.Seconds := x
              else
                pl.seconds := 0;
              pl.Filename := fn
            end;
            inc(filenr)
          end
          else
          begin
            if filesToSkip >= 0 then
            	continue;
            PL := winplaylist.GetNodeData(winplaylist.AddChild(nil));
            FillChar(PL^, sizeof(PL^), #0);
            PL.Kill := GetKill;
            PL.Playing := false;//fileNr = cardinalPos;
            GetAbsoluteFilename(WinampDir, s);
            if filenr < FindInListLimit then
              r := findInRecList(s)
            else
              r := nil;

            if assigned(r) then
            begin
              PL.Rec := r
            end
            else
            begin
              pl.text := getFileName(s, false);
              pl.filename := s
            end;
            inc(filenr)
          end
        end;
        closefile(f)
      end;

      if continuousPlay1.checked then
      	CheckConplay;
      validateWinplaylist(PlayingPos+deltaPlaylist);
      winplaylist.endupdate
    end
    else
    begin
			DoUpdwinplaylist(count);
      ValidateWinplaylist(PlayingPos)
    end
  end
end;

{Procedure TMainForm.doUpdwinplaylistMEXPControlPlaylist(count:cardinal);
const   FindInListLimit = 50000;
var     playingPos,x, i, filesToSkip: Integer;
				cardinalPos, filenr:cardinal;
				s, fn, s2:string;
				aNode:pVirtualNode;
        PL:PplstRec;
				f:textfile;
        r:prec;
        enqueued:boolean;
        files: TThreeStrings;
begin
  if count < WinampPlaylistRealCount then
  begin
	  WinampPlaylistRealCount := count;
	  doUpdwinplaylist(count)
  end
  else
  begin
	  doValidateWinplaylist(-1, files);    //Henter files

	  fileNr:=0;

	  PlayingPos := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
    cardinalPos := PlayingPos;

	  aNode := Winplaylist.GetFirst;
	  i:=0;
	  while (i<deltaPlaylist) and assigned(aNode) do
	  begin
  	  aNode := winplaylist.GetNext(aNode);
	    inc(i)
	  end;

    enqueued := false;
    i:=0;
    while not enqueued and (i<Length(files)) and assigned(aNode) do
    begin
      if length(files[i]) > 0 then
	      enqueued := enqueued or not Q_SameText(files[i], GetWinplayFilename(winplaylist.GetNodeData(aNode)));
      aNode := winplaylist.GetNext(aNode);
      inc(i)
    end;

//    files.free;

    if enqueued then
    begin
      //Der er blevet enqued nogle filer.. tilfj dem:
      //    Sg til hen i winamp.m3u hvor count er, og tilfj derfra...
      filesToSkip := WinampPlaylistRealCount;

      winplaylist.BeginUpdate;
      if continuousPlay1.checked then
      	RemoveConplay;

      writeplaylist(hwnd_winamp);
      Filemode := 0;
      assignfile(f,winampdir + 'Winamp.m3u');
      reset(f);

      readln(f);
      while not eof(f) do
      begin
        dec(filesToSkip);
        readln(f,s);
        Q_TrimInPlace(s);

        if Q_SameStrL(s, '#EXTINF', 7) then
        begin
          readln(f,fn);
          if filesToSkip >= 0 then
            continue;
          Q_TrimInPlace(fn);
          PL := winplaylist.GetNodeData(winplaylist.AddChild(nil));
          FillChar(PL^, sizeof(PL^), #0);
          PL.Playing := fileNr = cardinalPos; //to prevent 64bit comp
          if filenr < FindInListLimit then
          	r := findInRecList(fn)
          else
          	r := nil;

          if assigned(r) then
          	PL.ref := r
          else
          begin
            pl.Text := Q_CopyFrom(s, Q_StrScan(s, ',')+1);
            x:= Q_StrScan(s, ':');
            s2 := Q_CopyRange(s, x+1, Q_StrScan(s, ',', x)-1);
            if
            	Q_IsInteger(s2)
            then
            	x:=strToInt(s2)
            else
            	x:=0;

            if (x>=0) and (x<=high(word)) then
            	pl.Seconds := x
            else
            	pl.seconds := 0;
            pl.Filename := fn
          end;
          inc(filenr)
        end
        else
        begin
          if filesToSkip >= 0 then
          	continue;
          PL := winplaylist.GetNodeData(winplaylist.AddChild(nil));
          FillChar(PL^, sizeof(PL^), #0);
          PL.Playing := false;//fileNr = cardinalPos;
          if filenr < FindInListLimit then
          	r := findInRecList(s)
          else
          	r := nil;

          if assigned(r) then
          begin
          	PL.ref := r
          end
          else
          begin
          	pl.text := getFileName(s, false);
            pl.filename := s
          end;
          inc(filenr)
        end
      end;
      closefile(f);

      if continuousPlay1.checked then
      	CheckConplay;
      validateWinplaylist(PlayingPos+deltaPlaylist);
      winplaylist.endupdate
    end
    else
			doUpdwinplaylist(count)
  end
end;        }

procedure TMainForm.sliderMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	slidertimer.enabled:=true
end;

procedure TMainForm.sliderMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	slidertimer.enabled:=false
end;

procedure TMainForm.FormShow(Sender: TObject);
procedure FixSelectionColors(vt: TVirtualStringTree);
begin
	if vt.colors.FocusedSelectionBorderColor <> vt.Colors.FocusedSelectionColor then
		vt.colors.FocusedSelectionBorderColor := vt.Colors.FocusedSelectionColor;
	if vt.colors.UnFocusedSelectionBorderColor <> vt.Colors.UnFocusedSelectionColor then
		vt.colors.UnFocusedSelectionBorderColor := vt.Colors.UnFocusedSelectionColor;
end;
begin
	if Assigned(FSnap) and not FSnap.Started then
  	FSnap.start;

	if not assigned(CurrentActiveForm) then
		CurrentActiveForm := MainFormInstance;

				FixSelectionColors(tabel);
				FixSelectionColors(tree);
				FixSelectionColors(winplaylist);
				FixSelectionColors(playlistbox);
				FixSelectionColors(plcon);
{        plcon.hint :=
				'Playlist Window' + #13 +
        'Drag files here to add them to the currently selected quicklist' + #13 +
        '(select or create a new quicklist in the quicklist selector above)' + #13 +
        'or to create a new one. ' + #13 +
        'To change the order of the files, select a song and hold ' + #13 +
        'down Ctrl while pressing "up" or "down" on the keyboard. To delete press delete';

        playlistbox.hint :=
        'Quicklist Selector' + #13 +
        'Click a quicklist to display its content in the list below.' + #13 +
        'Double-click to play in Winamp. Right-click for additional options';

        tree.hint :=
        'Database, Artist and Album Selector' + #13 +
        'Click a database, artist or album to display the songs in' + #13 +
        'the list below. Right-click for additional options';

        tabel.Hint :=
        'MP3 list list' + #13 +
        'Here all songs in the database are listed.' + #13 +
        'To play a song, doubleclick it. Rightclick for additional options.' + #13 +
        'The list also supports drag and drop, which means you can select' + #13 +
        'files in the list and drag them to the Playlist Window, Winamp,' + #13 +
        'Winamp playlist, Explorer and others.' + #13 +
        'To search for specific songs, make sure the MP3 list is focused' + #13 +
        'and type the search string. Use quotes (""), + and - operators.';    }

        case pref.DeOp.itemindex of
                0:searchlabel.caption := GetText(TXT_SearchOr);
                1:searchlabel.caption := GetText(TXT_SearchAnd)
        end;
				filterbarResize(sender);

				formresize(sender);
				checkdrives(false);
				try
          if f0.Focused then
          	FocusControl(tabel)
				except
				end;

	CheckBackgroundImage
end;

procedure TMainForm.Generalconfiguration1Click(Sender: TObject);
var
	 CurrentFormBackup : TForm;
	 MainFormVisible: Boolean;
begin
	if not DBinitiated then
		InitDB;

	MainFormVisible := MainFormInstance.Visible;
	disableAOT;
	CurrentFormBackup := CurrentActiveForm;
	CurrentActiveForm := pref;
	if pref.ShowModal = mrok then
	begin
		updatetree(false);
		createcolumns;
		filterbarResize(nil); //fixer lblMainListCount, GroupLabel samt F0
		Refresh1Click(nil);
	end;
	CurrentActiveForm := CurrentFormBackup;
	if MainFormVisible then
		SetMainFormVisible(true)
end;

Function TMainForm.WinplayFindRef(rec: PRec):PVirtualNode;
var      aNode:PVirtualNode;
         pl:PplstRec;
begin
     result := nil;
     if not assigned(rec) then
     	exit;
     aNode := Winplaylist.GetFirst;
     while aNode <> nil do
     begin
          pl := Winplaylist.GetNodeData(aNode);
					if (pl.rec = rec) and (pl.Kill <> kill_conPlay) then
          begin
               result := aNode;
               break
          end;
          aNode := Winplaylist.GetNext(aNode)
     end
end;

Function TMainForm.AllowedToAddMoreSongsToPlaylist: Boolean;
begin
	result := not (partyMode1.Checked and pref.KeepPlaylistAtMaximum.Checked and (winplaylist.RootNodeCount >= pref.KeepPlaylistAtNumber.value))
end;

Function TMainForm.WinplayAdd(rec: PRec; kill:byte; checkDupes:boolean=true):PVirtualNode;
var     PL:PplstRec;
        aNode, dupNode:PVirtualNode;
        playing:boolean;
begin
	if AllowedToAddMoreSongsToPlaylist then
  begin
				playing := false;
				if continuousPlay1.Checked and (kill <> Kill_ConPlay) then
        begin
             aNode := Winplaylist.GetLast;
             if assigned(aNode) and (PplstRec(Winplaylist.getNodeData(aNode)).kill = Kill_ConPlay) then
             begin
                  result := WinplayInsert(rec, aNode, amInsertBefore, kill);
                  exit
             end
        end;
				if checkDupes and ignoreDuplicates1.Checked and (kill<>kill_conPlay) then
        begin
             dupNode := WinplayFindRef(rec);
             if assigned(dupNode) then //der behves ikke at teste om kill=0, dette bliver gjort i winplayfindref
             begin
                  if pref.ignoreDuplicatesSettings.ItemIndex = 0 then
                  begin
                       result := dupNode;
                       exit
                  end else
                  begin
                       playing := PplstRec(Winplaylist.GetNodeData(dupNode)).playing;
                       WinplayDequeue(dupNode);
                       Winplaylist.DeleteNode(dupNode)
                  end
             end
        end;
        result := WinPlayList.AddChild(nil);
        pl := WinPlayList.GetNodeData(result);
        fillChar(pl^, sizeof(pl^), #0);
        pl.Playing := playing;
        pl.rec := rec;
        pl.Kill := kill
	end
end;

Function TMainForm.WinplayInsert(rec: PRec; Node :PvirtualNode; IM:TVTNodeAttachMode; Kill:byte; checkDupes:boolean=true):PVirtualNode;
var     PL:PplstRec;
        dupNode:PVirtualNode;
        playing:boolean;
begin
	if AllowedToAddMoreSongsToPlaylist then
  begin
        playing := false;
        if checkDupes and ignoreDuplicates1.Checked and (kill <> kill_conPlay) then
         begin
             dupNode := WinplayFindRef(rec);
             if assigned(dupNode) then //der behves ikke at teste om kill=0, dette bliver gjort i winplayfindref
             begin
                  if pref.ignoreDuplicatesSettings.ItemIndex = 0 then
                  begin
                       result := dupNode;
                       exit
                  end else
                  begin
                       playing := PplstRec(Winplaylist.GetNodeData(dupNode)).playing;
                       if dupNode=Node then
                       begin
                            if IM=amInsertBefore then
                            begin
                                 Node := winplaylist.GetNext(Node);
                                 if not assigned(Node) then
                                    IM:=amNowhere//fr den til at kre addchild(nil) i stedet
                            end else
                            if IM=amInsertAfter then
                            begin
                                 Node := winplaylist.GetPrevious(Node);
                                 if not assigned(Node) then
                                 begin
                                      Node := winplaylist.GetFirst;
                                      IM:= amInsertBefore
                                 end
                            end
                       end;
                       WinplayDequeue(dupNode);
                       Winplaylist.DeleteNode(dupNode)
                  end
             end
        end;
        if IM = amNowhere then result := WinPlayList.AddChild(nil) else result := Winplaylist.Insertnode(Node, IM);
        pl := WinPlayList.GetNodeData(result);
        fillChar(pl^, sizeof(pl^), #0);
        pl.Playing := playing;
				pl.rec := rec;
        pl.kill := kill
	end
end;

Function TMainForm.plCONadd(p:pointer):PVirtualNode;
var     PL:PplConRec;
begin
        result := plCon.AddChild(nil);
        pl := plCon.GetNodeData(result);
        fillChar(pl^, sizeof(pl^), #0);
        pl.rec := p
end;

Function TMainForm.plCONInsert(p:pointer; Node :PvirtualNode; IM:TVTNodeAttachMode):PVirtualNode;
var     PL:PplConRec;
begin
        if IM = amNowhere then result := plCon.AddChild(nil) else result := plCon.Insertnode(Node, IM);
        pl := plCon.GetNodeData(result);
        fillChar(pl^, sizeof(pl^), #0);
        pl.Rec := p
end;

Function TMainForm.plCONInsertFname(const fName:String; Node :PvirtualNode; IM:TVTNodeAttachMode; FindInDB:Boolean=true):PVirtualNode;
Function InsertFromFilename:PVirtualNode;
var     PL:PplstRec;
begin
     if IM = amNowhere then result := plCon.AddChild(nil) else result := plCon.Insertnode(Node, IM);
     pl := plCon.GetNodeData(result);
     fillChar(pl^, sizeof(pl^), #0);
     pl.text := getFileName(fname, false);
     pl.Filename := fName
end;
var     PL:PplConRec;
        p:pointer;
        rec:Prec;
begin
        if FindInDB then p := findInReclist(fName) else p := nil;
        if assigned(p) then
        begin
             rec := p;
             if IM = amNowhere then result := plCon.AddChild(nil) else result := plCon.Insertnode(Node, IM);
             pl := plCon.GetNodeData(result);
             pl.Text := getFtextP(rec, fArtist) + ' - ' + getFtextP(rec, fTitle);
             pl.seconds := IntTimeToSec(rec.Length);
             pl.Filename := getFtextP(rec, fFilename);
             pl.Rec := p
        end else result := InsertFromFilename
end;

Function TMainForm.WinplayInsertFname(const fName:String; Node :PvirtualNode; IM:TVTNodeAttachMode; kill:byte; FindInDB:Boolean=true ; checkDupes:boolean=true):PVirtualNode;
Function InsertFromFilename:PVirtualNode;
var     PL:PplstRec;
begin
     if IM = amNowhere then result := WinPlayList.AddChild(nil) else result := Winplaylist.Insertnode(Node, IM);
     pl := WinPlayList.GetNodeData(result);
     fillChar(pl^, sizeof(pl^), #0);
     pl.text := getFilename(fname, false);
     pl.Filename := fName
end;
var     PL:PplstRec;
        rec:Prec;
        dupNode:PVirtualNode;
        playing:boolean;
begin
	if AllowedToAddMoreSongsToPlaylist then
  begin
        if FindInDB then
        	rec := findInReclist(fname)
        else
        	rec := nil;
        if assigned(rec) then
        begin
						 playing := false;
             if checkDupes and ignoreDuplicates1.Checked and (kill <> kill_conPlay) then
             begin
                  dupNode := WinplayFindRef(rec);
                  if assigned(dupNode) then //der behves ikke at teste om kill=0, dette bliver gjort i winplayfindref
                  begin
                       if pref.ignoreDuplicatesSettings.ItemIndex = 0 then
                       begin
                            result := dupNode;
														exit
                       end else
											 begin
														playing := PplstRec(Winplaylist.GetNodeData(dupNode)).playing;
                            if dupNode=Node then
                            begin
                                 if IM=amInsertBefore then
                                 begin
                                      Node := winplaylist.GetNext(Node);
                                      if not assigned(Node) then
                                         IM:=amNowhere//fr den til at kre addchild(nil) i stedet
                                 end else
                                 if IM=amInsertAfter then
                                 begin
                                      Node := winplaylist.GetPrevious(Node);
                                      if not assigned(Node) then
                                      begin
                                           Node := winplaylist.GetFirst;
                                           IM:=amInsertBefore
                                      end
                                 end
                            end;
                            WinplayDequeue(dupNode);
                            Winplaylist.DeleteNode(dupNode)
                       end
                  end
             end;
             if IM = amNowhere then result := WinPlayList.AddChild(nil) else result := Winplaylist.Insertnode(Node, IM);
             pl := WinPlayList.GetNodeData(result);
             fillChar(pl^, sizeof(pl^), #0);
             pl.Rec := rec
        end
        else result := InsertFromFilename
  end
end;

Procedure TMainForm.WinPlaySaveToFile(const Filename:String;Run:Boolean=false; PlayPos:integer=-1);
// Hvis run er sand, loades listen til winamp
var     cds: TCOPYDATASTRUCT;
        FS:TStream;
        aNode:PvirtualNode;
        PL:PplstRec;
        PlayNodeIndex : integer;
        s:String;
        playingNodeSet : boolean;
begin
        PlayNodeIndex := -1;
        playingNodeSet := false;
        FS := TFileStream.Create(filename, fmCreate);
				s:= '#EXTM3U' + #13#10;
				FS.writeBuffer(pointer(s)^, length(s));
				aNode := WinPlayList.getfirst;
				while aNode <> nil do
        begin
        	pl := WinPlayList.GetNodeData(aNode);
          if assigned(pl.Rec) then
          	s := getFtextP(pl.Rec, Fextstr) + #13#10 + getFtextP(pl.Rec, fFilename) + #13#10
          else
          	s:= '#EXTINF' + ':' + inttostr(pl.Seconds) + ',' + pl.text + #13#10 + pl.Filename + #13#10;
          FS.writeBuffer(pointer(s)^, length(s));

          if (PlayPos>=0) and run then
          	pl.Playing := aNode.index = cardinal(playPos)
          else
          	if pl.Playing and run then
            	PlayNodeIndex := aNode.index;
          playingNodeSet := playingNodeSet or pl.Playing;
          aNode := WinPlaylist.GetNext(aNode)
        end;
        FS.free;
        if not playingNodeSet and (WinPlayList.GetFirst <> nil) then
           PplstRec(WinPlayList.GetNodeData(WinPlayList.GetFirst)).playing := true;

        if Run then
        begin
             deleteplaylist(hwnd_winamp);
             cds.dwData := IPC_PLAYFILE;
             cds.lpData := pchar(Filename);
             cds.cbData := strlen(cds.lpData) + 1; // include space for null char
             SendMessage(hwnd_winamp, WM_COPYDATA, 0, LongInt(@cds));
             if (PlayPos >= 0) and (cardinal(PlayPos) < WinPlayList.RootNodeCount) then
						 begin
									SendMessage(hwnd_winamp, WM_WA_IPC, PlayPos, IPC_SETPLAYLISTPOS);
                  fOldPosi := PlayPos
             end
             else if PlayNodeIndex >= 0 then
             begin
                  SendMessage(hwnd_winamp, WM_WA_IPC, PlayNodeIndex, IPC_SETPLAYLISTPOS);
                  fOldPosi := PlayNodeIndex
             end
             else button4(hwnd_winamp)
        end
end;

Function TMainForm.GetWinplayFilename(PL:Pointer):string;
begin
	if assigned(PplstRec(PL).Rec) then
  	result := getFtextP(PplstRec(PL).Rec, fFilename)
  else
  	result := PplstRec(PL).filename
end;

Procedure TMainForm.WinPlaySave(PlayPos:integer=-1);
begin
	WinampPlaylistJustChangedByMEXP := true;
	if pref.ControlPlaylist.checked then
  	ValidateWinplaylist(playPos)
  else
  begin
  	CheckBrainPlay;
  	WinPlaySaveToFile(winampdir + 'Winamp.m3u', true, PlayPos)
  end
end;

procedure TMainForm.CheckBrainPlay;
var
	aNode, brainNode: PVirtualNode;
begin
	brainNode := nil;
	aNode := Winplaylist.GetFirst;
  while aNode <> nil do
  begin
  	if Q_SameText(BRAINFILENAME, GetWinplayFileName(Winplaylist.GetNodeData(aNode))) then
    begin
    	if assigned(brainNode) then
      	winplaylist.DeleteNode(brainNode);
      brainNode := aNode
    end;
    aNode := winplaylist.GetNext(aNode)
  end;
  if assigned(brainNode) and assigned(brainNode.nextSibling) then
  	winplaylist.MoveTo(brainNode, Winplaylist.GetLast, amInsertAfter, false)
end;

Function TMainForm.ValidateWinplaylist(playPos:integer; const playingNode: PVirtualNode=nil):integer;
var
	i:integer;
begin
	WinampPlaylistJustChangedByMEXP := true;
  CheckBrainPlay;
  result := doValidateWinplaylist(playPos, WinampPlaylistFiles, playingNode);
  deleteplaylist(hwnd_winamp);
  for i:=0 to length(WinampPlaylistFiles)-1 do
  	if length(WinampPlaylistFiles[i]) > 0 then
  		InsertFileToWinampPlaylist(WinampPlaylistFiles[i]);
  WinampPlaylistJustChangedByMEXPrealPos := result;
  if result >= 0 then
  	SendMessage(hwnd_winamp, WM_WA_IPC, result, IPC_SETPLAYLISTPOS)
end;

function CompareShuffleValue(Item1, Item2: Pointer): integer;
begin
	result := PplstRec(Item1).ShuffleValue - PplstRec(Item2).ShuffleValue;
end;

//Returnerer positionen p den fil der spilles i den rigtige Winamp playlist
Function TMainForm.doValidateWinplaylist(playPos:integer; var files:TThreeStrings; playingNode: PVirtualNode=nil):integer;

function GetRandom(const randomList: TList; remove: boolean):PplstRec;
var
	i, zero: integer;
begin
	if randomList.Count > 0 then
  begin
  	zero := -1;	//sidste "instans af 0"
	  for i:=0 to randomList.Count-1 do
    	if PplstRec(randomList.Items[i]).shuffleValue = 0 then
      	zero := i
      else
      	break;

    if zero = -1 then
    	zero := randomList.Count-1;

    i := random(random(zero));
  	result := randomList.Items[i];
    randomList.Delete(i)
  end
  else
  	result := nil
end;

function AddFiles(CurrentlyPlayingNode:PVirtualNode):integer;
var
	aNode, bNode:PVirtualNode;
  EnqueueArr: array[1..255] of PplstRec;
  playIndex, before, after, i, r, EnqueueListCount, filesPos :integer;	//r er randomInt
  randomList: TList;
  shuffle: Boolean;
  pl: PplstRec;
begin
	FillChar(files, SizeOf(files), #0);
  EnqueueListCount := 0;

  //prepare random list
  if ShuffleEnabled then
  begin
  	shuffle := true;
    randomList := TList.Create;
  	randomList.Capacity := winplaylist.RootNodeCount;

		aNode := winplaylist.GetFirst;
    while aNode <> nil do
    begin
    	//enqueue kode:
      pl := winplaylist.GetNodeData(aNode);
      if pl.EnqueueNo > 0 then
      begin
      	EnqueueArr[pl.EnqueueNo] := pl;
    		if pl.EnqueueNo > EnqueueListCount then
        	EnqueueListCount := pl.EnqueueNo
      end;
      //eo enqueue kode
      randomList.Add(winplaylist.GetNodeData(aNode));
      aNode := winplaylist.GetNext(aNode)
    end;

    //shuffler dem der str lige
    for i:=randomList.Count downto 2 do
    	randomList.Exchange(i-1,random(i));
    randomList.Sort(CompareShuffleValue)
  end
	else
  	shuffle := false;
  //end of Prepare random list.

  if shuffle or RepeatEnabled then
  begin
  	before := 1;
    after := 1
  end
  else
  begin
    if CurrentlyPlayingNode.Index = 0 then  //frste node?
    	before := 0
    else
    	before := 1;
    if CurrentlyPlayingNode.Index = Winplaylist.RootNodeCount-1	then //sidste node?
    	after := 0
    else
    	after := 1
  end;

  playIndex := CurrentlyPlayingNode.Index;
  result := 0;
  filesPos := 0;

  aNode := CurrentlyPlayingNode;
  deltaPlaylist := aNode.index;

  //before
	if shuffle then
  begin         //shuffle
    for r:=randomList.Count - before-1 to randomList.Count-2 do
    	if r >= 0 then
      begin
	    	files[filesPos] := GetWinplayFilename(randomList.Items[r]);
        inc(filesPos);
        inc(result);
        dec(deltaPlaylist)
      end
  end
  else
  begin //ikke shuffle, men almindelig

  	for i:=1 to before do	//Spoler tilbage
    begin
      if aNode.index > 0 then
        aNode := winplaylist.GetPrevious(aNode)
      else
        break
    end;

    if RepeatEnabled and (before > CurrentlyPlayingNode.index-aNode.index) then
    begin
      bNode := winplaylist.GetLast;
      if bNode <> nil then
      begin
        files[filesPos] := GetWinplayFilename(winplaylist.GetNodeData(bNode));
        inc(filesPos);
        inc(result);
        dec(deltaPlaylist)
      end
    end;

    while aNode <> CurrentlyPlayingNode do
    begin
      files[filesPos] := GetWinplayFilename(winplaylist.GetNodeData(aNode));
      inc(filesPos);
      inc(result);
      dec(deltaPlaylist);
      aNode := winplaylist.GetNext(aNode)
    end;
  end;
  //eo before

  //playing node:
  files[filesPos] := GetWinplayFilename(winplaylist.GetNodeData(CurrentlyPlayingNode));
  inc(filesPos);
  FoldPosi := aNode.index-deltaPlaylist;

  //after
  if not shuffle then	//prepare Enqueue-list - hvis shuffle er ON er den allerede prepared
  begin
		bNode := winplaylist.GetFirst;
    while bNode <> nil do
    begin
			pl := winplaylist.GetNodeData(bNode);
      if pl.EnqueueNo > 0 then
      begin
      	EnqueueArr[pl.EnqueueNo] := pl;
    		if pl.EnqueueNo > EnqueueListCount then
        	EnqueueListCount := pl.EnqueueNo
      end;
    	bNode := winplaylist.GetNext(bNode)
    end
  end;

  for i:=1 to after do
    begin
      if EnqueueListCount >= i then
      begin
      	files[filesPos] := GetWinplayFilename(EnqueueArr[i]);
        inc(filesPos)
      end
      else
      if shuffle then
    	begin
    		files[filesPos] := GetWinplayFilename(GetRandom(randomList, true));
      	inc(filesPos)
    	end
      else
      begin
        aNode := winplaylist.GetNext(aNode);
        if not assigned(aNode) and RepeatEnabled then
        	aNode := winplaylist.GetFirst;
        if not assigned(aNode) then
          break;

        files[filesPos] := GetWinplayFilename(winplaylist.GetNodeData(aNode));
        inc(filesPos)
      end
    end;

  if shuffle then
  	randomList.Free;

  WinampPlaylistRealCount := filesPos;
end;

function GetRealPlayIndex:integer;
var      aNode:PvirtualNode;
begin
  result := playPos;
  if result < 0 then
  begin
  	if assigned(playingNode) then
    	result := playingNode.Index
    else
    begin
      aNode := winplaylist.GetFirst;
      while aNode <> nil do
      begin
        if PplstRec(winplaylist.GetNodeData(aNode)).playing then
        begin
          result := aNode.index;
          playingNode := aNode;
          break
        end
        else
          aNode := winplaylist.GetNext(aNode)
      end
    end
  end;
  if result < 0 then //playlistpos er ikke sat, alts skal den sttes til den frste sang (position 0). WinPlaylist.playing skal sttes til den frste sang
  begin
    result := 0;
    if WinPlaylist.GetFirst <> nil then
    	PplstRec(winplaylist.GetNodeData(winplaylist.GetFirst)).playing := true
  end
end;

//////////MAIN////
var
	aNode:PVirtualNode;
  i: Integer;
begin
  PlayPos := GetRealPlayIndex;	//Finder "playpos" i winplaylist - den virtuelle
  //opdaterer listen
  //sletter alle i listen:
  result := -1;

  if assigned(playingNode) then
  	result := addFiles(playingNode)
  else
  	if playPos < winplaylist.RootNodeCount then
    begin
		  aNode := winplaylist.GetFirst;
	    for i:=0 to playPos-1 do
      	aNode := winplaylist.GetNext(aNode);
     	result := addFiles(aNode)
    end
end;

procedure TMainForm.InsertFileToWinampPlaylist(const fn:String);
var       cds: TCOPYDATASTRUCT;
begin
     cds.dwData := IPC_PLAYFILE;
     cds.lpData := pchar(fn);
     cds.cbData := strlen(cds.lpData) + 1; // include space for null char
     SendMessage(hwnd_winamp, WM_COPYDATA, 0, LongInt(@cds));
end;

function TMainForm.GetKill: Byte;
begin
	if AutosetKillafterplay1.Checked or (PartyMode1.Checked and pref.AlwaysEnableKill.Checked) then
		result := kill_del
	else
		result := Kill_None
end;

procedure TMainForm.Play1Click(Sender: TObject);
var
  aNode, wNode:PVirtualNode;
  p: Pointer;
  pp: Integer;
begin
  MLClickTime := GetTickCount;

	aNode := tabel.getfirstselected;
	if aNode = nil then
		exit;

	if PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked and (playbackstatus(hwnd_winamp) <> 0) then
	begin
		Addselected1Click(sender);
		exit
	end;

	SaveWinplayUndo;

  pp := -1;
  if pref.dontAddIfExistsInWinplay.Checked and (tabel.SelectedCount = 1) then
  begin
    p := GetRec(aNode);
  	wNode := Winplaylist.GetFirst;
    while wNode <> nil do
    begin
    	if p = PplstRec(winplaylist.GetNodeData(wNode)).Rec then
      begin
      	pp := wNode.Index;
        break
      end;
      wNode := Winplaylist.GetNext(wNode)
    end
  end;

  winplaylist.beginupdate;

  if pp = -1 then
  begin
    winplaylist.clear;
    while aNode <> nil do
    begin
      WinPlayAdd(getRec(aNode), GetKill, false);
      aNode := tabel.GetNextSelected(aNode)
    end
  end;

	if continuousPlay1.checked then
		CheckConPlay;

  if pp = -1 then
  	WinPlaySave
  else
  	WinPlaySave(pp);

	winplaylist.endupdate;
  if playbackstatus(hwnd_winamp) = 3 then //paused
		button4(hwnd_winamp);
	button2(hwnd_winamp) //play)
end;

procedure TMainForm.voldwnClick(Sender: TObject);
begin
        volumedown(hwnd_winamp)
end;

procedure TMainForm.Addselected1Click(Sender: TObject);
var
	aNode :PvirtualNode;
begin
	SaveWinplayUndo;
	aNode := tabel.getfirstselected;
	winplaylist.BeginUpdate;
	while aNode <> nil do
	begin
		winplayadd(getRec(aNode), GetKill);
		aNode := tabel.getnextselected(aNode)
	end;
	if continuousPlay1.checked then
		CheckConPlay;
	WinPlaySave;
	winplaylist.endupdate
end;

procedure TMainForm.Addall1Click(Sender: TObject);
var
	i:integer;
begin
	UpdateSearchBools;
	screen.cursor:=crhourglass;
	SaveWinplayUndo;
	winplaylist.beginupdate;
	if fonlyPL then
		for i:=0 to Fplaylist.count-1 do
			WinPlayAdd(FPlaylist.items[i], GetKill)
	else
		for i:=0 to reclist.count-1 do
			if filterrec(reclist.List^[i]) then
				WinPlayAdd(reclist.List^[i], GetKill);

	if continuousPlay1.checked then
		CheckConPlay;
	WinPlaySave;
	winplaylist.endupdate;
	screen.cursor:=crdefault
end;

procedure TMainForm.Showplaylist1Click(Sender: TObject);
begin
        playlist(hwnd_winamp)
end;


Function TMainForm.GetRec(const node:PVirtualNode):Prec;
begin
	//result := PTreeData(tabel.getnodedata(PV))^.p
  result := PTreeData(integer(@node.Data) + 4).p
end;

Procedure TMainForm.SetRec(const node:PVirtualNode; const p:pointer);
begin
//	PTreeData(tabel.getnodedata(PV))^.p := p
	PTreeData(integer(@node.Data) + 4).p := p
end;

procedure TMainForm.TabelMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
	i:integer;
	State : TKeyboardState;
	s:string;
	rec:Prec;
  tagValues : TtagValues;
begin
	if Button = mbRight then
  	tabelMouseRightMouseButtonDown := true;

  tabelCurrentColumn := tabel.Header.Columns.ColumnFromPosition(point(x,1));

  if not (PartyMode1.Checked and pref.DisableTagging.Checked) and (tabelCurrentColumn = 24) and assigned(tabel.HotNode) then   //Rating
  begin
  	SetLength(tagValues, 1);
    tagValues[0].field := FRating;
    tagValues[0].value := inttostr(FHotNoteRatingValue[0]);
   	UpdateRecValues(GetRec(tabel.HotNode), tagValues, GetDefaultUpdateTags);
    winplaylist.Invalidate;
  end
  else
  begin
    GetKeyboardState(State);
    if button = mbRight then
    begin
      if ((State[vk_Control] and 128) <> 0) and (tabel.GetNodeAt(x,y,true,i) <> nil) then
      begin
        rec := getrec(tabel.GetNodeAt(x,y,true,i));
        s := GetFtextP(rec, tabel.header.columns[tabel.Header.Columns.ColumnFromPosition(Point(x,y),true)].tag);

        if s <> '' then
        begin
          dontfilter := true;
          if pos(s, f0.text) <> 0 then //skal trkke fra
          begin
            if pos('"' + s + '"', f0.text) <> 0 then
            begin
              if (pos('+"' + s + '"', f0.text) <> 0) or (pos('-"' + s + '"', f0.text) <> 0) then
                f0.text := copy(f0.text, 1, pos('"' + s + '"',f0.text) -2) + copy(f0.text, pos('"' + s + '"',f0.text) + length(s) +2, 511)
              else
                f0.text := copy(f0.text, 1, pos('"' + s + '"',f0.text)-1) + copy(f0.text, pos('"' + s + '"',f0.text) + length(s) +2, 511)
            end
            else
            begin
              if (pos('+' + s, f0.text) <> 0) or (pos('-' + s, f0.text) <> 0) then
                f0.text := copy(f0.text, 1, pos(s,f0.text) -2) + copy(f0.text, pos(s,f0.text) + length(s), 511)
              else
                f0.text := copy(f0.text, 1, pos(s,f0.text)-1) + copy(f0.text, pos(s,f0.text) + length(s), 511)
            end
          end
          else //der skal lgges til
          begin
            if ((State[vk_Shift] and 128) <> 0) then
            begin
              if f0.text = '' then
                f0.Text := '-"' + s + '"'
              else
                f0.Text := f0.text + ' -"' + s + '"';
            end
            else
            begin
              if f0.text = '' then
                f0.Text := '"' + s + '"'
              else
                f0.Text := f0.text + ' +"' + s + '"'
            end
          end;
          ApplyFilter
        end
      end
    end
  end
end;

procedure TMainForm.nxtMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	if button = mbRight then
  	NextPopUp.Popup(NextRect.Left, clientHeight - imgLowerLeft.Height + NextRect.Top)
  else
  if (ssAlt in Shift) or ((winplaylist.rootnodecount = 1) and not (ssShift in Shift)and not (ssCtrl in Shift)) then
		NextinMainlistAltClick1Click(nil)
  else
  if ssShift in Shift then
  	Fastforward5seconds1Click(nil)
  else
  if ssCtrl in Shift then
  	Endoflist1Click(nil)
  else
  	Next2Click(nil)
end;

procedure TMainForm.prevMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if button = mbRight then
  	PrevPopUp.Popup(PrevRect.Left, clientHeight - imgLowerLeft.Height + PrevRect.Top)
  else
  if (ssAlt in Shift) or ((winplaylist.rootnodecount = 1) and not (ssShift in Shift)and not (ssCtrl in Shift)) then
		PreviousinMainlistAltClick1Click(nil)
  else
  if ssShift in Shift then
  	Revind5seconds1Click(nil)
  else
  if ssCtrl in Shift then
  	Startoflist1Click(nil)
  else
  	PreviousClick1Click(nil)
end;

procedure TMainForm.FormResize(Sender: TObject);
var       r1, r2:Trect;
begin
	if rez then
		exit;

	getwindowrect(MainFormInstance.handle, r1);
	SystemParametersInfo(SPI_GETWORKAREA, 0, @r2, 0);
	winmaximized := (r1.Left=r2.Left) and (r1.Top=r2.Top) and (r1.Right=r2.Right) and (r1.Bottom=r2.Bottom);

	rez2 := true;

	if MainFormInstance.Height = WindowShadeHeight then //windowshade?
		exit;

	tabelpanel.top := 20;
	tabelpanel.left := 12;

	if MainFormInstance.ClientWidth > SmallWindowLimit then
	begin		//// Stor strrelse
		LowerSmallPanel.Visible := false;
    FCurPlayRect := rect(130, clientHeight-36, MainFormInstance.clientwidth - imgLowerRight.Width - 10, 0);

		tabelpanel.Height := clientheight - iUp.Height - imglowerleft.Height
	end else
	begin
		tabelpanel.Height := MainFormInstance.clientheight - 86;

		FCurPlayRect := rect(4, 2, LowerSmallPanel.clientWidth-4, FCurPlayRect.Bottom - FCurPlayRect.Top);

		LowerSmallPanel.Visible := true;
	end;

	prepareCurPlayText(false, true);

	//TABELPANEL:
	tabelpanel.Width := MainFormInstance.clientwidth - tabelPanel.Left - ImgRight.Width - 0;
	treepanel.Height := tabelpanel.height;
	if (listpanelheight>=0) and pref.aatw.checked then
		TabelBar.SetBounds(round((treepanel.width/listpanelheight) * tabelpanel.width), 0, 8, tabelpanel.height)
	else
		TabelBar.SetBounds(treepanel.width, 0, 8, tabelpanel.height);
	tabelpanellow.BoundsRect := rect(tabelbar.BoundsRect.right, 0, tabelpanel.Width, tabelpanel.Height);
	listpanelheight := tabelpanel.width;
	filterbar.Width := tabelpanellow.Width;

	if LowerSmallPanel.Visible then
		LowerSmallPanel.SetBounds(tabelPanel.Left, tabelPanel.BoundsRect.Bottom, tabelPanel.Width, 28);

	pbar.BoundsRect := rect(sliderr.left, sliderr.top, sliderr.Left + sliderr.width, sliderr.Top + sliderr.height);

	WPbar.Width := tabelpanellow.width;

	if MinimizeWinplay.caption = arrowup then
		WPbar.top := tabelpanellow.Height - WPbar.height;
	treeplbar.Width := treepanel.Width;
	treeplbar.Top := treepanellow.Height;

	if MainFormInstance.ClientWidth > SmallWindowLimit then
	begin
		sliderr.Parent := MainFormInstance;
		sliderr.SetBounds(PosSliderLrgPos.x, MainFormInstance.ClientHeight - PosSliderLrgPos.y, MainFormInstance.ClientWidth - PosSliderLrgPos.x - PosSliderLrgStopFromEnd, sliderr.Height)
	end
	else
	begin
		Sliderr.Parent := LowerSmallPanel;
		Sliderr.SetBounds(PosSliderSmallPos.x, PosSliderSmallPos.y, LowerSmallPanel.clientWidth - PosSliderSmallStopFromEnd, Sliderr.Height)
	end;

	UpdateSizesTreePanel(nil);
	UpdateSizesTreePanel(TabelBar);
	UpdateSizesTreePanel(treeplbar);
	UpdateSizesTreePanel(WPbar);
	UpdateSizesTreePanel(plconbar);

	CheckAllPositions;
	UpdateSizesTreePanel(nil);
	rez2 := false;
	if sliderTimer.enabled then
		sliderTimerTimer(nil);
	repaint
end;

{var
  AppMon, WinMon: HMONITOR;
  I, J: Integer;
  ALeft, ATop: Integer;
begin
    if (FDefaultMonitor <> dmDesktop) and (Application.MainFormInstance <> nil) then
		begin
      AppMon := 0;
      if FDefaultMonitor = dmMainForm then
        AppMon := Application.MainFormInstance.Monitor.Handle
      else if (FDefaultMonitor = dmActiveForm) and (Screen.ActiveCustomForm <> nil) then
        AppMon := Screen.ActiveCustomForm.Monitor.Handle
      else if FDefaultMonitor = dmPrimary then
        AppMon := Screen.Monitors[0].Handle;
      WinMon := Monitor.Handle;
			for I := 0 to Screen.MonitorCount - 1 do
				if (Screen.Monitors[I].Handle = AppMon) then
					if (AppMon <> WinMon) then
						for J := 0 to Screen.MonitorCount - 1 do
							if (Screen.Monitors[J].Handle = WinMon) then
							begin
                if FPosition = poScreenCenter then
                  SetBounds(Screen.Monitors[I].Left + ((Screen.Monitors[I].Width - Width) div 2),
                    Screen.Monitors[I].Top + ((Screen.Monitors[I].Height - Height) div 2),
                     Width, Height)
								else
              end;
		end;
end;  }

function TMainForm.GetMonitorRect(const form: TCustomForm):TRect;
var
	formCenter : TPoint;
	i:integer;
	monitorFound : boolean;
	r : TRect;
begin
	//finder formens center:
	 GetWindowRect(form.handle, r);
	 formCenter := point(((r.Right - r.Left) div 2) + r.Left, ((r.Bottom - r.Top) div 2) + r.Top);
	 //finder ud af hvilken monitor formens er p:
	 monitorFound := false;
	 for i:=0 to Screen.MonitorCount-1 do
	 if pointInRect(formCenter, rect(Screen.Monitors[i].Left, Screen.Monitors[i].Top, Screen.Monitors[i].Left + Screen.Monitors[i].Width, Screen.Monitors[i].Top + Screen.Monitors[i].Height)) then
	 begin
		monitorFound := true;
		result := rect(Screen.Monitors[i].Left, Screen.Monitors[i].Top, Screen.Monitors[i].Left + Screen.Monitors[i].Width, Screen.Monitors[i].Top + Screen.Monitors[i].Height)
	 end;
	 if not monitorFound then
		result := rect(form.Monitor.Left, form.Monitor.Top, form.Monitor.Left + form.Monitor.Width, form.Monitor.Top + form.Monitor.Height);

	 if not PartyMode1.Checked then
	 begin
		 //checker om startbaren skal skres vk
		 SystemParametersInfo(SPI_GETWORKAREA, 0, @r, 0);
		 if pointInRect(point(((r.Right - r.Left) div 2) + r.Left, ((r.Bottom - r.Top) div 2) + r.Top), result) then
			result := r
	 end
end;

procedure TMainForm.SwitchMaximized;
var
	 r, r2:Trect;
begin
  if MainFormInstance.clientheight = WindowShadeHeight then
  begin  //normalize
    MainFormInstance.clientheight:=normalsize.y;
    MainFormInstance.ClientWidth:=normalsize.x;
    MainFormInstance.Constraints.MinHeight := 180
  end;
  //gemmer paneler
  listpanelheight := tabelpanel.width;

  colrez := false;

  r := GetMonitorRect(MainFormInstance);
  getwindowrect(MainFormInstance.handle, r2);
  if (r.top=r2.top) and (r.left=r2.left) and (r.right=r2.right) and (r.bottom=r2.bottom) then
  begin
    {normalize}
    winmaximized := false;
		if beforemaximizepos.Top = 32767 then
    	beforemaximizepos.top := 50;
    setwindowpos(MainFormInstance.handle, HWND_TOP, beforemaximizepos.left, beforemaximizepos.top, beforemaximizepos.right - beforemaximizepos.left , beforemaximizepos.bottom - beforemaximizepos.top, SWP_NOZORDER)
  end
  else
  begin
  	{maximize}
	  winmaximized := true;
	  getwindowrect(MainFormInstance.handle, beforemaximizepos);
	  setwindowpos(MainFormInstance.handle, HWND_TOP, r.left, r.top, r.right - r.left , r.bottom - r.top, SWP_NOZORDER)
  end
end;

procedure TMainForm.PlayMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	if button = mbRight then
  	PlayPopup.Popup(PlayRect.Left, clientHeight - imgLowerLeft.Height + PlayRect.Top)
  else
  if ssShift in Shift then
  	OpenfileCtrlClick1Click(nil)
  else
  if ssCtrl in Shift then
  	OpenlocationShiftClick1Click(nil)
  else
  	Playrestaart1Click(nil)
end;

procedure TMainForm.StopMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
begin
	if button = mbRight then
  	StopPopup.Popup(StopRect.Left, clientHeight - imgLowerLeft.Height + StopRect.Top)
  else
  if ssShift in Shift then
  	StopwithFadeout1Click(nil)
  else
  if ssCtrl in Shift then
  	Stopaftercurrent1Click(nil)
  else
  	StopClick1Click(nil)
end;

procedure TMainForm.filtertimerTimer(Sender: TObject);
begin
  filtertimer.enabled := false;
  if pref.enablereset.checked and (not autoresettree.enabled) and pref.treeviceversa.checked and (trim(f0.text) <> '') then
  begin
    tree.ClearSelection;
    SetFilterFlags
  end;
  ApplyFilter;
  autoresettabel.enabled:=false;
  autoresettabel.enabled:=true;
  autoresettree.enabled:=false;
  autoresettree.enabled:=true
end;

procedure TMainForm.f0Change(Sender: TObject);
begin
	curf := 0;
	filtertimer.enabled := false;
	if not dontfilter then
		case pref.SearchMode.itemindex of
			0: filtertimertimer(sender);
			1: filtertimer.enabled := true
		end
end;


procedure TMainForm.BitBtn1MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	button3(hwnd_winamp)
end;

procedure TMainForm.BitBtn4MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	button4(hwnd_winamp)
end;

procedure TMainForm.aotClick(Sender: TObject);
begin
	aot.checked := not aot.checked;
	TSnapWin(FSnap.GetSnapWin(MainFormInstance.handle)).AlwaysOnTop := aot.Checked;
	restoreAOT
end;

procedure TMainForm.restoreAOT;
begin
		 if aot.checked then
        begin
					 with MainFormInstance do
									 SetWindowPos(Handle,
									 HWND_TOPMOST,
									 Left,
									 Top,
									 Width,
									 Height,
									 SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE);
				end
				else
				begin
						with MainFormInstance do
									 SetWindowPos(Handle,
									 HWND_NOTOPMOST,
									 Left,
									 Top,
									 Width,
									 Height,
									 SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE);
        end
end;

procedure TMainForm.disableAOT;
begin
		 with MainFormInstance do
		 SetWindowPos(Handle,
		 HWND_NOTOPMOST,
		 Left,
		 Top,
		 Width,
		 Height,
     SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE)
end;

procedure TMainForm.SaveselectedinPlaylist1Click(Sender: TObject);
var
   f:textfile;
   exists:boolean;
   aNode : PVirtualNode;
   rec:Prec;
   fn:string;
begin
     disableAOT;
     if showOpenDialog(GetText(TXT_SelectFileToSaveAppend), '', '', 'Playlist files (m3u, pls)|*.M3U;*.PLS', fn) then
     begin
          assignfile(f, fn);
          Filemode := 2;
          exists := fileexists(fn);
          if exists then append(F) else rewrite(f);
					if not exists then writeln(f,'#EXTM3U');
          aNode := tabel.getfirstselected;
          while aNode <> nil do
          begin
               rec := GetRec(aNode);
               writeln(f,getFtextP(rec, fextstr));
               writeln(f,getFtextP(rec, fFilename));
               aNode := tabel.GetNextSelected(aNode)
          end;
          closefile(f)
     end;
		 SetMainFormVisible(true)
end;

procedure TMainForm.Deletefilefromharddisk1Click(Sender: TObject);
procedure AddDelDir(dir:string; lst:TQ_StringList);
var       i:integer;
begin
     dir := MainFormInstance.CutBS(dir);
     while (length(dir)>0) and (Q_StrRScan(dir, '\') > 0) and not lst.find(dir, i) do
     begin
          dir := MainFormInstance.CutBS(dir);
          if directoryExists(dir) then
             lst.Add(dir)
          else break;
          dir := Q_CopyRange(dir, 0, Q_StrRScan(dir, '\')-2)
		 end
end;
var
        aNode, pNode: pVirtualNode;
        r:Prec;
        NextFocused:pointer;
        yPos, i:integer;
        DelDirs:TQ_StringList;
begin
  screen.Cursor := crappstart;
  Application.CreateForm(Tdeletefromhd, deletefromhd);
  deleteFromHD.DeleteEmtyDirs.Visible := true;
  deletefromhd.files.clear;
  yPos := tabel.OffsetY;
  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
     r := GetRec(aNode);
     deletefromhd.files.items.add(getFtextP(r, fFilename));
     aNode := tabel.getnextselected(aNode)
  end;
  screen.Cursor := crdefault;
  CurrentActiveForm := deleteFromHD;
  if deletefromhd.ShowModal = mryes then
  begin
     screen.Cursor := crhourglass;

     DelDirs := TQ_StringList.Create;
     DelDirs.Sorted := true;
     DelDirs.Duplicates := dupIgnore;

     aNode := tabel.GetFirstSelected;
     pNode := tabel.GetPreviousVisible(aNode);
     if assigned(pNode) then
     	NextFocused := GetRec(pNode)
     else
     	NextFocused := nil;

     while aNode <> nil do
     begin
        r := GetRec(aNode);
        if DeleteFromHd.DeleteEmtyDirs.Checked then
           AddDelDir(getFtextP(r, fFilePath), DelDirs);
        if isPlayingInWinamp(getFtextP(r, fFilename)) then
              button4(hwnd_winamp);
        if not fileexists(getFtextP(r, fFilename)) or FileDeleteRB(getFtextP(r, fFilename)) then
        begin
        	Include(r.Flags, rfDeletePending);
          pNode := aNode;
          aNode := tabel.getnextselected(aNode)
        end
        else
        begin
        	showmessageX(GetText(TXT_CouldNotDeleteFile, [#13 + getFtextP(r, fFilename)]) + #13 + SysErrorMessage(GetLastError));
          pNode := aNode;
          aNode := tabel.getnextselected(aNode)
        end
     end;
     if assigned(pNode) and not (rfDeletePending in GetRec(pNode).Flags) then
     		NextFocused := GetRec(pNode);
     ReleaseRecs(true, true);


     tabel.beginupdate;
     reclisttotabel(false, true);
     ShowHideNodes;
     tabel.OffsetY := yPos;
     if assigned(NextFocused) then
     begin
          aNode := tabel.GetFirstVisible;
          while aNode <> nil do
          begin
               if GetRec(aNode) = NextFocused then
               begin
                  tabel.FocusedNode := aNode;
                  break
               end;
               aNode := tabel.GetNextVisible(aNode)
          end
     end;
     tabel.endupdate;
     if DeleteFromHd.DeleteEmtyDirs.Checked then
     begin
          delDirs.Sorted := false;
          delDirs.CustomSort(sortStringsByLength);
          for i:=0 to delDirs.Count-1 do
              if not DirInAutoScanList(delDirs.strings[i]) then
                 removeDir(delDirs.strings[i])
     end;
     deldirs.Free
  end;
  CurrentActiveForm := nil;
  deletefromhd.release;
  freeandnil(deletefromhd);
  if pref.AutoResizeColumnHeaders.Checked then
  	AutoResizeAllColumnsToFit;
  SaveAllNoRelease(true);
  screen.cursor := crdefault
end;

procedure TMainForm.Selectall1Click(Sender: TObject);
begin
        tabel.SelectAll(true)
end;

procedure TMainForm.Removeallfilters1Click(Sender: TObject);
begin
  f0.text := '';
  filters.clear;
  ApplyFilter
end;

procedure TMainForm.FormActivate(Sender: TObject);
begin
  try
		if assigned(CurrentActiveForm) and (CurrentActiveForm <> MainFormInstance) and CurrentActiveForm.Visible then
			CurrentActiveForm.SetFocus
  except
  end
end;

function GetNextMenuItem(mi:TMenuItem; onlyVisible: boolean):TMenuItem;
begin
	result := nil;
	if (mi.Count >0) and (not onlyVisible or mi.Visible) then
		result := mi.items[0]  //first sub-menuitem
	else
	begin
		if mi.menuindex < mi.parent.count-1 then
			result := mi.parent.Items[mi.menuindex+1]
		else
		begin //vlger den nste efter parent
			while assigned(mi.Parent) do
			begin
				mi := mi.Parent;
				if assigned(mi.Parent) and (mi.menuindex < mi.parent.count-1) then
        begin
        	result := mi.parent.Items[mi.menuindex+1];
          exit
        end
      end;
      result := nil
		end
	end
end;

function TMainForm.CheckPopUpMenuFromKey(Sender: TObject; PopupMenu: TPopUpMenu; var Key: Word; Shift: TShiftState):Boolean;
function ShowEvenIfHidden(mi: TMenuItem): Boolean;
begin
	result := (mi = ToggleExpanded1)
end;
var
	mi: TMenuItem;
	sht: TShortCut;
begin
	result := false;

	if Assigned(PopupMenu.OnPopup) then
		PopupMenu.OnPopup(nil);

	sht := shortcut(key,shift);
	mi := PopupMenu.Items[0];
	while mi <> nil do
	begin
  	if (mi.shortcut = sht) then
		if (mi.visible or ShowEvenIfHidden(mi)) and mi.enabled then
		begin
			mi.OnClick(mi);
			result := true;
			break
		end;
		mi := GetNextMenuItem(mi, true)
	end
end;

procedure TMainForm.TabelKeyDown(Sender: TObject; var Key: Word;
	Shift: TShiftState);
begin
	if key = VK_TAB then
  	Winplaylist.SetFocus;

	if (key = 8) and (ssCtrl in Shift) then f0.text := '';

	if not CheckPopUpMenuFromKey(Sender, filesPopup, Key, Shift) then
		Globalshortcuthandle(key, shift)
end;

procedure TMainForm.FormClose(Sender: TObject;
  var Action: TCloseAction);
begin
	if pref.sit.Checked then
		action := caMinimize
	else
		action := caHide;
	if PartyMode1.Checked then
		Action := caNone
end;

{procedure TMainForm.sliderMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var     sl:integer;
        percent,i:double;
begin
     if ssleft in shift then
     begin
          i:= Psliderr.Width;
          sl := round(percent * i);
          if sl < 2 then sl :=2
     end
end;    }

procedure TMainForm.savess(Sender: Tobject);
var sl:Tstringlist;
Begin
        if f0.text = '' then exit;
        sl := Tstringlist.create;
        if fileexists(settingsdir + AppName + '.searches') then sl.LoadFromFile(settingsdir + AppName + '.searches');
        sl.Add(f0.text);
        sl.savetofile(settingsdir + AppName + '.searches');
        sl.free
End;

procedure TMainForm.delss(Sender: Tobject);
var
	sl:Tstringlist;
	i:integer;
Begin
	sl := Tstringlist.create;
  if fileexists(settingsdir + AppName + '.searches') then
  	sl.LoadFromFile(settingsdir + AppName + '.searches');
  for i:=0 to sl.Count-1 do
  	if (sender as Tmenuitem).caption =sl.strings[i] then
    begin
    	sl.delete(i);
      break
    end;
  sl.savetofile(settingsdir + AppName + '.searches');
  sl.free
End;

procedure TMainForm.loadss(Sender: Tobject);
Begin
	dontfilter := true;
  f0.text := (sender as Tmenuitem).caption;
  ApplyFilter
End;

procedure TMainForm.SearchInClick(Sender: TObject);
begin
	TMenuItem(Sender).Checked := not TMenuItem(Sender).Checked;
	pref.SearchInFields.Checked[TMenuItem(Sender).MenuIndex] := TMenuItem(Sender).Checked;
	filtertimertimer(sender)
end;

procedure TMainForm.lssPopup(Sender: TObject);
var
	sl:Tstringlist;
	i :integer;
	mi: Tmenuitem;
	miArr: array of TMenuItem;
begin
	lss.items.clear;
	lss.Items.Add(newitem(GetText(TXT_SaveCurrentSearchMask),0,false,true,savess,0,'savesstr'));

  SetLength(miArr, pref.SearchInFields.Items.Count);

  for i:=0 to pref.SearchInFields.Items.Count - 1 do
  	miArr[i] := newItem(pref.SearchInFields.Items[i], 0, pref.SearchInFields.Checked[i], true, SearchInClick, 0, 'SearchIn00' + IntToStr(i));

	lss.Items.Add(NewSubMenu(GetText(TXT_SearchIn), 0, 'searchin', miArr));

	mi := Tmenuitem.create(self);
	mi.Caption := GetText(TXT_Delete);
	lss.Items.Add(mi);
	lss.Items.Add(newitem('-',TextToShortCut(''),false,true,nil,0,'br1'));
	if fileexists(settingsdir + AppName + '.searches') then
	begin
		sl := Tstringlist.create;
		sl.LoadFromFile(settingsdir + AppName + '.searches');
		for i:=0 to sl.count-1 do lss.Items.Add(newitem(sl.strings[i],TextToShortCut(''),false,true,loadss,0,'item'+inttostr(i)));
		for i:=0 to sl.count-1 do mi.Add(newitem(sl.strings[i],TextToShortCut(''),false,true,delss,0,'item'+inttostr(i)));
		sl.free
	end;
	if mi.Count = 0 then lss.Items.Delete(2)
end;

procedure TMainForm.n(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	lss.Popup(mouse.CursorPos.x,mouse.CursorPos.y)
end;

procedure TMainForm.BitBtn6MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	filespopup.Popup(mouse.cursorpos.x,mouse.cursorpos.y)
end;

procedure TMainForm.Addselectedtonewplaylist1Click(Sender: TObject);
var
  f:textfile;
  aNode:pVirtualNode;
  rec:Prec;
begin
  disableAOT;
  if savedialog1.Execute then
  begin
    assignfile(f, savedialog1.filename);
    Filemode := 2;
    rewrite(F);
    writeln(f,'#EXTM3U');
    aNode := tabel.GetFirstSelected;
    while aNode <> nil do
    begin
      rec := getrec(aNode);
      writeln(f,getFtextP(rec, Fextstr));
      writeln(f,getFtextP(rec, Ffilename));
      aNode := tabel.getnextselected(aNode)
    end;
    closefile(f)
  end;
  SetMainFormVisible(true)
end;

function SortListByTrack(Item1, Item2: Pointer): Integer;
begin
     result := CompByte(Prec(Item1).track, Prec(Item2).track)
end;

procedure TMainForm.StopAndPlayFirst;
var       aNode:PvirtualNode;
begin
  button4(hwnd_winamp);
  button2(hwnd_winamp);
  aNode := winplaylist.GetFirst;
  if assigned(aNode) then
    PplstRec(winplaylist.GetNodeData(aNode)).playing := true
end;

procedure TMainForm.Playallsongsinthisfolder1Click(Sender: TObject);
var
	sortlist: Tlist;
	i: Integer;
begin
  SetFilterFlags;

  SaveWinplayUndo;
  winplaylist.beginupdate;
  winplaylist.clear;

  if fonlyPL then
  begin
  for i:=0 to Fplaylist.count-1 do
    WinPlayAdd(FPlaylist.items[i], GetKill, false)
  end else
  begin
    SortList:=Tlist.create;
    for i:=0 to reclist.count-1 do
      if filterrec(reclist.List^[i], true) then
        sortlist.add(reclist.List^[i]);

  //				SortList.Sort(SortListByTrack);
    for i:=0 to SortList.Count-1 do
        WinPlayAdd(SortList.List^[i], GetKill, false);
    SortList.free
  end;

  if continuousPlay1.checked then CheckConPlay;
  //WinPlaySave;
  winplaylist.endupdate;

  if shuffleEnabled then //shuffle
    WinplaySave(random(winplaylist.RootNodeCount))
  else
  Winplaysave;
  button4(hwnd_winamp);
  button2(hwnd_winamp)
end;

procedure TMainForm.Enqueallsongsinthisfolder1Click(Sender: TObject);
var
	sortlist:Tlist;
	i:integer;
begin
	SetFilterFlags;
	SaveWinplayUndo;
	winplaylist.beginupdate;

	if fonlyPL then
	begin
		for i:=0 to Fplaylist.count-1 do
			WinPlayAdd(FPlaylist.List^[i], GetKill)
	end else
	begin
		SortList:=Tlist.create;
		for i:=0 to reclist.count-1 do
			if filterrec(reclist.List^[i], true) then
				sortlist.add(reclist.List^[i]);

//		SortList.Sort(SortListByTrack);
		for i:=0 to SortList.Count-1 do
			WinPlayAdd(SortList.List^[i], GetKill);
		SortList.free
	end;
	if continuousPlay1.checked then
		CheckConPlay;
	WinPlaySave;
	winplaylist.endupdate
end;

procedure TMainForm.treeMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
	State : TKeyboardState;
//  hi: THitInfo;
//  tr: PTreeRec;
begin
{	tree.TreeOptions.MiscOptions := tree.TreeOptions.MiscOptions - [toFullRowDrag];
	//Is a coverImage clicked?
  tree.GetHitTestInfoAt(x, y, true, hi);
  if Assigned(hi.HitNode) then
  begin
    tr := tree.GetNodeData(hi.HitNode);
  	if assigned(tr.CoverRec) and pref.cbShowCoverInTree.Checked and not tree.IsEditing and
    	(tr.CoverRec.State = ImageLoaded) and not (crfInvalidateThumb in tr.CoverRec.Flags) and assigned(tr.CoverRec.Image) then
    	tree.TreeOptions.MiscOptions := tree.TreeOptions.MiscOptions + [toFullRowDrag];
  end; }

  //Remove filter?
	GetKeyboardState(State);
	if ((State[vk_Shift] and 128) <> 0) then
	begin
		dontfilter := true;
		f0.text := '';
		dontfilter := false
	end
end;

procedure TMainForm.Addlocation1Click(Sender: TObject);
var
  TitleName : string;
  lpItemID : PItemIDList;
  BrowseInfo : TBrowseInfo;
  DisplayName : array[0..MAX_PATH] of char;
  TempPath : array[0..MAX_PATH] of char;
  VolumeName, FileSystemName     : array [0..MAX_PATH-1] of Char;
  MaxComponentLength,FileSystemFlags    : Dword;

begin
	disableAOT;
	Application.CreateForm(Tdbpref, dbpref);

  dbPref.AddLocationForm := true;

	SetMainFormVisible(false);
  FillChar(BrowseInfo, sizeof(TBrowseInfo), #0);
  BrowseInfo.hwndOwner := dbpref.Handle;
  BrowseInfo.pszDisplayName := @DisplayName;
  TitleName := GetText(TXT_SpecifyDir);
  BrowseInfo.lpszTitle := PChar(TitleName);
  BrowseInfo.ulFlags := BIF_RETURNONLYFSDIRS;
  lpItemID := SHBrowseForFolder(BrowseInfo);
  if lpItemId <> nil then begin
    SHGetPathFromIDList(lpItemID, TempPath);
    dbpref.path.items.add(TempPath);
    dbpref.pathChange(nil);
    GlobalFreePtr(lpItemID);
  end else
  begin
  	SetMainFormVisible(true);
    FSnap.CheckAllSnaps;
    dbpref.release;
    FreeAndNil(dbpref);
		SetMainFormVisible(true);
    exit
  end;

	GetVolumeInformation(pchar(copy(temppath,1,3)),VolumeName,MAX_PATH,@VolumeSerialNo,MaxComponentLength,FileSystemFlags,FileSystemName,MAX_PATH);
  dbpref.name.text := volumename;
  if dbpref.name.text <> '' then
     dbpref.name.text := ansiuppercase(volumename)[1] + copy(ansilowercase(volumename),2,255);

  CurrentActiveForm := dbPref;
	dbpref.showmodal;
	CurrentActiveForm := nil;
  dbpref.release;
  FreeAndNil(dbpref);
  CurrentActiveForm := MainFormInstance;
	SetMainFormVisible(true);
  UpdateTree(false)
end;

Function TMainForm.GetPLboxFname(aNode:PVirtualNode):String;
begin
        forcedirectories(settingsdir + '-quicklist\TopList');
				result := settingsdir + '-quicklist\';
				if PPlBoxData(PlayListBox.GetNodeData(aNode))^.toplist then result := result + 'TopList\';
				result := result + PPlBoxData(PlayListBox.GetNodeData(aNode))^.text + '.m3u'
end;

procedure TMainForm.updateplaylist;
// Opdaterer playlisten i plCon
var     f:textfile;
        aNode:PVirtualNode;
        PR:PplConrec;
        rec:Prec;
begin
  if (playlistbox.selectedcount = 0) then exit;
  begin
     //if PPlBoxData(playlistbox.getNodeData(playlistbox.GetFirstSelected)).toplist then exit;
     assignfile(f,GetPLboxFname(playlistbox.getfirstselected));
     Filemode := 2;
     rewrite(f);
     writeln(f, '#EXTM3U');
     aNode := plcon.getfirst;
     while aNode <> nil do
     begin
        PR := plcon.getNodedata(aNode);
        if (PR.Rec = nil) and (length(PR.filename)>0) then
        begin
         writeln(f,'#EXTINF' + ':' + inttostr(PR.Seconds) + ',' + PR.text);
         writeln(f, PR.filename)
        end else
        begin
         rec := PR.Rec;
         writeln(f,getFtextP(rec, fExtStr));
         writeln(f,getFtextP(rec, fFilename))
        end;
        aNode := plcon.GetNext(aNode)
     end;
     closefile(f)
  end
end;

procedure TMainForm.updateplaylistbox;
        var     i:integer;
                aNode : PVirtualNode;
begin
        QuickListFF.RootDirectory := settingsdir + '-quicklist';
        QuickListFF.Files.Clear;
        QuickListFF.Search;
        playlistbox.BeginUpdate;
        playlistbox.Clear;
        if pref.toplist.checked then
                begin
                        aNode := playlistbox.AddChild(nil);
												PPlBoxData(PlayListBox.GetNodeData(aNode))^.text := 'Top ' + inttostr(pref.topnr.value) + ' list';
                        PPlBoxData(PlayListBox.GetNodeData(aNode))^.TopList := true
								end;

        for i:=0 to QuickListFF.Files.count -1 do
                begin
                        aNode := playlistbox.AddChild(nil);
                        PPlBoxData(PlayListBox.GetNodeData(aNode))^.text := copy(getfilename(QuickListFF.Files.strings[i]),1,length(getfilename(QuickListFF.files.strings[i]))-4);
                        PPlBoxData(PlayListBox.GetNodeData(aNode))^.TopList := false
                end;
        QuickListFF.Files.Clear;
        playlistbox.endupdate;
        playlistbox.SortTree(0, sdAscending)
end;

procedure TMainForm.filespopupPopup(Sender: TObject);
function SelectedIsAutoscanned: Boolean;
var
	aNode : PVirtualNode;
begin
	result := false;
	aNode := tabel.getFirstSelected;
  while aNode <> nil do
  begin
  	if rfAutoscanned in GetRec(aNode).Flags then
    begin
    	result := true;
      break
    end;
    aNode := tabel.GetNextSelected(aNode)
  end
end;
var
	i: Integer;
  inGroup: array of integer;
  aNode : PVirtualNode;
  mnu: TMenuitem;
  compilation: Boolean;
  rec: Prec;
begin
	Tags1.Visible := tabel.SelectedCount > 0;
	UpdateID3tag1.Visible := tabel.SelectedCount > 0;
	WriteId3v11.Visible := tabel.SelectedCount > 0;
	WriteId3v21.Visible := tabel.SelectedCount > 0;
	mniWriteAllSupportedTags.Visible := tabel.SelectedCount > 0;
	Deletefilefromharddisk1.Visible := tabel.SelectedCount > 0;
	DuplicateWizard1.Visible := tabel.SelectedCount > 0;
	Organizefiles2.Visible := tabel.SelectedCount > 0;
	CopyToMyMusic1.Visible := tabel.SelectedCount > 0;
	Deletefromplaylist1.Visible := tabel.SelectedCount > 0;
	TabelAddtoquicklist1.Visible := tabel.SelectedCount > 0;
	Punchin2.Visible := tabel.SelectedCount > 0;
	PlayAll.Visible := true;
  Explorer1.Visible := (tabel.SelectedCount = 1) and not PartyMode1.Checked;
  RemoveFromDatabase1.Visible := not (PartyMode1.Checked and pref.DisableDBmanagement.Checked);
  Savetoplaylist1.Visible := not PartyMode1.Checked;
	FillAddToSubMenu(TabelAddtoquicklist1);

	Changetracknumberto1231.Visible := tabel.selectedCount > 1;
	Removeallfilters1.shortcut := Clearfilter1.shortcut;
	Deletefromplaylist1.visible := fOnlyPL;
	CopyToMyMusic1.Caption := GetText(TXT_CopyToHD, [pref.harddisk.text]);
	CopyToMyMusic1.visible := canCopyToMyMusic;
	for i:=0 to pref.dblclick.items.count-1 do
  	DblClickoptions1.items[i].checked := i = pref.dblclick.ItemIndex;

	Tags1.Visible := Tags1.Visible and not (PartyMode1.Checked and pref.DisableTagging.Checked);
  RemoveAutoScannedflag1.Visible := Tags1.Visible and SelectedIsAutoscanned;
	UpdateID3tag1.Visible := UpdateID3tag1.Visible and not (PartyMode1.Checked and pref.DisableTagging.Checked);
	WriteId3v11.Visible := WriteId3v11.Visible and not (PartyMode1.Checked and pref.DisableTagging.Checked);
	WriteId3v21.Visible := WriteId3v21.Visible and not (PartyMode1.Checked and pref.DisableTagging.Checked);
	mniWriteAllSupportedTags.Visible := mniWriteAllSupportedTags.Visible and not (PartyMode1.Checked and pref.DisableTagging.Checked);

	Deletefilefromharddisk1.Visible := Deletefilefromharddisk1.Visible and not (PartyMode1.Checked and pref.DisableDeleteFromHD.Checked);

	DuplicateWizard1.Visible := DuplicateWizard1.Visible and not (PartyMode1.Checked and pref.DisableOrganizeDuplicateFiles.Checked);
	Organizefiles2.Visible := Organizefiles2.Visible and not (PartyMode1.Checked and pref.DisableOrganizeDuplicateFiles.Checked);

	CopyToMyMusic1.Visible := CopyToMyMusic1.Visible and not (PartyMode1.Checked and pref.DisableDeleteFromHD.Checked);

	Deletefromplaylist1.Visible := Deletefromplaylist1.Visible and not (PartyMode1.Checked and pref.DisableEditPlaylist.Checked);

	TabelAddtoquicklist1.Visible := TabelAddtoquicklist1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);

	Punchin2.Visible := Punchin2.Visible and not (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked);
  Enqueueandplay1.Visible := Punchin2.Visible;

	PlayAll.Visible := PlayAll.Visible and not (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked);

  if Tags1.Visible and not (PartyMode1.Checked and pref.DisableTagging.Checked) then
  begin
    //Determine group checkstate from selected files
    //0=unset, 1=Unchecked, 2=Checked, 3=Grayed
    compilation := true;
    setLength(inGroup, grouplist.Count);
		for i:=0 to length(inGroup)-1 do
    	inGroup[i] := 0;

    aNode := tabel.GetFirstSelected;
    while aNode <> nil do
    begin
    	rec := GetRec(aNode);

    	compilation := compilation and (rfCompilation in rec.Flags);

    	for i:=0 to length(inGroup)-1 do
      begin
      	if HasGroup(rec, i) then
        	inGroup[i] := inGroup[i] or 2
        else
        	inGroup[i] := inGroup[i] or 1
      end;
      aNode := tabel.GetNextSelected(aNode)
    end;

    //Add groups to menu
    Groups1.Clear;
    for i:=0 to length(inGroup)-1 do
    begin
      mnu := NewItem(PGroupRec(GroupList.items[i]).Name, 0, inGroup[i] = 2, true, Groups1SubItemClick, 0, 'groupSubMenu' + inttostr(i));
      mnu.Tag := i;
    	groups1.Add(mnu)
    end;
    Groups1.Visible := Groups1.Count > 0;
    Compilation1.Visible := true;
    Compilation1.Checked := compilation
  end
  else
  begin
  	Groups1.visible := false;
		Compilation1.Visible := false
  end;

	File1.Visible :=  HasVisibleChildren(File1);
end;

procedure TMainForm.Groups1SubItemClick(Sender: TObject);
var
	recs, valuesList, rollBackList: TList;
	values: PtagValues;
  aNode: PVirtualNode;
  addToGroup: boolean; 	///false = remove
  groupIndex: integer;
begin
	Screen.Cursor := crHourGlass;
  addToGroup := not Tmenuitem(sender).Checked;
  groupIndex := Tmenuitem(sender).tag;
	recs := TList.Create;
  valuesList := TList.Create;
  rollBackList := TList.Create;

  //Iterate nodes
  aNode := tabel.GetFirstSelected;
  while aNode <> nil  do
  begin
  	if HasGroup(GetRec(aNode), groupIndex) <> addToGroup then	//Do we need to change the group for this rec?
    begin
    	recs.Add(GetRec(aNode));

    	New(values);
      SetLength(values^, 1);
      if addToGroup then
	      values^[0].field := FAddGroup
      else
      	values^[0].field := FRemoveGroup;
      values^[0].value := PGroupRec(groupList.items[groupIndex]).Name;

      valuesList.Add(values);

      New(values);
      SetLength(values^, 1);
      if addToGroup then
	      values^[0].field := FRemoveGroup
      else
      	values^[0].field := FAddGroup;
      values^[0].value := PGroupRec(groupList.items[groupIndex]).Name;

      rollBackList.Add(values);
    end;
    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecValues(recs, valuesList, rollBackList, 'Tagging...', true, GetDefaultUpdateTags);

  tabel.invalidate;
  screen.cursor := crDefault
end;

{
procedure TMainForm.Addto1Click(Sender: TObject);
var       aNode :pVirtualNode;
begin
       plcon.beginupdate;
       aNode := tabel.getfirstselected;
       while aNode <> nil do
       begin
            plconAdd(getRec(aNode));
            aNode := tabel.getnextselected(aNode)
			 end;
				plcon.endupdate;
				updateplaylist
end;  }

procedure TMainForm.plboxpopupPopup(Sender: TObject);
begin
	LoadInWinamp1.Visible := true;
	Newplaylist1.Visible := true;
	Deleteplaylist1.Visible := true;
	RenameQuicklist1.Visible := true;

	Deleteplaylist1.visible := playlistbox.SelectedCount <> 0;
	RenameQuicklist1.Visible := playlistbox.SelectedCount <> 0;
	LoadinWinamp1.Visible := playlistbox.SelectedCount <> 0;
	EnqueueinWinamp1.Visible := playlistbox.SelectedCount <> 0;

	LoadinWinamp1.Visible := LoadinWinamp1.Visible and not (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked);

	Newplaylist1.Visible := Newplaylist1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);
	Deleteplaylist1.Visible := Deleteplaylist1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);
	RenameQuicklist1.Visible := RenameQuicklist1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);
end;

procedure TMainForm.LoadinWinamp1Click(Sender: TObject);
var
	aNode: PVirtualNode;
begin
	if playlistbox.selectedcount > 0 then
	begin
		Winplaylist.Beginupdate;
		SaveWinplayUndo;
		updateplaylist;
		Winplaylist.Clear;

		aNode := plCon.GetFirst;
		while aNode <> nil do
		begin
			PlConToWinPlaylist(plCon.GetNodeData(aNode), nil, amNowhere);
			aNode := plCon.GetNext(aNode)
		end;
		if shuffleEnabled then //shuffle?
			WinplaySave(random(plcon.RootNodeCount))
		else
			WinplaySave(0);
		Winplaylist.EndUpdate;
		button4(hwnd_winamp);
		button2(hwnd_winamp)
	end
end;

procedure TMainForm.playlistboxDblClick(Sender: TObject);
begin
	LoadinWinamp1Click(sender)
end;

procedure TMainForm.Deleteplaylist1Click(Sender: TObject);
begin
  if playlistbox.selectedcount = 0 then exit;
  if PPlBoxData(PlayListBox.GetNodeData(playlistbox.getfirstselected))^.TopList then
     showmessageX(GetText(TXT_CannotDeleteToplist));

  if YesNoBoxx('Delete Quicklist', 'Are you sure you want to delete the selected Quicklist?', GetText(TXT_Yes), GetText(TXT_No), 2) then
  begin
	  if fileexists(GetPLboxFname(playlistbox.getfirstselected)) then
    	FileDeleteRB(GetPLboxFname(playlistbox.getfirstselected));
	  plcon.clear;
	  updateplaylistbox
  end
end;

procedure TMainForm.Newplaylist1Click(Sender: TObject);
var     s:string;
        f:textfile;
        aNode : PVirtualNode;
begin
  s := '';
  if InputBoxx(GetText(TXT_EnterNewQLnameCaption), GetText(TXT_EnterNewQLnameText, ['\ / : * ? " < > |']), s) then
  begin
    Q_TrimInPlace(s);
    if QuicklistExists(s) then
    	ShowmessageX(GetText(TXT_QuicklistAlreadyExists, [s]))
    else
    begin
      aNode := playlistbox.AddChild(nil);
      PPlBoxData(PlayListBox.GetNodeData(aNode))^.text := s;
      PPlBoxData(PlayListBox.GetNodeData(aNode))^.TopList := false;
      assignfile(f, settingsdir + '-quicklist\' + s + '.m3u');
      Filemode := 2;
      rewrite(f);
      closefile(f);
      playlistbox.ClearSelection;
      playlistbox.Selected[aNode] := true
    end
  end
end;

procedure TMainForm.treepopPopup(Sender: TObject);

Procedure SetViewModesVisible(value: Boolean);
var
	i: Integer;
begin
	i := 0;
	while ViewModeMenuItem.Items[i] <> N1 do
  begin
  	ViewModeMenuItem.Items[i].Visible := value;
    inc(i)
  end
end;

function GetDatabaseLocation(node: PVirtualNode): integer;
begin
	result := -1;
  while node <> tree.rootnode do
  begin
   	if PTreeRec(tree.GetNodedata(node)).Kind in [TreeKind_Harddisk, TreeKind_Zip, TreeKind_CdRom, TreeKind_Network] then
    begin
    	result := PTreeRec(tree.GetNodedata(node)).Location;
      exit
    end;

  	node := node.Parent
  end;
end;

var
	tr:PTreeRec;
	TreeText: String;
  aNode:PvirtualNode;
  TreeKind : TtreeKind;
  commonKind : boolean;
  ReloadcoverVisible: Boolean;
  location: integer;
begin
	Tagging1.Visible := true;
	Addlocation1.Visible := true;
	Deleteselecteddatabase1.Visible := true;
	Rename1.Visible := true;
	Propertiesfor1.Visible := true;
	Organizefiles1.Visible := true;
	Scanforduplicates1.Visible := true;
	Addplaylist1.Visible := true;
	Deleteplaylist2.Visible := true;
	Playallsongsinthisfolder1.Visible := true;
  ReloadcoverVisible := false;

  SelecttherootofthecurrentdatabaseCtrlR1.shortcut := Selecttherootofthecurrentdatabase1.shortcut;
  if tree.selectedcount = 0 then
  begin
    Playallsongsinthisfolder1.visible := false;
    Enqueallsongsinthisfolder1.visible := false;
    SelecttherootofthecurrentdatabaseCtrlR1.visible := false;
    Deleteselecteddatabase1.visible := false;
    Propertiesfor1.visible := false;
    Scanforduplicates1.visible := true;
    TreeExchangeAristAlbum.Visible := false;
    rename1.Visible := false;
    Addplaylist1.visible := true;
    Deleteplaylist2.visible := false;
    SetViewModesVisible(not showmedia1.Checked or not pref.IndividualSO.Checked);
    Scanforchanges1.Visible := false;
    Playallsongsinselecteddatabase1.Visible := false;
    Removeselectedfromdatabase1.Visible := false;
  end else
  begin
    commonKind := true;
    aNode := tree.GetFirstSelected;
    TR := tree.GetNodeData(aNode);
    TreeKind := TR.Kind;
    while aNode <> nil do
    begin
      TR := tree.GetNodeData(aNode);
      commonKind := commonKind and ((TreeKind = TR.Kind) or ((TreeKind in [TreeKind_Zip, TreeKind_CdRom, TreeKind_Network]) and (TR.kind in [TreeKind_Zip, TreeKind_CdRom, TreeKind_Network])));
      ReloadcoverVisible := ReloadcoverVisible or (Assigned(tr.CoverRec) and (crfThumbnailVisible in tr.CoverRec.Flags));
      aNode := tree.GetNextSelected(aNode)
    end;

    Playallsongsinselecteddatabase1.Visible := showmedia1.Checked and commonKind and (TreeKind in [TreeKind_Zip, TreeKind_CdRom, TreeKind_Network, TreeKind_Artist, TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_YearAlbum, TreeKind_Genre, TreeKind_ArtistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_Drive, TreeKind_DriveRecursive, TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive, TreeKind_Year, TreeKind_Decade, TreeKind_Rating]);

    TreeExchangeAristAlbum.Visible := (tree.selectedCount=1) and (TR.kind in [TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_Artist, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_Year, TreeKind_Decade, TreeKind_Rating]) and (tree.selectedcount = 1);
		TreeText := GetTreeText(tree, tree.GetFirstSelected);
    if TreeExchangeAristAlbum.visible and (Q_PosStr(' - ', TreeText)>0) then
			TreeExchangeAristAlbum.Caption := GetText(TXT_ConvertToArtistAlbum, [Q_CopyRange(TreeText,1,Q_PosStr(' - ', TreeText)), Q_CopyFrom(TreeText, Q_PosStr(' - ', TreeText)+3)])
    else
    	TreeExchangeAristAlbum.Visible := false;

    Scanforduplicates1.visible := (tree.selectedcount = 1) and (TreeKind in [TreeKind_Harddisk, TreeKind_Zip, TreeKind_Network]);
    Playallsongsinthisfolder1.visible := true;
    Enqueallsongsinthisfolder1.visible := true;
    SelecttherootofthecurrentdatabaseCtrlR1.visible := showmedia1.checked;
    Deleteselecteddatabase1.visible := CommonKind and (TreeKind in [TreeKind_Zip, TreeKind_CdRom, TreeKind_Network]);
    Propertiesfor1.visible := (tree.selectedcount = 1) and (TR.Kind in [TreeKind_Harddisk, TreeKind_Zip, TreeKind_CdRom, TreeKind_Network]);
    rename1.Visible := (tree.selectedcount = 1) and (TR.Kind in [TreeKind_Harddisk, TreeKind_Zip, TreeKind_CdRom, TreeKind_Network]);

    ScanForChanges1.Visible := not ScanThread.Runing and (not partyMode1.Checked or not pref.DisableDBmanagement.Checked);

    Addplaylist1.visible := (tree.selectedcount = 1) and (TR.Kind in [TreeKind_Playlist, TreeKind_PlaylistParent]);
    Deleteplaylist2.visible := commonKind and (TreeKind = TreeKind_Playlist);
    Removeselectedfromdatabase1.Visible := not (TreeKind in [TreeKind_Playlist, TreeKind_PlaylistParent, TreeKind_GroupParent]) and not (PartyMode1.Checked and pref.DisableDBmanagement.Checked);

//    SetViewModesVisible(not showmedia1.Checked or not pref.IndividualSO.Checked or ((tree.selectedcount = 1) and (TR.Kind in [TreeKind_Harddisk, TreeKind_Zip, TreeKind_CdRom, TreeKind_Network])));

    location := GetDatabaseLocation(tree.GetFirstSelected);

    if not ShowMedia1.Checked and not pref.IndividualSO.Checked then
      location := 0;	//Select the first database

    if (length(dbs) > 0) and (not ShowMedia1.Checked or ((location >= 0) and (not pref.IndividualSO.Checked or ShowMedia1.Checked))) then
    begin
    	SetViewModesVisible(true);
      if location >= 0 then
	      setTreeViewModeMenuItem(dbs[location].TreeStructureIndex)
      else
      	setTreeViewModeMenuItem(dbs[0].TreeStructureIndex)
    end
    else
    	SetViewModesVisible(false);

{	  if pref.IndividualSO.Checked and ShowMedia1.Checked and (length(dbs) > 1) and (tree.selectedcount = 1) and (TR.Kind in [TreeKind_Harddisk, TreeKind_Zip, TreeKind_CdRom, TreeKind_Network]) then
			setTreeViewModeMenuItem(dbs[location].TreeStructureIndex)
    else
    	if not pref.IndividualSO.Checked or not ShowMedia1.Checked and (length(dbs) > 0) then
      	setTreeViewModeMenuItem(dbs[0].TreeStructureIndex)}
  end;

	Tagging1.Visible := Tagging1.Visible and not (PartyMode1.Checked and pref.DisableTagging.Checked);

	Addlocation1.Visible := Addlocation1.Visible and not (PartyMode1.Checked and pref.DisableDBmanagement.Checked);
	Deleteselecteddatabase1.Visible := Deleteselecteddatabase1.Visible and not (PartyMode1.Checked and pref.DisableDBmanagement.Checked);
	Rename1.Visible := Rename1.Visible and not (PartyMode1.Checked and pref.DisableDBmanagement.Checked);
	Propertiesfor1.Visible := Propertiesfor1.Visible and not (PartyMode1.Checked and pref.DisableDBmanagement.Checked);

	Organizefiles1.Visible := Organizefiles1.Visible and not (PartyMode1.Checked and pref.DisableOrganizeDuplicateFiles.Checked);
	Scanforduplicates1.Visible := Scanforduplicates1.Visible and not (PartyMode1.Checked and pref.DisableOrganizeDuplicateFiles.Checked);

	Addplaylist1.Visible := Addplaylist1.Visible and not (PartyMode1.Checked and pref.DisableEditPlaylist.Checked);
	Deleteplaylist2.Visible := Deleteplaylist2.Visible and not (PartyMode1.Checked and pref.DisableEditPlaylist.Checked);

	Playallsongsinthisfolder1.Visible := Playallsongsinthisfolder1.Visible and not (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked);

  Playallsongs1.Visible := not PartyMode1.Checked;
  Playallsongsinselecteddatabase1.Visible := not PartyMode1.Checked;

  Files1.Visible :=  HasVisibleChildren(Files1);
  Databases1.Visible := HasVisibleChildren(Databases1);
  Showcovers1.Checked := pref.cbShowCoverInTree.Checked;
  Reloadcover1.Visible := ReloadcoverVisible
end;

procedure TMainForm.Deleteselecteddatabase1Click(Sender: TObject);
var     i,x,q:integer;
        DBs2:Array of Trec2;
        tr:PTreeRec;
        PL : PplRec;
        r:Prec;
begin
  if tree.SelectedCount = 0 then
  	exit;

  tr := tree.GetNodeData(tree.getfirstselected);
  for i:=0 to length(dbs)-1 do
  	if dbs[i].name = TR.Text then
  	begin
		  if Application.MessageBox(pchar
			  (GetText(TXT_DeleteTheDatabase, [TR.text])),
			  Pchar(GetText(TXT_DeleteDatabase)),
			  MB_OKCANCEL + MB_DEFBUTTON1) <> IDOK then exit;

      screen.Cursor := crHourGlass;

      //Reclist
      for x:=0 to reclist.count-1 do
      begin
        r := reclist.List^[x];
        if r.Location = i then
          Include(r.Flags, rfDeletePending)
        else
          if r.Location > i
            then dec(r.Location) //rykker op i listen
      end;
      ReleaseRecs(false, true);

      //m3uList
      for x:=m3uList.count-1 downto 0 do
      begin
        PL := m3uList.Items[x];
        if PL.location = i then
        begin
          if assigned(PL.CacheRef) then
          begin
            setLength(PplCacheRec(PL.CacheRef).Cache, 0);
            dispose(PplCacheRec(PL.CacheRef))
          end;
          dispose(PL);
          m3uList.Delete(x)
        end
        else
          if PL.location > i then
            dec(PL.location)
      end;

			//dbs
			if fileexists(settingsdir + dbs[i].filename) then
		  	deletefile(settingsdir + dbs[i].filename);

	  	setlength(dbs2,length(dbs)-1);
		  q:=0;
      for x:=0 to length(dbs)-1 do
        if x<>i then
        begin
          dbs2[q] := dbs[x];
          q:=q+1
        end;
		  setlength(dbs, length(dbs2));
		  for x:=0 to length(dbs2)-1 do
		  	dbs[x] := dbs2[x];
	  	finalize(dbs2);

      break;	//Break for loop
  	end;
  RecListToTabel(true, true);
  updatetree(true);
  Screen.Cursor := crDefault
end;

procedure TMainForm.plconKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
	if key = 13 then
		plcondblclick(sender)
	else
		if (playlistbox.getFirstSelected <> nil) and not PPlBoxData(playlistbox.getNodeData(playlistbox.getfirstSelected)).toplist then
		begin
			if not CheckPopUpMenuFromKey(Sender, qlSongsPop, Key, Shift) then
				Globalshortcuthandle(key, shift)
		end
		else
		if (playlistbox.getFirstSelected <> nil) and PPlBoxData(playlistbox.getNodeData(playlistbox.getfirstSelected)).toplist then
			if not CheckPopUpMenuFromKey(Sender, TopListPop, Key, Shift) then
				Globalshortcuthandle(key, shift)
end;

procedure TMainForm.Updatetree1Click(Sender: TObject);
begin
	updatetree(false)
end;

procedure TMainForm.Collapseall1Click(Sender: TObject);
var     aNode:PvirtualNode;
begin
        tree.beginupdate;
        aNode := tree.GetFirst;
        while aNode <>nil do
                begin
                        tree.Expanded[aNode] := false;
                        aNode := tree.GetNext(aNode)
                end;
        tree.endupdate
end;

procedure TMainForm.Expandall1Click(Sender: TObject);
var     aNode:PvirtualNode;
begin
  tree.beginupdate;
  aNode := tree.GetFirst;
  while aNode <>nil do
  begin
    tree.Expanded[aNode] := true;
    aNode := tree.GetNext(aNode)
  end;
  tree.endupdate
end;

procedure TMainForm.Label1Click(Sender: TObject);
begin
{        if label1.Caption = ' r ' then
                begin
                        label1.caption := ' s ';
                        treepanellow.caption := inttostr(treepanellow.height);
                        treepanellow.height := panel1.height
                end else
                begin
                        label1.caption := ' r ';
                        if Q_IsInteger(treepanellow.caption) then  treepanellow.height := strtoint(treepanellow.caption) else treepanellow.height := 200
                end   }
end;

procedure TMainForm.CollapseButtonClick(Sender: TObject);
begin
        Collapseall1Click(sender)
end;

procedure TMainForm.AllButtonClick(Sender: TObject);
begin
	Selectnoneshowalldatabases1Click(sender)
end;

procedure TMainForm.EnqueueinWinamp1Click(Sender: TObject);
var
	aNode: PVirtualNode;
begin
	if playlistbox.selectedcount > 0 then
	begin
		Winplaylist.Beginupdate;
		SaveWinplayUndo;
		updateplaylist;

		aNode := plCon.GetFirst;
		while aNode <> nil do
		begin
			PlConToWinPlaylist(plCon.GetNodeData(aNode), nil, amNowhere);
			aNode := plCon.GetNext(aNode)
		end;

		WinplaySave;
		Winplaylist.EndUpdate
	end
end;

procedure TMainForm.treeKeyDown(Sender: TObject; var Key: Word;
	Shift: TShiftState);
	var
        aNode : PVirtualNode;
begin
	if key = VK_TAB then
		tabel.SetFocus
	else
	if key = VK_HOME then
	begin
  	if not assigned(tree.FocusedNode) then
    	exit;

		if showmedia1.checked and (tree.getnodelevel(tree.FocusedNode) > 0) then
			SelecttherootofthecurrentdatabaseCtrlR1Click(nil)
		else
		if showmedia1.checked and (tree.getnodelevel(tree.FocusedNode) = 0) then
		begin
			aNode := tree.focusednode;
			tree.Selected[aNode] := false;
			aNode := aNode.PrevSibling;
			if aNode = nil then
			begin   //Finder sidste node
				aNode := tree.GetFirst;
				while aNode.NextSibling <> nil do
					aNode := aNode.NextSibling
			end;
			if aNode <> nil then
			begin
				tree.FocusedNode := aNode;
				Tree.Selected[aNode] := true
			end
		end else //showmedia1 er ikke checked
		begin
			aNode := tree.focusednode;
			if aNode.Index > 0 then
			begin
				tree.Selected[aNode] := false;
				tree.FocusedNode := tree.GetFirstVisible
				end
			end
		end
		else
		if key = VK_END then
		begin
    	if not assigned(tree.FocusedNode) then
	    	exit;

			if showmedia1.checked and (tree.getnodelevel(tree.FocusedNode) > 0) then
			begin
				aNode := tree.focusednode;
				tree.Selected[aNode] := false;
				while (aNode <> nil) and (tree.GetNodeLevel(aNode) <> 0) do
					aNode := tree.GetNext(aNode);
				if aNode = nil then
					aNode := tree.GetFirstVisible;
				tree.FocusedNode := aNode;
				Tree.Selected[aNode] := true;
				tree.endupdate
			end
			else
			if showmedia1.checked and (tree.getnodelevel(tree.FocusedNode) = 0) then
			begin
				aNode := tree.focusednode;
				tree.Selected[aNode] := false;
				aNode := aNode.NextSibling;
				if aNode = nil then aNode := tree.GetFirst;
				if aNode <> nil then
				begin
					tree.FocusedNode := aNode;
					Tree.Selected[aNode] := true
				end
			end else //showmedia1 er ikke checked
			begin
				aNode := tree.focusednode;
				if aNode <> tree.GetLastVisibleChild(tree.rootnode.LastChild) then
				begin
					tree.Selected[aNode] := false;
					tree.FocusedNode := tree.GetLastVisibleChild(tree.rootnode.LastChild)
				end
			end
		end
		else
		if not CheckPopUpMenuFromKey(Sender, TreePop, Key, Shift) then
			Globalshortcuthandle(key, shift)
end;

procedure TMainForm.playlistboxKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
	if not CheckPopUpMenuFromKey(Sender, PLboxPopUp, Key, Shift) then
		Globalshortcuthandle(key, shift)
end;

procedure TMainForm.f0KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
		 if (key = VK_BACK) and (ssCtrl in shift) then
     begin
          f0.Text := '';
          key := 0;
          shift := []
		 end;
		 if key = VK_TAB then
			tabel.SetFocus else globalshortcuthandle(key,shift);

		 if key = VK_RETURN then
			if pref.SearchMode.ItemIndex = 2 then
				filtertimerTimer(sender)
			else
				case pref.EnterInSearchfield.ItemIndex of
					1: Playall1Click(nil); //efter nske fra DreamCool : )
					2: Addall1Click(nil)
				end
end;

procedure TMainForm.treeKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
  var     n:PVirtualNode;
begin
	if key = vk_escape then
	begin
		tree.beginupdate;
		n := tree.GetFirst;
		while n <> nil do
		begin
			tree.selected[n] := false;
			n:=tree.getnext(n)
		end;
		tree.endupdate;
		TreeFilter
	end
end;


procedure TMainForm.treeEnter(Sender: TObject);
begin
//	if treepanel.width < 2 then
//		treepanel.width := 200
end;

procedure TMainForm.RenameQuicklist1Click(Sender: TObject);
var newstring:string;
begin
  if playlistbox.selectedcount = 0 then
  	exit;
  if PPlBoxData(PlayListBox.GetNodeData(playlistbox.getfirstselected))^.TopList then
  begin
  	showmessageX(GetText(TXT_CannotRenameToplist));
    exit
  end;

  newString := '';
  if fileexists(settingsdir + '-quicklist\' + PPlBoxData(PlayListBox.GetNodeData(playlistbox.getfirstselected))^.text + '.m3u') then
  begin
  	if InputBoxx(GetText(TXT_RenameQuicklist), GetText(TXT_EnterNewQLnameText, ['\ / : * ? " < > |']), NewString) then
  	begin
  		if renamefile(settingsdir + '-quicklist\' + PPlBoxData(PlayListBox.GetNodeData(playlistbox.getfirstselected))^.text + '.m3u',settingsdir + '-quicklist\' + newstring + '.m3u') then
			  updateplaylistbox
      else
  			showmessageX(GetText(TXT_CouldNotRenameQL))
    end
  end
end;

Function TMainForm.CutBS(const s:string):String;
begin   //fjerner alle trailing \
	result := s;
  while (length(result)>0) and (result[length(result)] = '\') do
  	Q_CutRight(result, 1)
end;

function TMainForm.canCopyToMyMusic:boolean;
var      aNode:PvirtualNode;
begin
  aNode := tabel.GetFirstSelected;
  result := aNode <> nil;
  while (aNode <> nil) and result do
  begin
    result := result and (Prec(getRec(aNode)).location <> 0);
    aNode := tabel.GetNextSelected(aNode)
  end
end;

procedure TMainForm.CopyToMyMusic(Sender: TObject);
var     aNode:pVirtualNode;
        i, HDindex:integer;
        pattern, newFname, status:string;
        NRec:Prec;
        r:Prec;
        ProForm : TInputbox2;
begin
     if not canCopyToMyMusic then exit;
     pattern := trim(pref.MyMusicPattern.text);
     if length(pattern)=0 then exit;

     HDindex := -1;
     for i:=0 to length(dbs)-1 do
         if dbs[i].Media = media_harddisk then
            HDindex := i;

     if HDindex = -1 then exit;

     status := '';

     screen.cursor := crhourglass;

     showProcessDlg(GetText(TXT_CopyingFiles), tabel.SelectedCount, false, ProForm);

     aNode := tabel.GetFirstSelected;
     while aNode <> nil do
     begin
          r := getrec(aNode);
          if r.Location <> HDindex then
          begin
               newFname := FilenameFromPattern(r, pattern, '');
               if not fileExists(newFname) or YesNoBoxx(GetText(TXT_OverwriteFile), GetText(TXT_OverwriteFileAlreadyEx, [#13+ newFname + #13]), GetText(TXT_Yes), GetText(TXT_No), 2)  then
               begin
                    if forceDirectories(getFilePath(newFname)) then
                    begin
                    	if copyFile(pchar(getFtextP(r, fFilename)),pchar(newFname),false) then
                      begin
                        BeginSetArtistAlbumFilename;
                      	try
                              new(NRec);
                              fillChar(Nrec^, sizeOf(Nrec^), #0);

                              Nrec^.AudioType := r.AudioType;
                              setFilename(Nrec, newFname, true);
                              Nrec.Location := HDindex;
                              Nrec.DatabaseTime := DateTimeToFileDate(now);
                              Nrec.LastWriteTime := FileAge(newFname);

                              Nrec.flags := r.Flags;

                              Nrec.Artist := r.Artist;
                              Nrec.ArtistSortOrder := r.ArtistSortOrder;
                              SetPCharString(Nrec.Title, r.Title);
                              //NRec.Title := r.title;
                              Nrec.Album := r.Album;
                              Nrec.Year := r.Year;
                              Nrec.Comment := r.Comment;
                              NRec.Track := r.Track;
                              Nrec.TotalTracks := r.TotalTracks;
                              Nrec.Kbps := r.Kbps;
                              Nrec.Length := r.length;
                              Nrec.Channels := r.Channels;
                              Nrec.Playcount := r.playCount;
                              NRec.CRC := r.CRC;
                              Nrec.FSize := Nrec.Fsize;
                              Nrec.Khz := r.Khz;
                              Nrec.addQuality := r.addQuality;

                              setLength(Nrec.Genre, length(r.Genre));
                              for i:=0 to length(r.Genre)-1 do
                                  Nrec.Genre[i] := r.Genre[i];
                              setLength(Nrec.Groups, length(r.Groups));
                              for i:=0 to length(r.Groups)-1 do
                                  Nrec.Groups[i] := r.Groups[i];

                              reclist.Add(Nrec)
                        finally
                        	EndSetArtistAlbumFilename
                        end
                      end else Status := status + #13#13 + GetText(TXT_CouldNotCopyFromTo, [#13+getFTextP(r, fFilename) + #13, #13+ newFname])
               	end else Status := status + #13#13 + GetText(TXT_CouldNotCreateDirFileNodeCopied, [getFilePath(newFname) + #13])
						end else Status := status + #13#13 + GetText(TXT_FileCouldNotBeFound, [getFtextP(r, fFilename)])
          end;
          aNode := tabel.GetNextSelected(aNode);
          ProForm.Pbar.Position := ProForm.Pbar.Position +1;
          forceRepaint(ProForm)
     end;
     ProForm.release;
     FreeAndNil(ProForm);
     UpdateHashedReclist;
     RecListToTabel(true, true);
     treefilter;
     SaveAllNoRelease(true);
     screen.cursor := crdefault;
     if length(status)>0 then
     	showmessageX(Q_CopyFrom(status, 3), taLeftJustify	)
end;

procedure TMainForm.ShowTreewindow1Click(Sender: TObject);
begin
	treepanel.width := 200
end;

procedure TMainForm.MinimizeQ2Click(Sender: TObject);
begin
        if MinimizeQ2.caption = arrowdown then
        begin
             MinimizeQ2.caption := arrowup;
             plconbar.tag := plconbar.top;
             plconbar.Top := treepanel.height - plconbar.Height;
             UpdateSizesTreePanel(plconbar)
        end else
        begin
             MinimizeQ2.caption := arrowdown;
             if (plconbar.tag < treepanel.height) and (plconbar.tag > treeplbar.Top + treeplbar.height) then plconbar.top := plconbar.tag else plconbar.top := treepanel.height - plconbar.height - 50;
						 UpdateSizesTreePanel(plconbar)
        end
end;

{procedure TMainForm.MySaveToTree(tree: TVirtualStringTree; Str: TStream);
procedure AddStr(const s: String);
begin
	if length(s) > 0 then
  	Str.Write(s[1], length(s))
end;
const
	header = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">' + #13#10 + '<html>' + #13#10 + '<body>' + #13#10 + '<table width="100%" border="0" cellspacing="0" cellpadding="0">' + #13#10;
  footer = '</table>' + #13#10 + '</body>' + #13#10 + '</html>';
  tr = '<tr>';
  td = '<td>';
  EndTR = '</tr>';
  EndTD = '</td>';
var
	aNode: PVirtualNode;
  columns: array of Integer;
  column: TColumnIndex;
  i: Integer;
  ws: WideString;
begin
	//genererer columns
  if (tree.Header.Columns.Count > 0) then
  begin
    SetLength(columns, 0);
  	column := tree.Header.Columns.GetFirstVisibleColumn;
    while Column >= 0 do
    begin
    	SetLength(columns, length(columns)+1);
      columns[length(columns)-1] := column;
      column := tree.Header.Columns.getNextVisibleColumn(column)
    end;
  end
  else
  begin
  	setLength(columns, 1);
    columns[0] := 0
  end;

  AddStr(Header);

  if hoVisible in tree.Header.Options then
  begin

  end;

  //skriver nodes
  aNode := tree.GetFirstVisible;
  while aNode <> nil do
  begin
  	AddStr(tr);
  	for i:=0 to length(columns)-1 do
    begin
    	tree.OnGetText(tree, aNode, columns[i], ttStatic, ws);
      AddStr(td + ws + EndTD)
    end;
    aNode := tree.GetNextVisible(aNode)
  end;
	AddStr(footer)
end;
               }

procedure TMainForm.SavetoHTML1Click(Sender: TObject);
var
	f:TStream;
  s:string;
begin
  disableAOT;
  if savedialog2.Execute then
    if savedialog2.FilterIndex = 1 then
    begin
      screen.cursor := crhourglass;
      application.processmessages;
      s := tabel.ContentToHTML(tstVisible);
      s := #239 + #187 + #191 + s;    //Ellers vises visse filer ikke rigtigt i explorer
      f := TFileStream.create(savedialog2.filename, fmCreate);
      f.write(s[1], length(s));
      f.free;
      screen.cursor := crDefault
    end;
  SetMainFormVisible(true)
end;

procedure TMainForm.CDEvents1AfterArrival(Sender: TObject);
begin
	checkdrives(false)
end;

procedure TMainForm.Propertiesfor1Click(Sender: TObject);
var
	i, x:integer;
  TR:PTreeRec;
begin
  disableAOT;
  TR := tree.getNodeData(tree.getfirstselected);
  if TR.Kind = TreeKind_Harddisk then
  begin
    SetMainFormVisible(false);
    pref.PC.ActivePage := pref.TSMyMusic;
    Generalconfiguration1Click(sender)
  end else
  begin
		Application.CreateForm(Tdbpref, dbpref);
   	dbpref.AddLocationForm := false;
   	for i:=0 to length(dbs)-1 do
   		if dbs[i].name = TR.text then
      begin
        dbpref.name.text := dbs[i].name;
        dbpref.CalcCRCcb.Checked := dbs[i].calculateCRC;
        dbpref.repairVBRCB.Checked := dbs[i].repairVBR;
        for x:=0 to length(dbs[i].paths)-1 do
          dbpref.path.items.add(dbs[i].paths[x]);
        for x:=0 to length(dbs[i].excl)-1 do
          dbpref.excl.items.add(dbs[i].excl[x]);
        dbpref.recsub.checked := dbs[i].recursive;
        dbpref.Cpanel.selectioncolor := dbs[i].color;
        dbpref.cbUseCustomColor.Checked := dbs[i].UseCustomColor;
        if dbs[i].media = media_cdrom then dbpref.readonly.checked := true else
        if dbs[i].media = media_network then dbpref.network.Checked := true else
         dbpref.notreadonly.checked := true;
        dbpref.caption := 'Properties for ' + dbs[i].name;
        if dbs[i].exists then
        	dbpref.loadinglabel.caption :=''
        else
        	dbpref.loadinglabel.caption := GetText(TXT_DeviceNotPresentDontScan);
        CurrentActiveForm := dbPref;
        dbpref.showmodal;
        break // breaker lkken.
   		end;
  	CurrentActiveForm := nil;
  	dbpref.release;
  	FreeAndNil(dbpref)
  end;
  SetMainFormVisible(true)
end;

function TMainForm.PlConToWinPlaylist(const pPC:Pointer; const targetNode:PVirtualNode; const IM:TVTNodeAttachMode):PVirtualNode;
var
	WP: PplstRec;
	PC: PplConRec;
begin
	PC := pPC;
	result := WinplayInsert(PC.Rec, targetNode, IM, GetKill);
	if assigned(result) and not assigned(PC.Rec) then
	begin
		WP := WinPlayList.GetNodeData(result);
		WP.Filename := PC.Filename;
		WP.Seconds := PC.Seconds;
		WP.Text := PC.Text
	end
end;

procedure TMainForm.plconDblClick(Sender: TObject);
var
	index:integer;
	aNode, wNode:PvirtualNode;
	PC:PplConRec;
begin
	if (playlistbox.selectedcount > 0) and (plcon.SelectedCount > 0) then
	begin
		index := -1;
		SaveWinplayUndo;
		updateplaylist;
		winplaylist.BeginUpdate;
		if (pref.QuicklistClick.ItemIndex in [0, 1]) and not (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked) then {Add entire and play selected / play selected}
		begin
			winplaylist.clear;

			if pref.QuicklistClick.ItemIndex = 0 then // Add entire and play selected
			begin
				aNode := plCon.GetFirst;
				while aNode <> nil do
				begin
					PC := plCon.GetNodeData(aNode);
					wNode := PlConToWinPlaylist(PC, nil, amNowhere);
					if plCon.Selected[aNode] then
						index := wNode.index;
					aNode := plCon.GetNext(aNode)
				end
			end else   //play selected
			begin
				aNode := plCon.GetFirstSelected;
				index := 0;
				while aNode <> nil do
				begin
					PC := plCon.GetNodeData(aNode);
					PlConToWinPlaylist(PC, nil, amNowhere);
					aNode := plCon.GetNextSelected(aNode)
				end
			end
		end else
			if (pref.QuicklistClick.ItemIndex in [2, 3]) or (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked) then {Enqueue / PunchIn}
			begin
				if (pref.QuicklistClick.ItemIndex = 2) or (PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked) then   //equeue
					aNode := WinPlayList.GetLast
				else
				begin
					aNode := WinPlayList.GetFirst;
					while aNode <> nil do
					begin
						if PplstRec(WinplayList.GetNodeData(aNode)).playing then
							break;
						aNode := WinPlayList.GetNext(aNode)
					end
			end;
			PC := plCon.GetNodeData(plCon.GetFirstSelected);
			aNode := PlConToWinPlaylist(PC, aNode, amInsertAfter)
		end;
		if continuousPlay1.checked then
			CheckConPlay;

		if partyMode1.Checked and pref.AlwaysEnqueueToWP.Checked then
			WinplaySave
		else
			WinPlaySave(index);
		winplaylist.endupdate;

		if (not (partyMode1.Checked and pref.AlwaysEnqueueToWP.Checked) and (pref.QuicklistClick.ItemIndex in [0, 1])) or (partyMode1.Checked and pref.AlwaysEnqueueToWP.Checked and (playbackstatus(hwnd_winamp) <> 1)) then
    begin
    	if playbackstatus(hwnd_winamp) = 3 then //paused
				button4(hwnd_winamp);
			button2(hwnd_winamp)
    end
	end
end;

procedure TMainForm.Sort1Click(Sender: TObject);
begin
				plcon.SortTree(0, sdAscending);
				updateplaylist;
				if plcon.getfirstselected <> nil then plcon.scrollintoview(plcon.getfirstselected, true)
end;

procedure TMainForm.Shuffle1Click(Sender: TObject);
Begin
  plcon.SortTree(1, sdAscending);
  updateplaylist;
  if plcon.getfirstselected <> nil then
  	plcon.scrollintoview(plcon.getfirstselected, true)
end;

procedure TMainForm.MoveDown1Click(Sender: TObject);
var     aNode : PVirtualNode;
begin
        plcon.beginupdate;
        aNode:=plcon.GetFirstSelected;
        while aNode <> nil do
                begin
                        if plcon.GetNext(aNode) <> nil then plcon.moveto(aNode,plcon.GetNext(aNode), amInsertAfter, false);
                        aNode:=plcon.GetNextSelected(aNode)
                end;
        plcon.endupdate;
        updateplaylist
end;


procedure TMainForm.MoveUp1Click(Sender: TObject);
var     aNode : PVirtualNode;
begin
        plcon.beginupdate;
        aNode:=plcon.GetFirstSelected;
        while aNode <> nil do
                begin
                        if plcon.GetPrevious(aNode) <> nil then plcon.moveto(aNode,plcon.GetPrevious(aNode), amInsertBefore, false);
                        aNode:=plcon.GetNextSelected(aNode)
                end;
        plcon.endupdate;
        updateplaylist
end;

procedure TMainForm.Delete1Click(Sender: TObject);
begin
	plcon.DeleteSelectedNodes;
	updateplaylist
end;

procedure TMainForm.imgrightMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
setWindowLong(MainFormInstance.Handle,
                GWL_STYLE,
               GetWindowLong(MainFormInstance.Handle,GWL_STYLE) and WS_CAPTION and WS_THICKFRAME);
               SetWindowPos(Handle,
                                                HWND_TOP,
                                                Left,
                                                Top,
                                                Width,
                                                Height,
                                                SWP_SHOWWINDOW or SWP_NOMOVE or SWP_NOSIZE)
end;

procedure TMainForm.imgrightMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
{setWindowLong(MainFormInstance.Handle,
                GWL_STYLE,
                GetWindowLong(MainFormInstance.Handle,GWL_STYLE) and not WS_CAPTION and not WS_SIZEBOX);
}end;

procedure TMainForm.imgrightMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
setWindowLong(MainFormInstance.Handle,
                GWL_STYLE,
                GetWindowLong(MainFormInstance.Handle,GWL_STYLE) and not WS_CAPTION and WS_SIZEBOX);
end;

procedure TMainForm.imgrightClick(Sender: TObject);
begin
		 setWindowLong(MainFormInstance.Handle,
     GWL_STYLE,
     GetWindowLong(MainFormInstance.Handle,GWL_STYLE) and not WS_CAPTION and WS_SIZEBOX);
end;

{procedure TMainForm.Copyallfilestoadirectory1Click(Sender: TObject);
//var
//        i:integer;
//        s:string;
//        Fo      : TSHFileOpStruct;
//        buffer  : array[0..65000] of char;
//        p       : pchar;
begin
		    if copyfolder.ShowModal = mrok then
                begin
                        if copyfolder.edit1.text <> '' then if copyfolder.edit1.text[length(copyfolder.edit1.text)] <> '\' then copyfolder.edit1.text := copyfolder.edit1.text + '\';
                        FillChar(Buffer, sizeof(Buffer), #0);
                        p := @buffer;
                        for i:= 0 to plfilenames.Count -2 do p := StrECopy(p, pchar(plfilenames.strings[i])) + 1;
                        StrECopy(p, pchar(plfilenames.strings[plfilenames.count-1]));
                        FillChar(Fo, sizeof(Fo), #0);
												Fo.Wnd    := Handle;
                        Fo.wFunc  := FO_COPY;
                        Fo.pFrom  := @Buffer;
                        Fo.pTo    := pchar(copyfolder.edit1.text);
                        Fo.fFlags := 0;
                             SHFileOperation(Fo);
                      {  if ((SHFileOperation(Fo) <> 0){ or
                        {(Fo.fAnyOperationsAborted <> false)} {)then
                        showmessageX(Cancelled);}
     {                   if copyfolder.CheckBox1.checked then
                                begin
                                        for i:=0 to plfilenames.count-1 do
                                                begin
                                                        if plfilenames.count -1 > 99 then
                                                                begin
                                                                        case length(inttostr(i)) of
                                                                                1 : s:= '00' + inttostr(i);
                                                                                2 : s:= '0' + inttostr(i);
                                                                                3 : s:= inttostr(i);
                                                                        end
                                                                end else
                                                                begin
                                                                        case length(inttostr(i)) of
                                                                                1 : s:= '0' + inttostr(i);
                                                                                2 : s:= inttostr(i);
                                                                        end
                                                                end;
                                                        if fileexists(copyfolder.edit1.text + getfilename(plfilenames.strings[i])) then renamefile(copyfolder.edit1.text + '\' + getfilename(plfilenames.strings[i]), copyfolder.edit1.text + s + ' - ' + getfilename(plfilenames.strings[i]))
                                                end
                                end
				end;
end;          }

procedure TMainForm.Playall1Click(Sender: TObject);
var
	i:integer;
begin
	if PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked then
	begin
		AddAll1Click(sender);
		exit
	end;

	screen.cursor:=crhourglass;
	SaveWinplayUndo;
	UpdateSearchBools;
	winplaylist.beginupdate;
	winplaylist.clear;
	if fonlyPL then
		for i:=0 to Fplaylist.count-1 do
			WinPlayAdd(FPlaylist.items[i], GetKill, false)
	else
		for i:=0 to reclist.count-1 do
			if filterrec(reclist.List^[i]) then
				WinPlayAdd(reclist.List^[i], GetKill, false);

	if continuousPlay1.checked then
		CheckConPlay;
	WinPlaySave;
	winplaylist.endupdate;
  if playbackstatus(hwnd_winamp) = 3 then //paused
		button4(hwnd_winamp);
	button2(hwnd_winamp);
	screen.cursor:=crdefault
end;

procedure TMainForm.FormCanResize(Sender: TObject; var NewWidth,
  NewHeight: Integer; var Resize: Boolean);
begin
		SetWindowLong(MainFormInstance.Handle, GWL_STYLE,
			GetWindowLong(MainFormInstance.Handle,GWL_STYLE) and not WS_CAPTION and not WS_THICKFRAME);
end;

Function TMainForm.GetDefaultTreeStructureIndex: Integer;
begin
	if length(dbs) > 0 then
  	result := dbs[0].TreeStructureIndex
  else
  	result := 0
end;

Function TMainForm.GetPreDefinedTreeStructureFromIndex(index: Integer):PTreeStructure;
var
	Node: PtreeStructureNode;
begin
  new(result);
  FillChar(result^, SizeOf(result^), 0);
  result.Head := NewTreeStructureNode;
  result.Index := index;
  result.PreDefinedIndex := index;
  node := result.Head;

	if index in [0, 1, 2, 3] then
  begin
	  node.Content := tscCompilationContainer;
	  node.IncludeCompilation := true;
    node.SortColumnField := -1;
	  node.Child := NewTreeStructureNode;
	  node.Child.Content := tscCompilations;
	  node.Child.IncludeCompilation := true;
    node.Child.SortColumnField := -1;
	  node.NextSibling := NewTreeStructureNode;
	  node := node.NextSibling;
  end;

  node.SortColumnField := -1;

	case index of
  	0:
    begin
    	result.Text := GetText(TXT_ColumnArtist) + ' \ ' + GetText(TXT_ColumnAlbum);
	  	node.Content := tscArtistsSortOrder;
	    node.IncludeCompilation := true;
	    node.Child := NewTreeStructureNode(tscAlbums, false);
      node.Child.NextSibling := NewTreeStructureNode(tscCompilations, true)
	  end;

  	1:
    begin
    	result.Text := GetText(TXT_ColumnArtist) + ' - ' + GetText(TXT_ColumnAlbum);
			node.Content := tscArtist_albums
	  end;

  	2:
    begin
    	result.Text := GetText(TXT_ColumnAlbum);
	  	node.Content := tscAlbums;
      node.NextSibling := NewTreeStructureNode(tscCompilations, true)
	  end;

    3:
	  begin
    	result.Text := GetText(TXT_ColumnGenre) + ' \ ' + GetText(TXT_ColumnArtist) + ' \ ' + GetText(TXT_ColumnAlbum);
	  	node.Content := tscGenres;
	    node.IncludeCompilation := true;
	    node.Child := NewTreeStructureNode(tscArtistsSortOrder, true);
	    node.Child.Child := NewTreeStructureNode(tscAlbums, false);
      node.Child.Child.NextSibling := NewTreeStructureNode(tscCompilations, true)
	  end;

		4:
	  begin
    	result.Text := GetText(TXT_DirectoryStructure);
	  	node.Content := tscDrivesRecursive;
	    node.IncludeCompilation := true;
	    node.Child := NewTreeStructureNode(tscDirectoriesRecursive, true)
	  end;

    5:
	  begin
    	result.Text := GetText(TXT_TrimmedDirectoryStructure);
	  	node.Content := tscTrimmedDirectoriesRecursive;
	    node.IncludeCompilation := true
	  end
  end
end;

Function TMainForm.GetTreeStructureFromIndex(index: Integer):PTreeStructure;
var
	aNode: PVirtualNode;
  i: Integer;
begin
	if index < Pref.TreeStructureList.RootNodeCount then
  begin
  	aNode := Pref.TreeStructureList.GetFirst;
  	for i:=1 to index do
    	aNode := Pref.TreeStructureList.GetNext(aNode);
    result := PTreeData(Pref.TreeStructureList.GetNodeData(aNode)).p
  end
  else
  	result := nil
end;

Procedure TMainForm.setTreeViewModeMenuItem(SelectedIndex: Integer);
var
  aNode: PVirtualNode;
  ts: PTreeStructure;
  MenuItem: TMenuItem;
begin
	while ViewModeMenuItem.Items[0] <> N1 do
  	ViewModeMenuItem.Delete(0);

  aNode := Pref.TreeStructureList.GetFirst;
  while aNode <> nil do
  begin
  	ts := PTreeData(Pref.TreeStructureList.GetNodeData(aNode)).p;
    MenuItem := NewItem(ts.Text, 0, aNode.Index = SelectedIndex, true, ShowArtistAlbum1Click, 0, 'ViewModeMenuItem' + IntToStr(aNode.Index));
    MenuItem.RadioItem := true;
    ViewModeMenuItem.Insert(aNode.Index, MenuItem);
		aNode := Pref.TreeStructureList.GetNext(aNode)
  end
end;

procedure TMainForm.ShowArtistAlbum1Click(Sender: TObject);
var
	aNode : PVirtualNode;
	TR : PTreeRec;
  i, index: Integer;
begin
	TMenuItem(Sender).Checked := true;
  index := TMenuItem(Sender).MenuIndex;

	if ShowMedia1.Checked then
	begin
		aNode := tree.GetFirstSelected;
		while aNode <> tree.rootnode do
		begin
			TR := tree.GetNodeData(aNode);
			if TR.Kind in [TreeKind_Harddisk, TreeKind_Cdrom, TreeKind_Zip, TreeKind_Network] then
      begin
				dbs[TR.Location].TreeStructureIndex := index;
        break
      end;

      aNode := aNode.Parent
		end
	end
  else
  	//Not IndividualSO - change all databases
    for i:=0 to length(dbs)-1 do
      dbs[i].TreeStructureIndex := index;

	updatetree(true)
end;

Procedure TMainForm.RemoveFromPLcache(PplRecP:pointer; rec:PRec; updatePlaylistFile:boolean); //hvis rec er nil slettes alle refs
var       PC : PPLcacheRec;
          PL : PplRec;
          i, x : integer;
          plFile : TStringlist;
          root, s :String;
          updated : boolean;
begin
     PL := PplRecP;
     if assigned(PL.CacheRef) then
     begin
          //Fjerner fra Cache
          PC := PL.CacheRef;
          if assigned(rec) then
          begin
               for i:=length(PC.cache)-1 downto 0 do
                   while (i < length(PC.cache)) and (rec = PC.cache[i]) do
                   begin
                        for x:=i to length(PC.Cache)-2 do
                            PC.Cache[x] := PC.Cache[x+1];
                        setLength(PC.Cache, length(PC.Cache)-1)
                   end
          end
          else
          begin
               setLength(PC.Cache, 0);
               dispose(PC);
               PL.CacheRef := nil
          end
     end;
     if assigned(rec) and updatePlaylistFile and getFileAccess(PL.Filename, true, true, true) then
     begin
          root := getFilePath(PL.filename);
          plFile := TStringlist.create;
          plFile.loadFromFile(PL.filename);
          updated := false;
          i:=plFile.count-1;
          while i >=0 do
          begin
               s := plFile.strings[i];
               if (length(s)>0) and (s[1]<>'#') then
               begin
                    if length(getFilePath(s))=0 then
                    	s := root + s;
                    if Q_SameText(s, getFtextP(rec, fFileName)) then
                    begin
                         updated := true;
                         plFile.Delete(i);
                         if (i>0) and (plFile.count>0) and (length(plFile.strings[i-1])>0) and (plFile.strings[i-1][1] = '#') then
                         begin
                              plFile.delete(i-1);
                              dec(i,2)
                         end else dec(i)
                    end else dec(i)
               end else dec(i)
          end;

          if updated then plFile.SaveToFile(PL.filename);
          plFile.free
     end
end;

Function TMainForm.UpdatePLcache(PplRecP:pointer; refresh:boolean=false):boolean;
var       PC : PPLcacheRec;
          PL : PplRec;
          root, s : string;
          f : textfile;
          p : pointer;
          arrayVirtualSize, arrayRealSize : cardinal;
begin
     result := true;
     PL := PplRecP;
     // hvis den indeholder en tom cacheRef skal den refreshe
     refresh := refresh or (assigned(PL.cacheRef) and (length(pPLcacheRec(PL.cacheRef).cache)=0));
     if refresh or not assigned(PL.cacheRef) then
     begin
          if assigned(PL.cacheRef) then
          begin
               PC := PL.cacheRef;
               setLength(PC.cache, 0);
               dispose(PC);
               PL.CacheRef := nil
          end;
          if not GetFileAccess(PL.Filename, true, false) then
          begin
               // Der kan ikke lses fra filen, der oprettes en tom cache
               new(PC);
               fillChar(PC^, sizeOf(PC^), #0);
               setLength(PC.cache, 0);
               PC.Complete := false;
               PL.cacheRef := PC;
               result := false;
               exit
          end;
          screen.cursor := crAppStart;
          new(PC);
          fillChar(PC^, sizeOf(PC^), #0);
          PC.Complete := true;
          root := getfilepath(PL.Filename);
          assignfile(f, PL.Filename);
          Filemode := 0;
          reset(f);

          arrayRealSize := 50;
          arrayVirtualSize := 0;
          setLength(PC.Cache, arrayRealSize);
          while not eof(f) do
          begin
               readln(f,s);
               Q_TrimInPlace(s);
               if (length(s)>0) and (s[1] <> '#') then
               begin
                    GetAbsoluteFilename(root, s);
                    p := findInReclist(s);
                    if assigned(p) then
                    begin
                         inc(arrayVirtualSize);
                         if arrayVirtualSize > arrayRealSize then
                         begin
                              inc(arrayRealSize, 50);
                              setLength(PC.Cache, arrayRealSize)
                         end;
                         PC.cache[arrayVirtualSize-1] := p
                    end
                    else PC.complete := false
               end
          end;
          closeFile(f);
          //forkorter arrayet til kun at indeholde det faktiske antal pointers
          setLength(PC.cache, arrayVirtualSize);
//          setLength(PC.Cache, lst.count);
//          for i:=0 to lst.count-1 do PC.cache[i] := lst.items[i];
//          lst.Free;

          PL.CacheRef := PC
     end;
     screen.cursor := crDefault
end;

Procedure TMainForm.AddToFPlaylist(TR: PTreeRec);
var       i, l:integer;
          PC : PPLcacheRec;
          PL : PplRec;
begin
  if TR.Kind <> TreeKind_Playlist then
  	exit;
  PL := TR.PlRecRef;
  if assigned(PL.CacheRef) then
  begin
    PC := PL.CacheRef;
    l := length(PC.cache);
    FPlaylist.Capacity := FPlaylist.count + l;
    for i:=0 to l-1 do
      FPlaylist.Add(PC.cache[i])
  end
end;

Procedure TMainForm.MakeFtreePath;
////////////////////////
Function GetText(aNode:PvirtualNode):WideString;
begin
	TreeGetText(Tree, aNode, 0, ttStatic, result);
end;

{Function NodePath(aNode:PVirtualNode):String;
begin
	result := '';
  while tree.rootnode <> aNode do
  begin
  	if PtreeRec(tree.getNodeData(aNode)).kind in [TreeKind_Drive, TreeKind_DriveRecursive, TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive] then
    	result := GetText(aNode) + '\' + result;
    aNode := aNode.parent
  end
end;  }

Function AddToTreePath(s:string):integer;
var    i:integer;
begin
	for i:=0 to fTreePath.count-1 do
  if Q_sameText(fTreePath.strings[i], s) then
  begin
  	result := i;
    exit
  end;
  result := fTreePath.Add(s)
end;

var
	aNode, bNode:PVirtualNode;
	i, L, K, sortColumn:Integer;
  aTR, bTR: PTreeRec;
	TreeKindDirectorySet: Boolean;
Begin
{    fTreeFilter beskrivelse:

     2 dim array af integers, integers refererer til strenge i ffTreePath
     tf[] er hver "parent" node der er selected og tf[][] er fx artist, album index i fTreePath. tf[][0] er dog altid location eller -1 for at vlge alle
}
	fOnlyPL := false;

	//nulstiller
  for i:=0 to GroupList.Count-1 do
    PGroupRec(GroupList.List^[i]).Selected := false;

	FGroupSelectedInTree := false;

	FTreePath.Clear;
	FPlaylist.Clear;
	setLength(fTreeFilter, 0);

	L:=0;
	aNode := tree.GetFirstSelected;
  //Get tree sort column
  aTR := Tree.GetNodeData(aNode);
  if aNode <> nil then
	  sortColumn := aTR.SortField
  else
  	sortColumn := -1;

	while aNode <> nil do
	begin
  	aTR := Tree.GetNodeData(aNode);
		if aTR.Kind = TreeKind_Group then
		begin
			FGroupSelectedInTree := true;
			PGroupRec(aTR.PlRecRef).Selected := true
		end;

		if aTR.Kind = TreeKind_Playlist then
		begin
			fOnlyPL := true;
			if UpdatePLcache(aTR.PlRecRef) then
				AddToFPlayList(aTR)
		end
		else
		begin
			inc(L);
			K := tree.GetNodeLevel(aNode)+1;
			if not showmedia1.checked then
				inc(k);
			setLength(fTreeFilter, L);
			setLength(fTreeFilter[L-1], K);
			bNode := aNode;
      TreeKindDirectorySet := false;
			for i:=K-1 downto 0 do
			begin
        bTR := Tree.GetNodeData(bNode);
				if i = 0 then
				begin
					if (tree.rootnode <> bNode) and (bTR.Kind in [TreeKind_Harddisk, TreeKind_CDROM, TreeKind_Zip, TreeKind_Network]) then
						fTreeFilter[L-1,i].i := bTR.location
					else
						fTreeFilter[L-1,i].i := -1
				end
				else
				begin
        	case bTR.Kind of
						TreeKind_Artist, TreeKind_Genre, TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_CompilationParent, TreeKind_Rating:
						begin
							fTreeFilter[L-1,i].i := bTR.tag;
							fTreeFilter[L-1,i].kind := bTR.kind
						end;
						TreeKind_ArtistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum:
						begin
							fTreeFilter[L-1,i].i := AddToTreePath(bTR.text);
							fTreeFilter[L-1,i].kind := bTR.kind
						end;
            TreeKind_Set:
            begin
            	fTreeFilter[L-1,i].i := GetPartOfSet(bTR.Tag);
							fTreeFilter[L-1,i].kind := bTR.kind
            end;
            TreeKind_Year, TreeKind_Decade:
            begin
            	fTreeFilter[L-1,i].i := bTR.Tag;
							fTreeFilter[L-1,i].kind := bTR.kind
            end;
            TreeKind_CustomField:
            begin
            	fTreeFilter[L-1, i].kind := bTR.Kind;
            	fTreeFilter[L-1, i].i := AddToTreePath(bTR.Text);
              fTreeFilter[L-1, i].Tag := bTR.Tag
            end;
            TreeKind_Group:
            begin
            	fTreeFilter[L-1,i].i := bTR.Tag;
		          fTreeFilter[L-1,i].kind := TreeKind_Group;
            end;
						TreeKind_DriveRecursive, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectoryRecursive:
						begin
							fTreeFilter[L-1,i].i := AddToTreePath(bTR.Text + '\');
		          fTreeFilter[L-1,i].kind := TreeKind_DirectoryRecursive;
		          fTreeFilter[L-1,i].Tag := bTR.Tag
						end;
  					TreeKind_Drive, TreeKind_Directory, TreeKind_TrimmedDirectory:
						begin
              if not TreeKindDirectorySet then
              begin
                if bTR.Count = 0 then
                	fTreeFilter[L-1,i].i := -2
                else
									fTreeFilter[L-1,i].i := bTR.PathListIndex;
			          fTreeFilter[L-1,i].kind := TreeKind_Directory;
	              TreeKindDirectorySet := true
              end
              else
              	fTreeFilter[L-1,i].i := -1
						end
	 				else
						fTreeFilter[L-1,i].i := -1
        end
			end;
			bNode := bNode.parent
		end
	end;
	aNode := tree.GetNextSelected(aNode)
	end;

	fOnlyPL := fOnlyPl and (tree.SelectedCount = 1);
	if fOnlyPL then
		tabel.Header.SortColumn := -1
	else
  begin
  	if (sortColumn <> -1) and (FMLsortedCol <> sortColumn) then
    begin
    	FMLSortedCol1 := FMLsortedCol;
    	FMLsortedCol := sortColumn;
      tabel.Header.SortDirection := sdAscending;

      tabel.BeginUpdate;
		  tabel.SortTree(FMLSortedCol,tabel.header.sortdirection, false);
			TabelToRecList;
      tabel.EndUpdate
    end;
    tabel.header.SortColumn := FMLsortedCol;
  end;

 {	if not GroupSelected then
		for i:=0 to groupList.count-1 do
			PGroupRec(groupList.Items[i]).filter := PGroupRec(groupList.Items[i]).Checked;   }

	UpdateSearchBools
end;

procedure TMainForm.Addalltoexistingplaylist1Click(Sender: TObject);
var
   f:textfile;
   exists:boolean;
   aNode : PVirtualNode;
   rec:Prec;
   fn:string;
begin
     disableAOT;
     if showOpenDialog(GetText(TXT_SelectFileToSaveAppend), '', '', 'Playlist files (m3u, pls)|*.M3U;*.PLS', fn) then
     begin
          assignfile(f, fn);
          Filemode := 2;
          exists := fileexists(fn);
          if exists then append(F) else rewrite(f);
					if not exists then writeln(f,'#EXTM3U');
          aNode := tabel.getfirstVisible;
          while aNode <> nil do
          begin
               rec := GetRec(aNode);
               writeln(f,getFtextP(rec, fextstr));
               writeln(f,getFtextP(rec, fFilename));
               aNode := tabel.GetNextVisible(aNode)
          end;
          closefile(f)
     end;
		 SetMainFormVisible(true)
end;

procedure TMainForm.Addalltonewplaylist1Click(Sender: TObject);
var
  f:textfile;
  aNode:pVirtualNode;
  rec:Prec;
begin
  disableAOT;
  if savedialog1.Execute then
  begin
    assignfile(f, savedialog1.filename);
    Filemode := 2;
    rewrite(F);
    writeln(f,'#EXTM3U');
    aNode := tabel.GetFirstVisible;
    while aNode <> nil do
    begin
      rec := getrec(aNode);
      writeln(f,getFtextP(rec, Fextstr));
      writeln(f,getFtextP(rec, Ffilename));
      aNode := tabel.getnextVisible(aNode)
    end;
    closefile(f)
  end;
  SetMainFormVisible(true)
end;

procedure TMainForm.UpdateID3tag1Click(Sender: TObject);
var
	art, ArtistSortOrder, tit, alb, com :string;
  PartOfSet, rating: Byte;
  track,TotalTracks,kbps,yea,cha,freq:integer;
  Flags:TRecFlags;
  duration : Cardinal;
  Fsize:Cardinal;
  aNode : PvirtualNode;
  Crc:LongWord;
  r:Prec;
  audioType:byte;
  addQ:word;
  LastWriteTime:Integer;
  cr: PCoverRec;
begin
  screen.cursor := crhourglass;

  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  pbar.Progress := 0;
  if tabelSelCount > 1 then
    begin
            sliderr.visible := false;
            WinplaylistCurrentTimeLabel.Visible := false;
            pbar.visible := true;
            pbar.MaxValue := tabelselcount
    end;
  aNode:= tabel.getfirstselected;
  while aNode <> nil do
  begin
    r := getRec(aNode);
    flags := r.flags;
    PartOfSet := r.PartOfSet;
    if readid3(nil, dbs[r.location].repairVBR, getFtextP(r, fScanpath), getFtextP(r, fFilename),master_MyMusic, audioType, addQ, art, ArtistSortOrder, tit, alb, com, PartOfSet, rating, yea,track,TotalTracks,kbps,cha,duration,{groups,}flags,Fsize,crc,freq,{ CreateTime,} LastWriteTime, dbs[r.location].calculateCRC, cr, r) then
    begin
    	try
      	BeginSetArtistAlbumFilename;
      	try
         setArtist(r, art, ArtistSortOrder);
         r.AudioType := audioType;
         r.addQuality := addQ;
         SetPCharString(r.Title, tit);
//         r.Title:= tit;
         r.Album:= GetAlbumID(alb);
         r.Rating := Rating;
         r.PartOfSet := PartOfSet;
         if (yea>=-1) and (yea<32767) then r.Year:= yea else r.Year := -1;
         r.Comment:= com;
         if (track>=0) and (track<=high(word)) then r.Track:= track else r.Track := 0;
         if (TotalTracks>=0) and (TotalTracks<=high(word)) then r.TotalTracks:= TotalTracks else r.TotalTracks := 0;
         if (kbps > -32767) and (kbps < 32767) then r.Kbps:= kbps else r.kbps := 0;
         r.Length := duration;
         if cha in [0 .. 4] then r.Channels := Cha else r.Channels := 4;//unknown
//         r.CreateTime := createTime;
         r.LastWriteTime := LastWriteTime;
         r.Flags := flags;
         if (crc > low(cardinal)) and (crc < high(cardinal)) then r.CRC := crc else r.CRC := 0;
         r.FSize := Fsize;
         if (freq>=0) and (freq<=high(word)) then r.khz := freq else r.Khz := 0;
         AddCoverRecToList(cr, r);
         tabel.invalidatenode(aNode);
         pbar.Progress := pbar.progress+1
        finally
        	EndSetArtistAlbumFilename
        end
      except
      end
    end;
    aNode := tabel.GetNextSelected(aNode)
  end;
  sliderr.visible := true;
  WinplaylistCurrentTimeLabel.Visible := true;
  pbar.visible := false;
  screen.cursor := crdefault;
  AfterTagChanged;
  Dec(SafeToAutoScanCount)
end;

procedure TMainForm.groupmenuPopup(Sender: TObject);
var
  i:integer;
  mi: TMenuItem;
begin
	groupmenu.Items.Clear;
	for i:=0 to groupList.Count-1 do
	begin
		//groupmenu.Items.Add(newitem(PgroupRec(GroupList.items[i]).name,texttoshortcut(''),PgroupRec(GroupList.items[i]).checked,true,gmenuitem1Click,0,'gmenuitem' + inttostr(i)))
    mi := newitem(PgroupRec(GroupList.items[i]).name,texttoshortcut(''),false,true,gmenuitem1Click,0,'gmenuitem' + inttostr(i));

    case PgroupRec(GroupList.items[i]).checkstate of
      GroupCheckState_Unchecked : mi.ImageIndex := 9;
      GroupCheckState_Checked : mi.ImageIndex := 13;
      GroupCheckState_Exclude : mi.ImageIndex := 17;
    end;
    groupmenu.Items.Add(mi);

	end;

	groupmenu.Items.Add(newitem('-',texttoshortcut(''),false,true,nil,0,'nlastsplitter1'));
	groupmenu.Items.Add(newitem(GetText(TXT_OnlyShowSelectedGroups),texttoshortcut(''),FInvertGroupsChecked,true,gmenuitemInvertClick,0,'nInvert'));
	groupmenu.Items.Add(newitem(GetText(TXT_FileMustBeInAllCheckedGroups),texttoshortcut(''),fAndGroups,true,gmenuitemAndGroupClick,0,'nGroupAnd'));
	groupmenu.Items.Add(newitem('-',texttoshortcut(''),false,true,nil,0,'nlastsplitter2'));
	groupmenu.Items.Add(newitem(GetText(TXT_ConfigureGroups),texttoshortcut(''),false,true,Configgroups1Click,0,'menuitemconfig'))
end;

procedure TMainForm.gmenuitem1Click(Sender: TObject);
var
  i:integer;
  imgIdx: integer;
  pg: PGroupRec;
begin

  pg := GroupList.Items[(sender as Tmenuitem).MenuIndex];
	imgIdx := (sender as Tmenuitem).ImageIndex;

  case imgIdx of
     9: pg.Checkstate := GetNextGroupCheckState(GroupCheckState_Unchecked);
    13: pg.Checkstate := GetNextGroupCheckState(GroupCheckState_Checked);
    17: pg.Checkstate := GetNextGroupCheckState(GroupCheckState_Exclude)
  end;
  //	for i:=0 to groupList.Count-1 do
//  	PgroupRec(GroupList.items[i]).checked := groupmenu.Items[i].checked;

  SetFilterFlags;
	updatetree(true)
end;

procedure TMainForm.gmenuitemInvertClick(Sender: TObject);
begin
	(sender as Tmenuitem).checked := not (sender as Tmenuitem).checked;
	FInvertGroupsChecked := (sender as Tmenuitem).checked and (grouplist.Count>0);

  SetFilterFlags;
	updatetree(true)
end;

procedure TMainForm.gmenuitemAndGroupClick(Sender: TObject);
begin
	(sender as Tmenuitem).checked := not (sender as Tmenuitem).checked;
	fAndGroups := (sender as Tmenuitem).checked;

  SetFilterFlags;
	updatetree(true)
end;

procedure TMainForm.grouplabelMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	groupmenu.Popup(mouse.CursorPos.x,mouse.CursorPos.y)
end;

procedure TMainForm.Configgroups1Click(Sender: TObject);
var
   CurrentFormBackup : TForm;
begin
	Application.CreateForm(TGroupsform, Groupsform);
  CurrentFormBackup := CurrentActiveForm;
  CurrentActiveForm := groupsForm;
  tree.BeginUpdate;
  groupsform.showmodal;
  UpdateTree(true);
  tree.EndUpdate;
  CurrentActiveForm := CurrentFormBackup;
	GroupsForm.Release;
  GroupsForm := nil;
end;

procedure TMainForm.MinimizeQ1Click(Sender: TObject);
begin
        if MinimizeQ1.Caption = arrowdown then
                begin
                        MinimizeQ1.caption := arrowup;
                        if MinimizeQ2.caption = arrowdown then
                                begin
                                        playlistbox.tag := 1;
                                        MinimizeQ2Click(self)
                                end;
                        treeplbar.Tag := treeplbar.Top;
                        treeplbar.Top := treepanel.height - treeplbar.height;
                        UpdateSizesTreePanel(treeplbar)
                end else
                begin
                        MinimizeQ1.caption := arrowdown;
                        if (treeplbar.tag > panel1.height) and (treeplbar.tag < treeplbar.Top) then treeplbar.top := treeplbar.tag else treeplbar.top := treepanel.height - treeplbar.height - 80;
                        UpdateSizesTreePanel(treeplbar);
                        if playlistbox.tag = 1 then
                                begin
                                        playlistbox.tag := 0;
                                        if MinimizeQ2.caption = arrowup then MinimizeQ2Click(self)
                                end
                end
end;

Procedure TMainForm.UpdateSizesTreePanel(Obj : TObject);
begin
        if Obj = treeplbar then
                begin
                        treepanellow.height := treeplbar.top;
                        UpdateTreeBounds(playlistbox);
                        UpdateTreeBounds(tree);
                        if MinimizeQ2.caption = arrowdown then plconbar.top := playlistbox.top + playlistbox.height;
                        plcon.top := plconbar.top + plconbar.height;
                        if MinimizeQ2.caption = arrowup then playlistbox.height := treepanel.height - treeplbar.top - treeplbar.height - plconbar.height;

                        if plconbar.Top >= treepanel.height - plconbar.Height then
                        begin   //plconbar er lige p bunden
                        	MinimizeQ2.caption := arrowup;
                          playlistbox.height := treepanel.height - treeplbar.top - treeplbar.height - plconbar.height
                        end;

                        if MinimizeQ2.caption = arrowdown then plcon.height := treepanel.height - plconbar.top - plconbar.height;
                        if (treeplbar.Top = treepanel.height - treeplbar.Height) or (treeplbar.BoundsRect.Bottom = plconbar.top) then MinimizeQ1.caption := arrowup else MinimizeQ1.caption := arrowdown;
                        if (MinimizeQ2.caption = arrowup) and (MinimizeQ1.caption = arrowdown) then plconbar.Top := treepanel.height - plconbar.Height;
                        plcon.top := plconbar.top + plconbar.height
                end else
        if Obj = plconbar then
                begin
                        if plconbar.top + plconbar.height = treepanel.height then MinimizeQ2.caption := arrowup else MinimizeQ2.caption := arrowdown;
                        UpdateTreeBounds(playlistbox);
                        UpdateTreeBounds(plcon);
                end else
				if Obj = WPbar then
					begin
						if WPbar.BoundsRect.Bottom >= tabelpanellow.height then
						begin
							MinimizeWinplay.caption := arrowup;
							WPbar.top:= tabelpanellow.height - WPbar.height
						end
						else MinimizeWinplay.caption := arrowdown;
						UpdateTreeBounds(tabel);
						UpdateTreeBounds(Winplaylist)
					end else
        if Obj = TabelBar then  {Bar mellem tree og tabel}
        begin
        	treepanel.SetBounds(0, 0, TabelBar.left, tabelpanel.height);
          tabelpanellow.SetBounds(TabelBar.Boundsrect.right, 0, tabelpanel.width - TabelBar.Boundsrect.right, tabelpanellow.clientheight);
        end
        else
        if Obj = nil then
                begin   //Bruges til at tilpasse de andre componenter til de tre bar'er
                        treepanellow.height := treeplbar.top;
                        if MinimizeQ1.Caption = arrowdown then
                                begin
                                        playlistbox.top := treeplbar.top + treeplbar.height;
                                        playlistbox.height := plconbar.Top - playlistbox.Top
                                end else
                                begin
                                        treeplbar.Top := treepanel.height - treeplbar.Height;
                                        playlistbox.top := treeplbar.top + treeplbar.height;
                                        playlistbox.height := 0
                                end;

                        if MinimizeQ2.caption = arrowdown then
                                begin
                                        plcon.Top := plconbar.top + plconbar.Height;
                                        plcon.Height := treepanel.height - plcon.Top - plcon.height
                                end else
                                begin
                                        plconbar.Top := treepanel.height - plconbar.Height;
                                        plcon.top := plconbar.top + plconbar.height
                                end
                end
end;

procedure TMainForm.winplaylistDblClick(Sender: TObject);
begin
	if (winplaylist.selectedcount <> 0) and not (partyMode1.Checked and pref.PartyDisablePlaybackControls.Checked) then
  begin
  	WinplaylistClickTime := GetTickCount;
		WinampPlaylistPlaySong(Winplaylist.GetFirstSelected)
  end
end;

procedure TMainForm.WinampPlaylistPlaySong(const index: Integer);
var
	aNode: PVirtualNode;
	i: Integer;
begin
	if index >= winplaylist.RootNodeCount then
		exit;

	if pref.ControlPlaylist.checked then
	begin
		aNode := Winplaylist.GetFirst;
		for i:=0 to index do
			aNode := Winplaylist.GetNext(aNode);
		WinampPlaylistPlaySong(aNode)
	end
	else
	begin
		SendMessage(hwnd_winamp, WM_WA_IPC, index, IPC_SETPLAYLISTPOS);
    if playbackstatus(hwnd_winamp) = 3 then //paused
			button4(hwnd_winamp);
		button2(hwnd_winamp);
		winplaylist.repaint
	end
end;

procedure TMainForm.WinampPlaylistPlaySong(const aNode: PVirtualNode);
begin
	if pref.ControlPlaylist.checked then
  begin
  	WinPlaySave(aNode.index);
		doSliderTimerTimer(aNode)
  end
	else
		SendMessage(hwnd_winamp, WM_WA_IPC, aNode.index, IPC_SETPLAYLISTPOS);

  if playbackstatus(hwnd_winamp) = 3 then //paused
		button4(hwnd_winamp);
	button2(hwnd_winamp);
	winplaylist.repaint
end;

procedure TMainForm.Showmedia1Click(Sender: TObject);
begin
	showmedia1.checked := not showmedia1.checked;
	updatetree(true)
end;

procedure TMainForm.columnpopupPopup(Sender: TObject);
var
	i:integer;
	mi: TMenuItem;
begin
	columnpopup.items.clear;
	columnpopup.Items.add(newitem(pref.AutoResizeColumnHeaders.Caption, texttoshortcut(''), pref.AutoResizeColumnHeaders.Checked, true, ToggleAutoResizeColumnToFit, 0, 'columnPopXtra1'));
	columnpopup.Items.add(newitem(pref.HideInfoShownInTree.Caption, texttoshortcut(''), pref.HideInfoShownInTree.Checked, true, ToggleHideInfoShownInTree,0, 'columnPopXtra2'));
	columnpopup.Items.add(newitem('-', texttoshortcut(''), false, true, nil,0, 'columnPopXtra3'));
	for i:=0 to tabel.header.columns.count -1 do
	begin
		mi := newitem(tabel.header.columns[tabel.Header.Columns.ColumnFromPosition(i)].text,texttoshortcut(''), TabelColumnsVisible[tabel.Header.Columns.ColumnFromPosition(i)] ,true , columnpopupmenuClick,0,'menuitemcolpop' + inttostr(i));
		mi.tag := tabel.Header.Columns.ColumnFromPosition(i);
		columnpopup.Items.add(mi)
	end
end;

procedure TMainForm.ToggleHideInfoShownInTree(Sender: TObject);
begin
	pref.HideInfoShownInTree.Checked := not pref.HideInfoShownInTree.Checked;
  ApplyTabelColumnsVisible();
	ApplyFilter(false)
end;

procedure TMainForm.ToggleAutoResizeColumnToFit(Sender: TObject);
begin
	pref.AutoResizeColumnHeaders.Checked := not pref.AutoResizeColumnHeaders.Checked;
	if pref.AutoResizeColumnHeaders.Checked then
		AutoResizeAllColumnsToFit
end;

procedure TMainForm.columnpopupmenuClick(Sender: TObject);
var     i:integer;
begin
	(sender as Tmenuitem).checked := not (sender as Tmenuitem).checked;
	for i:=3 to columnpopup.Items.Count-1 do
		TabelColumnsVisible[columnpopup.Items[i].Tag] := columnpopup.Items[i].Checked;
	ApplyTabelColumnsVisible;
	UpdateTreeBounds(tabel);
	UpdateHScroll(tabelScrollH, tabel)
end;

procedure TMainForm.ApplyTabelColumnsVisible;
var
	i: Integer;
begin
	tabel.Beginupdate;
	for i:=0 to length(TabelColumnsVisible)-1 do
		if TabelColumnsVisible[i] then
			tabel.header.columns[i].options := tabel.header.columns[i].options + [coVisible]
		else
    	tabel.header.columns[i].options := tabel.header.columns[i].options - [coVisible];
	tabel.EndUpdate
end;

procedure TMainForm.MinimizeWinplayClick(Sender: TObject);
begin
        if MinimizeWinplay.Caption = arrowdown then
        begin
                MinimizeWinplay.caption := arrowup;
                WPbar.Tag := WPbar.Top;
                WPbar.top := tabelpanellow.height - WPbar.height;
                UpdateSizesTreePanel(WPbar)
        end else
        begin
                MinimizeWinplay.caption := arrowdown;
                if WPbar.tag > 0 then WPbar.top := WPbar.tag else WPbar.top := tabelpanellow.height - WPbar.height - 80;
                UpdateSizesTreePanel(WPbar)
        end
end;

procedure TMainForm.winplaylistKeyDown(Sender: TObject; var Key: Word;
	Shift: TShiftState);
begin
	if key = VK_TAB then
		tree.SetFocus
	else
		if not CheckPopUpMenuFromKey(Sender, WinPlayPop, Key, Shift) then
			Globalshortcuthandle(key, shift)
end;

procedure TMainForm.PopupMenu1Popup(Sender: TObject);
begin
        filespopup.Popup(mouse.cursorpos.x,mouse.cursorpos.y)
end;

Procedure TMainForm.TreeFilter;
begin
	if LoadingDBs then
		exit;

  SetFilterFlags;
	ApplyFilter;
	screen.cursor := crdefault
end;

procedure TMainForm.continuousPlay1Click(Sender: TObject);
begin
	continuousPlay1.checked := not continuousPlay1.checked;
	if CheckConPlay then
		 winplaysave
end;

procedure TMainForm.RemoveConplay;
var       aNode, bNode : PVirtualNode;
begin
     winplaylist.beginupdate;
     aNode := Winplaylist.GetLast;
     while aNode <> nil do
     begin
          if PplstRec(Winplaylist.GetNodeData(aNode)).kill = Kill_ConPlay then
          begin
               bNode := Winplaylist.GetPrevious(aNode);
               if PplstRec(Winplaylist.GetNodeData(aNode)).playing then
                  PplstRec(Winplaylist.GetNodeData(aNode)).kill := Kill_None
               else
               begin
                WinplayDequeue(aNode);
               	Winplaylist.deletenode(aNode)
               end;
               aNode := bNode
          end else aNode := Winplaylist.GetPrevious(aNode)
     end;
     winplaylist.endupdate
end;

function TMainForm.CheckConPlay(checkNext:boolean=false):boolean; //retunrerer om den har ndret noget i listen
function GetFirstAviable:PVirtualNode;
var      aNode:PVirtualNode;
         r:Prec;
begin
  result := nil;
  aNode := tabel.GetFirst;
  while aNode <> nil do
  begin
	  r := getRec(anode);
	  if (r.Location = 0) and dbs[r.Location].exists and fileexists(getFtextP(r, ffilename)) then
	  begin
		  result := aNode;
		  aNode := nil
	  end
    else
    	aNode := tabel.GetNext(aNode)
  end
end;

Function GetNext:PRec;
//      Finder den nste i tabel der skal spilles. Kan senere evt. udvides med noget random noget
var
	found:boolean;
  rec, r:Prec;
  lastNode, rNode:PVirtualNode;
  PL:PplstRec;
  list: Tlist;
  i: Integer;
begin
	found := false;

  //finder den sidste non-kill-node i winplaylist:
  lastNode := winplaylist.GetLast;
  while lastNode <> nil do
  	if PplstRec(winplaylist.GetNodeData(lastNode)).kill <> kill_ConPlay then
    	break
    else
    	lastNode := winplaylist.GetPrevious(lastNode);

  if assigned(lastNode) then
  begin
  	PL := winplaylist.GetNodeData(lastNode);
    if assigned(PL.Rec) then
    	rec := PL.Rec
    else
    begin
    	rec := findInReclist(PL.filename);
      if assigned(rec) then
      	PL.Rec := rec
    end
  end
  else
  	rec := nil;

  if FromMainList1.Checked and assigned(rec) then
  begin
    rNode := tabel.GetFirstVisible;
    while rNode <> nil do
    begin
      r := getRec(rNode);
      if (not assigned(rec) and (rfPlaying in r.Flags)) or (assigned(rec) and (rec = r)) then
      begin
        found := true;
        break
      end;
      rNode := tabel.getnextvisible(rNode)
    end;

    if found then
    begin
      rNode := tabel.getnextvisible(rNode);
      if rNode = nil then
        rNode := tabel.GetFirstVisible
    end
    else
      rNode := tabel.GetFirstVisible;
    if not assigned(rNode) then
      rNode := GetFirstAviable;

    if assigned(rNode) then
      result := getRec(rNode)
    else
      result := nil
  end
  else
  if randomfrommainlist1.Checked then
  begin
  	list := Tlist.Create;
    list.Capacity := tabel.VisibleCount;
    for i:=0 to reclist.Count-1 do
    	if (reclist.List^[i] <> rec) and filterRec(reclist.List^[i]) then
      	list.Add(reclist.List^[i]);
    if list.Count > 0 then
    	result := list.List^[random(list.Count)]
    else
    	result := nil;
    list.free
  end
  else
  if randomFromCurrentDatabase1.Checked and assigned(rec) then
  begin
  	list := Tlist.Create;
    list.Capacity := reclist.Count;
    for i:=0 to reclist.Count-1 do
    	if (Prec(reclist.List^[i]).location = rec.location) and groupFilter(reclist.List^[i], true) then
      	list.Add(reclist.List^[i]);
    if list.Count > 0 then
    	result := list.List^[random(list.Count)]
    else
    	result := nil;
    list.free
  end
  else
  begin
		list := Tlist.Create;
    list.Capacity := reclist.Count;
    for i:=0 to reclist.Count-1 do
    	if dbs[Prec(reclist.List^[i]).location].exists and groupFilter(reclist.List^[i], true) then
      	list.Add(reclist.List^[i]);
    if list.Count > 0 then
    	result := list.List^[random(list.Count)]
    else
    	result := nil;
    list.free
  end
end;

function GetConPlayNode:PVirtualNode;
var      aNode : PVirtualNode;
begin
     result := nil;
     aNode := Winplaylist.GetLast;
		 while aNode <> nil do
     begin
          if PplstRec(Winplaylist.GetNodeData(aNode)).kill = Kill_conPlay then
          begin
               result := aNode
          end;
          aNode := Winplaylist.GetPrevious(aNode)
     end
end;
///////MAIN:
var
	conPlay: PVirtualNode;
  nextRec: PRec;
  PL: PplstRec;
begin  result := false;
	if winplaylist.rootNodecount = 0 then
  	exit;

  winplaylist.Beginupdate;

  if not continuousPlay1.checked then
  begin   //fjerner alle cont play
	  RemoveConplay;
	  result := true
  end
  else
  begin
	  conPlay := GetConPlayNode;
	  PL := winplayList.GetNodeData(conPlay);
	  if assigned(conPlay) and not PL.Playing then
	  begin
		  if checkNext or pref.updateContPlayOnFilter.checked then
		  begin
			  nextRec := GetNext;
			  if not pl.playing and assigned(nextRec) and (nextRec <> PL.Rec) then
			  begin
				  WinplayDequeue(conPlay);
				  winplaylist.DeleteNode(conPlay);
				  winplayAdd(nextRec, kill_ConPlay, false);
				  result := true
			  end
		  end
	  end else
	  begin
		  if assigned(conPlay) then
			  PL.Kill := kill_del;
		  nextRec := GetNext;
		  if assigned(nextRec) then
		  begin
			  winplayAdd(nextRec, kill_ConPlay, false);
			  result := true
		  end
	  end
  end;

  winplaylist.OnUpdating := nil;
  winplaylist.endupdate;
  winplaylist.OnUpdating := treeUpdating
end;

procedure TMainForm.Resetcounter1Click(Sender: TObject);
var     aNode:PvirtualNode;
        r:Prec;
begin
	aNode:=plcon.GetFirstSelected;
	while aNode <> nil do
		begin
			r := pPlconRec(plcon.getNodeData(aNode))^.Rec;
			r.playcount := 0;
			aNode:=plcon.GetNextSelected(aNode)
		end;
	PlaylistboxChange(playlistbox, playlistbox.getfirst)
end;

procedure TMainForm.TopListPopPopup(Sender: TObject);
var       r:Prec;
begin
	Resetcounter1.Visible := not PartyMode1.Checked;
	Resetallfiles1.Visible := not PartyMode1.Checked;

	try
		if assigned(pPlconRec(plcon.getNodeData(plcon.getfirstselected))^.Rec) then
		begin
			r := pPlconRec(plcon.getNodeData(plcon.getfirstselected))^.Rec;
			playedtimes1.visible := true;
			if r.PlayCount=1 then
				Playedtimes1.caption := GetText(TXT_PlayedOneTime) else Playedtimes1.caption := GetText(TXT_PlayedXtimes, [inttostr(r.PlayCount)])
		end
		else
			playedtimes1.visible := false
	except playedtimes1.visible := false
	end
end;

procedure TMainForm.SelecttherootofthecurrentdatabaseCtrlR1Click(Sender: TObject);
var     aNode :PVirtualNode;
begin
     if showmedia1.checked and (tree.Selectedcount<>0) then
     begin
          tree.beginupdate;
          aNode := tree.focusednode;
          tree.Selected[aNode] := false;
          while (aNode <> nil) and (tree.GetNodeLevel(aNode) <> 0) do
                aNode := aNode.Parent;
          tree.FocusedNode := aNode;
          Tree.Selected[aNode] := true;
          tree.endupdate;
          treefilter
     end
end;

procedure TMainForm.StartSearch1Click(Sender: TObject);
begin
	ApplyFilter
end;

procedure TMainForm.autoresettabelTimer(Sender: TObject);
begin
        autoresettabel.Enabled := false
end;

procedure TMainForm.Rename1Click(Sender: TObject);
var     TR:PtreeRec;
begin
        if tree.selectedcount <> 1 then exit;
        tr := tree.GetNodeData(tree.getfirstselected);
				if not (TR.kind in [treeKind_Artist, treeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_Year]) then exit;
        tree.EditNode(tree.GetFirstSelected,-1);
							{  begin
												makeFtreepath;
												Tree.options := Tree.options + [goediting];
												Tree.EditorMode :=true;
												exit
								end; }
end;

procedure TMainForm.ConfigmenuPopup(Sender: TObject);
begin
	Generalconfiguration1.shortcut := Preferences1.shortcut;
	Help1.Visible := not partyMode1.Checked and fileexists(plugindir + AppName + '\help\index.htm');

	Generalconfiguration1.Visible := not partyMode1.Checked;
	Winamp1.Visible := not partyMode1.Checked;
	aot.Visible := not partyMode1.Checked;
	Undo2.Visible := not partyMode1.Checked;
	CloseWinamp1.Visible := not partyMode1.Checked;
  SaveDatabase1.Visible := not partymode1.Checked
end;

procedure TMainForm.Mainlistfocused1Click(Sender: TObject);
begin
        tabel.SetFocus
end;

procedure TMainForm.TreeFocused1Click(Sender: TObject);
begin
        tree.SetFocus
end;

procedure TMainForm.PlaylistFocused1Click(Sender: TObject);
begin
        winplaylist.setfocus
end;

procedure TMainForm.QuicklistselectorFocused1Click(Sender: TObject);
begin
        playlistbox.SetFocus
end;

procedure TMainForm.QuicklistsongsFocused1Click(Sender: TObject);
begin
        plcon.setfocus
end;


procedure TMainForm.Selectnoneshowalldatabases1Click(Sender: TObject);
var     aNode:PvirtualNode;
begin
  tree.beginupdate;
  aNode := tree.GetFirst;
  while aNode <>nil do
  begin
    tree.selected[aNode] := false;
    aNode := tree.GetNext(aNode)
  end;
  tree.endupdate;
//  TreeFilter	- not nescesarry as it is called when the tree-selection changes
end;

Procedure TMainForm.CleanLists;
function DeleteNode(node: PVirtualNode): PVirtualNode;
begin
	result := tree.GetPrevious(node);
  tree.DeleteNode(node)
end;
var
	i, k:integer;
  aNode:PvirtualNode;
  TR:PTreeRec;
  arr: array of boolean;
begin
	tree.BeginUpdate;
	MoveAddRecListToReclist;

  BeginSetArtistAlbumFilename;

  SetLength(arr, artistList.Count);
  for i:=0 to reclist.Count-1 do
  begin
  	arr[PRec(reclist.List^[i]).artist] := true;
    arr[PRec(reclist.List^[i]).ArtistSortOrder] := true
  end;
  for i:=0 to AddRecList.Count-1 do
  begin
  	arr[PRec(AddRecList.List^[i]).artist] := true;
    arr[PRec(AddRecList.List^[i]).ArtistSortOrder] := true
  end;

  for i:=artistList.count-1 downto 0 do
  begin
  	if not arr[i] then
    begin
      artistList.Delete(i);
      //fjerner forekomster
      for k:=0 to reclist.count-1 do
      begin
        if PRec(reclist.List^[k]).artist > i then
           dec(PRec(reclist.List^[k]).artist);
        if PRec(reclist.List^[k]).ArtistSortOrder > i then
           dec(PRec(reclist.List^[k]).ArtistSortOrder)
      end;

      for k:=0 to AddRecList.count-1 do
      begin
        if PRec(AddReclist.List^[k]).artist > i then
           dec(PRec(AddReclist.List^[k]).artist);
        if PRec(AddReclist.List^[k]).ArtistSortOrder > i then
           dec(PRec(AddReclist.List^[k]).ArtistSortOrder)
      end;
    end
  end;

  //tree  - artist
  aNode := tree.GetFirst;
  while aNode <> nil do
  begin
  	TR := tree.GetNodeData(aNode);
    if TR.Kind=TreeKind_Artist then
    	for i:=length(arr)-1 downto 0 do
      	if not arr[i] then
        	if TR.tag>i then
        		dec(TR.tag)
        	else
          if TR.tag = i then
          begin
          	aNode := DeleteNode(aNode);
            break
          end;

    aNode := tree.GetNext(aNode)
  end;

	//albumList
  SetLength(arr, 0);	//nulstiller
  SetLength(arr, albumList.Count);
  for i:=0 to reclist.Count-1 do
  begin
  	arr[PRec(reclist.List^[i]).album] := true
  end;
  for i:=0 to AddRecList.Count-1 do
  begin
  	arr[PRec(AddRecList.List^[i]).album] := true
  end;

  for i:=albumList.count-1 downto 0 do
  begin
    if not arr[i] then
    begin
      albumList.Delete(i);
      //fjerner forekomster
      for k:=0 to reclist.count-1 do
        if PRec(reclist.List^[k]).album > i then
        	dec(PRec(reclist.List^[k]).album);

      for k:=0 to AddRecList.count-1 do
        if PRec(AddReclist.List^[k]).album > i then
           dec(PRec(AddReclist.List^[k]).album);
    end
  end;

	//tree  - album
  aNode := tree.GetFirst;
  while aNode <> nil do
  begin
  	TR := tree.GetNodeData(aNode);
    if TR.Kind in [TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum] then
    	for i:=length(arr)-1 downto 0 do
      	if not arr[i] then
        	if TR.tag>i then
        		dec(TR.tag)
        	else
          if TR.tag = i then
          begin
          	aNode := DeleteNode(aNode);
            break
          end;
    aNode := tree.GetNext(aNode)
  end;

  //FpathList
  SetLength(arr, 0);	//nulstiller
  SetLength(arr, FpathList.Count);
  for i:=0 to reclist.Count-1 do
  	arr[PRec(reclist.List^[i]).Fpath] := true;

  for i:=FpathList.count-1 downto 0 do
  begin
    if not arr[i] then
    begin
      FpathList.Delete(i);
      //fjerner forekomster
      for k:=0 to reclist.count-1 do
      if PRec(reclist.List^[k]).Fpath > i then
        dec(PRec(reclist.List^[k]).Fpath)
    end
  end;

  aNode := tree.GetFirst;
  while aNode <> nil do
  begin
  	TR := tree.GetNodeData(aNode);
    if TR.Kind in [TreeKind_DriveRecursive, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectoryRecursive, TreeKind_Drive, TreeKind_Directory, TreeKind_TrimmedDirectory] then
    	for i:=length(arr)-1 downto 0 do
      	if not arr[i] then
        	if TR.PathListIndex >i then
        		dec(TR.PathListIndex)
        	else
          if TR.PathListIndex = i then
          begin
          	aNode := DeleteNode(aNode);
            break
          end;
    aNode := tree.GetNext(aNode)
  end;

  SetLength(arr, 0);
  makeFtreePath;
	EndSetArtistAlbumFilename;
  Tree.EndUpdate
end;

Function TMainForm.SetPartOfSetFromString(var PartOfSet: Byte; const value: String): Boolean;
var
  i: Integer;
  s: String;
begin
  result := true;
  if length(value) > 0 then
  begin
    i := Q_StrScan(value, '/');
    if i > 0 then
    begin
      s := Q_CopyRange(value, 1, i-1);
      if (length(s) > 0) then
      	if Q_IsInteger(s) and (StrToInt(s) <= 16) then
        	SetPartOfSet(PartOfSet, StrToInt(s))
        else
        	result := false;

      s := Q_CopyFrom(value, i+1);
      if (length(s) > 0) then
      	if Q_IsInteger(s) and (StrToInt(s) <= 16) then
	        SetTotalParts(PartOfSet, StrToInt(s))
        else
        	result := false;
    end
    else
    if Q_IsInteger(value) and (StrToInt(value) <= 16) then
      SetPartOfSet(PartOfSet, StrToInt(value))
    else
    	result := false
  end
  else
  begin
  	PartOfSet := 0;
    result := true
  end
end;

Function TMainForm.SetPartOfSetFromString(rec: PRec; const value: String): Boolean;
begin
	SetPartOfSetFromString(rec.PartOfSet, value);
end;

Procedure TMainForm.SetPartOfSet(var PartOfSet: Byte; value: Byte);
begin
	PartOfSet := (value shl 4) or (PartOfSet and $F);
end;

Procedure TMainForm.SetPartOfSet(rec: PRec; value: Byte);
begin
	SetPartOfSet(rec.PartOfSet, value);
end;

Procedure TMainForm.SetTotalParts(var PartOfSet: Byte; value: Byte);
begin
	PartOfSet := value or (PartOfSet and $F0);
end;

Procedure TMainForm.SetTotalParts(rec: PRec; value: Byte);
begin
	SetTotalParts(rec.PartOfSet, value);
end;

Function TMainForm.GetPartOfSet(PartOfSet: Byte): Byte;
begin
	result := PartOfSet shr 4;
end;

Function TMainForm.GetPartOfSet(rec: PRec): Byte;
begin
	result := GetPartOfSet(rec.PartOfSet);
end;

Function TMainForm.GetTotalParts(PartOfSet: Byte): Byte;
begin
	result := PartOfSet and $F;
end;

Function TMainForm.GetTotalParts(rec: PRec): Byte; 
begin
	result := GetTotalParts(rec.PartOfSet);
end;

Function TMainForm.GetArtistID(const artist:string):integer;
var      i:integer;
         aNode:PvirtualNode;
         TR:PTreeRec;
begin
  if not artistList.find(artist, result) then
  begin
    result := artistList.add(artist);
    for i:=0 to reclist.count-1 do       //reclist
    begin
      if Prec(reclist.List^[i]).artist >= result then
        inc(Prec(reclist.List^[i]).artist);
      if Prec(reclist.List^[i]).ArtistSortOrder >= result then
        inc(Prec(reclist.List^[i]).ArtistSortOrder)
    end;
    //AddReclist:
    for i:=0 to AddReclist.count-1 do
    begin
      if Prec(AddReclist.List^[i]).artist >= result then
        inc(Prec(AddReclist.List^[i]).artist);
      if Prec(AddReclist.List^[i]).ArtistSortOrder >= result then
        inc(Prec(AddReclist.List^[i]).ArtistSortOrder)
    end;

    //tree:
    aNode := tree.GetFirst;
    while aNode <> nil do
    begin
      TR := tree.GetNodeData(aNode);
      if (TR.Kind=TreeKind_Artist) and (TR.tag>=result) then
        inc(TR.tag);
      aNode := tree.GetNext(aNode)
    end;
    makeFtreePath
  end
end;

Function TMainForm.SameArtistAndArtistSortOrder(const rec: PRec): Boolean;
begin
 result := (rec.Artist = rec.ArtistSortOrder) or Q_SameText(theFix(artistList.Strings[rec.Artist]), artistList.Strings[rec.ArtistSortOrder]);
end;

Function TMainForm.SetArtist(const rec:PRec; const artist:string):integer;
var
	sWOT:string;
begin
  result := GetArtistID(artist);

  //If artistSortOrder is the samme as the former artist, also update ArtistSortOrder
 	if SameArtistAndArtistSortOrder(rec) then
  begin
	  sWOT := theFix(artist);
	  if Q_SameText(artist, sWOT) then
	    rec.ArtistSortOrder := result
    else
    begin
     	rec.ArtistSortOrder := GetArtistID(sWOT);
	    if not Q_SameText(artistList.Strings[result], artist) then
	  		artistList.Find(artist, result)
    end
  end;

  rec.artist := result
end;

Function TMainForm.SetArtist(const rec:PRec; const artist, artistSortOrder:string):integer;
var
	sWOT:string;
begin
  result := GetArtistID(artist);
  if length(artistSortOrder) = 0 then
  begin
	  sWOT := theFix(artist);
	  if Q_SameText(artist, sWOT) then
	    rec.ArtistSortOrder := result
    else
    	rec.ArtistSortOrder := GetArtistID(sWOT)
  end
  else
  begin
	  rec.ArtistSortOrder := GetArtistID(artistSortOrder);
  end;

  if not Q_SameText(artistList.Strings[result], artist) then
  	artistList.Find(artist, result);
  rec.artist := result
end;

Function TMainForm.SetArtistSortOrder(const rec:PRec; const artistSortOrder:string):integer;
begin
	if length(trim(artistSortOrder)) = 0 then
  	result := rec.Artist
  else
		result := GetArtistID(artistSortOrder);

  rec.ArtistSortOrder := result
end;

Function TMainForm.GetAlbumID(const s:string):integer;
var      i:integer;
         aNode:PvirtualNode;
         TR:PTreeRec;
begin
     if not albumList.find(s, result) then
     begin
          result := albumList.add(s);
          for i:=0 to reclist.count-1 do
          begin
               if Prec(reclist.List^[i]).album >= result then
                  inc(Prec(reclist.List^[i]).album)
          end;
          //AdReclist
          for i:=0 to AddReclist.count-1 do
          begin
          	if Prec(AddReclist.List^[i]).album >= result then
            	inc(Prec(AddReclist.List^[i]).album)
          end;

          //tree:
          aNode := tree.GetFirst;
          while aNode <> nil do
          begin
               TR := tree.GetNodeData(aNode);
							 if (TR.Kind in [TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum]) and (TR.tag>=result) then
									inc(TR.tag);
               aNode := tree.GetNext(aNode)
          end;
          makeFtreePath
     end
end;

Function TMainForm.SetFpath(const s:string):integer;
var
	i:integer;
  aNode: PVirtualNode;
  TR: PTreeRec;
begin
     if not FpathList.find(s, result) then
     begin
          result := FpathList.add(s);
          for i:=0 to reclist.count-1 do
          begin
               if Prec(reclist.List^[i]).Fpath >= result then
                  inc(Prec(reclist.List^[i]).Fpath)
          end;
          //AddRecList
          for i:=0 to AddReclist.count-1 do
          begin
               if Prec(AddReclist.List^[i]).Fpath >= result then
                  inc(Prec(AddReclist.List^[i]).Fpath)
					end;
          //tree:
          aNode := tree.GetFirst;
          while aNode <> nil do
          begin
               TR := tree.GetNodeData(aNode);
							 if (TR.Kind in [TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive]) and (TR.PathListIndex >= result) then
									inc(TR.PathListIndex);
               aNode := tree.GetNext(aNode)
          end;
          makeFtreePath
     end
end;

Function TMainForm.GetFTextP(const rec:PRec; const Field:integer):String;
var
	x:integer;
begin
    try
    case Field of
            FFILENAME: result := FpathList.strings[rec.fPath] + rec.fName;
            FFNAME: result := rec.fName;
            FFILEPATH: result := FpathList.strings[rec.fPath];
            FARTIST: result := artistList.strings[rec.Artist];
            FArtistSortOrder: result := artistList.strings[rec.ArtistSortOrder];
            FTITLE: result := rec.Title;
            FALBUM: result := albumList.strings[rec.Album];
            FGENRE:
              begin
                result := '';
                for x:=0 to length(rec.Genre)-1 do
                  if rec.Genre[x] < genreList.Count then
                    if result = '' then
                      result := genreList.strings[rec.Genre[x]]
                    else
                      result := result + ', ' + genreList.strings[rec.Genre[x]]
              end;
            FYEAR: if rec.year <= 0 then result := '' else result := inttostr(rec.year);
            FCOMMENT: result := rec.Comment;
            FTRACK: if rec.track < 1 then result :='' else result := inttostr(rec.track);
            FTotalTracks: if rec.TotalTracks < 1 then result :='' else result := inttostr(rec.TotalTracks);
            FTrackInfo:
              begin
                if (rec.Track > 0) and (rec.TotalTracks = 0) then
                  result := inttostr(rec.Track)
                else
                if (rec.Track > 0) and (rec.TotalTracks > 0) then
                  result := inttostr(rec.Track) + '/' + inttostr(rec.TotalTracks)
                else
                if (rec.Track = 0) and (rec.TotalTracks > 0) then
                  result := '/' + inttostr(rec.TotalTracks)
                else
                  result := ''
              end;
            FKBPS: try
                    if rec.kbps < 0 then result := inttostr(abs(rec.kbps)) + ' VBR';
                    if rec.kbps = 0 then result := '';
                    if rec.kbps > 0 then result := inttostr(abs(rec.kbps));
                    except result := ''
                    end;
            FLENGTH: try result := IntTimeToStr(rec.length, false, false) except result := '' end;
            FLOCATION:result:= dbs[rec.location].Name;
            FCHANNELS:
                    if rec.channels < 0 then
                      result := ''
                    else
                    try
                      result := AudioTypes[rec.audioType].channelNames[rec.channels]
                    except result := ''
                    end;
            FPLAYCOUNT:result := inttostr(rec.playcount);
            FCOMPILATION: if rfCompilation in rec.Flags then result := '1' else result := '0';
            FGROUPS:
                    begin
                            result:='';
                            for x:=0 to length(rec.Groups)-1 do
                            if result = '' then
                                    result := PGroupRec(groupList.items[rec.Groups[x]]).name
                            else
                                    result := result + ', ' + PGroupRec(groupList.items[rec.Groups[x]]).name
                    end;
            FCRC:result := inttostr(rec.crc);

            FFSIZE:case pref.fzcol.itemindex of
                    0: result := floattoStrF(rec.FSize div 1024,ffnumber,8,0);
                    1: result := floattoStrF(rec.FSize,ffnumber,8,0)
                    end;

            FKHZ:
              if rec.Khz = 0 then
                result := ''
              else
              case pref.SRcol.itemindex of
                    0: result := floattoStrF(rec.Khz div 1000,ffnumber,8,0);
                    1: result := floattoStrF(rec.Khz,ffnumber,8,0)
                    end;
            FAudioType: result := AudioTypes[rec.AudioType].shortName;

            FTags:
            begin
              if (rfHasId3v1 in rec.Flags) and (rfHasId3v2 in rec.Flags) then
                if rfEqualId3 in rec.Flags then
                  result := 'Id3v1=Id3v2, '
                else
                  result := 'Id3v1Id3v2, '
              else
              begin
                if rfHasId3v1 in rec.Flags then
                  result := 'Id3v1, '
                else
                  result := '';
                if rfHasId3v2 in rec.Flags then
                  result := result + 'Id3v2, '
              end;
              if rfHasApeTag in rec.Flags then
                result := result + 'Ape, ';
              if rfHasOggTag in rec.Flags then
                result := result + 'Ogg, ';
              if rfHasWmaTag in rec.Flags then
                result := result + 'WMA, ';
              if length(result) > 2 then
                Q_CutRight(result, 2)
            end;

            FPartOfSetText : result := GetPartsString(rec);
            FPartOfSet :	begin
            								x := GetPartOfSet(rec);
                            if x > 0 then
                            	result := inttostr(x)
                            else
                            	result := ''
            							end;

            FTotalParts :	begin
            								x := GetTotalParts(rec);
                            if x > 0 then
                            	result := inttostr(x)
                            else
                            	result := ''
            							end;

            fArtistTitle : result := artistList.strings[rec.Artist] + ' - ' + rec.Title;
            Fextstr: result := '#EXTINF:' + inttostr(IntTimeToSec(rec.length)) + ',' + artistList.strings[rec.Artist] + ' - ' + rec.Title;
            Fscanpath: GetScanPath(rec);
            fQuality: begin
                           if rec.AudioType in [0, 2, 3, 4, 5] then //Mp3, Ogg, WMA, Ape, Wave
                           begin
                            result := getFtextP(rec, Fkbps) + ' kbps, ' + getFtextP(rec, FKHZ);
                            case pref.SRcol.itemindex of
                              0: result := result + ' KHz';
                              1: result := result + ' Hz'
                            end;
                            result := result + ' ' + getFtextP(rec, Fchannels);
                           end else
                           if rec.AudioType = 1 then //musePack
                           begin
                                result := getFtextP(rec, Fkbps) + ' kbps ' + getFtextP(rec, fChannels) + ', ' + MUSEPACKPROFILES[rec.addQuality shr 8] + ', Str.Ver ' + inttostr(rec.addQuality and $FF)
                           end
                           else
                            result := ''
            end;
            FDATABASETIME: result := DateTimeToStr(FileDateToDateTime(rec.DatabaseTime));
            FLASTWRITEDATE: result := DateTimeToStr(FileDateToDateTime(rec.LastWriteTime));
    else
    begin
			result := '';		//nescesarry :)
      if Field >= FCustomField then
      begin
        for x:=0 to length(rec.CustomFields)-1 do
          if rec.CustomFields[x].FieldIndex = Field - FCustomField then
          begin
            case PCustomField(FieldList.Items[rec.CustomFields[x].FieldIndex]).dataType of
              0: result := PStringData(rec.CustomFields[x].data).Value;
              1: result := IntToStr(PIntegerData(rec.CustomFields[x].data).Value);
              2: result := FloatToStr(PRealData(rec.CustomFields[x].data).Value);
            end;
            break
          end
      end
    end
  end;
  except
    result := ''
  end
end;

Procedure TMainForm.GetFTextP(const rec:Prec; const Field:integer; var result:WideString);// overload;
var
	x:integer;
begin
        try
        case Field of
                FFILENAME: result := FpathList.strings[rec.fPath] + rec.fName;

                FFNAME: result := rec.fName;
								FFILEPATH: result := FpathList.strings[rec.fPath];
                FARTIST: result := artistList.strings[rec.Artist];// + ' (' + IntToStr(rec.Artist) + ')';
                FArtistSortOrder: result := artistList.strings[rec.ArtistSortOrder];
                FTITLE: result := rec.Title;
                FALBUM: result := albumList.strings[rec.Album];
                FGENRE:
												begin
													result := '';
													for x:=0 to length(rec.Genre)-1 do
														if rec.Genre[x] < genreList.Count then
														begin
															if result = '' then
																result := genreList.strings[rec.Genre[x]]
															else
																result := result + ', ' + genreList.strings[rec.Genre[x]]
														end
                        end;
								FYEAR: if rec.year <= 0 then result := '' else result := inttostr(rec.year);
                FCOMMENT: result := rec.Comment;
								FTRACK: if rec.track < 1 then result :='' else result := inttostr(rec.track);
                FTotalTracks: if rec.TotalTracks < 1 then result :='' else result := inttostr(rec.TotalTracks);
                FTrackInfo:
                	begin
                  	if (rec.Track > 0) and (rec.TotalTracks = 0) then
                      result := inttostr(rec.Track)
                    else
                    if (rec.Track > 0) and (rec.TotalTracks > 0) then
                    	result := inttostr(rec.Track) + '/' + inttostr(rec.TotalTracks)
                    else
                    if (rec.Track = 0) and (rec.TotalTracks > 0) then
                    	result := '/' + inttostr(rec.TotalTracks)
                    else
                    	result := ''
                  end;
                FKBPS: try
                        if rec.kbps < 0 then result := inttostr(abs(rec.kbps)) + ' VBR';
                        if rec.kbps = 0 then result := '';
                        if rec.kbps > 0 then result := inttostr(abs(rec.kbps));
                        except result := ''
                        end;
                FLENGTH: try result := IntTimeToStr(rec.length, false, false) except result := '' end;
                FLOCATION:result:= dbs[rec.location].Name;
								FCHANNELS:
                				if rec.channels < 0 then
                        	result := ''
                        else
                        try
                        	result := AudioTypes[rec.audioType].channelNames[rec.channels]
                        except result := ''
												end;
								FPLAYCOUNT:result := inttostr(rec.playcount);
                FCOMPILATION: if rfcompilation in rec.Flags then result := '1' else result := '0';
                FGROUPS:
												begin
                                result:='';
																for x:=0 to length(rec.Groups)-1 do
																if result = '' then
                                        result := PGroupRec(groupList.items[rec.Groups[x]]).name
																else
                                        result := result + ', ' + PGroupRec(groupList.items[rec.Groups[x]]).name
                        end;
                FCRC:result := inttostr(rec.crc);
                FFSIZE:case pref.fzcol.itemindex of
                        0: result := floattoStrF(rec.FSize div 1024,ffnumber,8,0);
                        1: result := floattoStrF(rec.FSize,ffnumber,8,0)
                	end;

                FKHZ:
	                if rec.Khz = 0 then
                  	result := ''
                  else
  	              case pref.SRcol.itemindex of
                        0: result := floattoStrF(rec.Khz div 1000,ffnumber,8,0);
                        1: result := floattoStrF(rec.Khz,ffnumber,8,0)
                	end;

                fAudioType: result := AudioTypes[rec.AudioType].shortName;

                FTags:
                begin
                  if (rfHasId3v1 in rec.Flags) and (rfHasId3v2 in rec.Flags) then
                    if rfEqualId3 in rec.Flags then
                      result := 'Id3v1=Id3v2, '
                    else
                      result := 'Id3v1Id3v2, '
                  else
                  begin
                    if rfHasId3v1 in rec.Flags then
                      result := 'Id3v1, '
                    else
                      result := '';
                    if rfHasId3v2 in rec.Flags then
                      result := result + 'Id3v2, '
                  end;
                  if rfHasApeTag in rec.Flags then
                    result := result + 'Ape, ';
                  if rfHasOggTag in rec.Flags then
                    result := result + 'Ogg, ';
                  if rfHasWmaTag in rec.Flags then
                    result := result + 'WMA, ';
                  if length(result) > 2 then
                  	result := copy(result, 1, length(result)-2)
                end;

                FPartOfSetText : result := GetPartsString(rec);
                
                fArtistTitle : result := artistList.strings[rec.Artist] + ' - ' + rec.Title;
                Fextstr: result := '#EXTINF:' + inttostr(IntTimeToSec(rec.length)) + ',' + artistList.strings[rec.Artist] + ' - ' + rec.Title;
                Fscanpath: GetScanPath(rec);
								fQuality: begin
															 if rec.AudioType in [0, 2, 3, 4, 5] then //Mp3, Ogg, WMA, Ape, Wave
                               begin
                                    result := getFtextP(rec, Fkbps) + ' kbps, ' + getFtextP(rec, FKHZ);
                                    case pref.SRcol.itemindex of
                                         0: result := result + ' KHz';
                                         1: result := result + ' Hz'
                                         end;
                                    result := result + ' ' + getFtextP(rec, Fchannels);
                               end else
                               if rec.AudioType = 1 then //musePack
                               begin
                                    result := getFtextP(rec, Fkbps) + ' kbps ' + getFtextP(rec, fChannels) + ', ' + MUSEPACKPROFILES[rec.addQuality shr 8] + ', Str.Ver ' + inttostr(rec.addQuality and $FF)
                               end
                               else
                               result := '';
                end;
                FDATABASETIME: result := DateTimeToStr(FileDateToDateTime(rec.DatabaseTime));
                FLASTWRITEDATE: result := DateTimeToStr(FileDateToDateTime(rec.LastWriteTime));
				else
        begin
        	result := '';		//nescesarry :)
        	if Field >= FCustomField then
          begin
          	for x:=0 to length(rec.CustomFields)-1 do
            	if rec.CustomFields[x].FieldIndex = Field - FCustomField then
              begin
              	case PCustomField(FieldList.Items[rec.CustomFields[x].FieldIndex]).dataType of
                	0: result := PStringData(rec.CustomFields[x].data).Value;
                  1: result := IntToStr(PIntegerData(rec.CustomFields[x].data).Value);
                 	2: result := FloatToStr(PRealData(rec.CustomFields[x].data).Value);
                end;
                break
              end
          end
        end
			end;
      except
      	result := 'An error have happened! Please report to the author.' + #13 + 'Method/Code: GetText: ' + IntToStr(Field);  //behver ikke have GetText
      end
end;

Function TMainForm.GetScanPath(const P:Pointer):String;
var
	s:string;
	x:integer;
begin
  s := GetFTextP(p, FfilePath);
  for x:=0 to length(dbs[Prec(p).location].paths)-1 do
   if (length(s) > length(dbs[Prec(p).location].paths[x])) and (Q_CompTextL(s, dbs[Prec(p).location].paths[x], length(dbs[Prec(p).location].paths[x])) = 0) then
   begin
      result := dbs[Prec(p).location].paths[x];
      break
   end
end;

procedure TMainForm.CDEvents1AfterRemove(Sender: TObject;
  FirstDriveLetter: Char);
begin
	checkdrives(false)
end;

procedure TMainForm.Refresh1Click(Sender: TObject);
begin
  screen.cursor := crHourglass;
  checkdrives(true);
  tabel.beginupdate;
  if fOnlyPL and (tree.GetFirstSelected<>nil) and (pTreeRec(tree.getNodeData(tree.getFirstSelected)).kind = TreeKind_Playlist) then
  begin
    //refresher cache
    if assigned(pTreeRec(tree.getNodeData(tree.getFirstSelected)).PlRecRef) then
      UpdatePLcache(pTreeRec(tree.getNodeData(tree.getFirstSelected)).PlRecRef, true)
  end
  	else
    	reclistToTabel(false, true);

  SetFilterFlags;
  ApplyFilter(false); //hvis ikke tree, stter autoreset i gang

  if not fOnlyPL then
  begin
    tabel.SortTree(FMLSortedCol,tabel.header.sortdirection, false);
    TabelToRecList
  end;
  tabel.endupdate;

  CheckBackgroundImage;
  screen.cursor := crdefault
end;

procedure TMainForm.autoresettreeTimer(Sender: TObject);
begin
	autoresettree.Enabled := false
end;

procedure TMainForm.Delete2Click(Sender: TObject);
var
   aNode : PVirtualNode;
   topNodeSelected, bottomNodeSelected: Boolean;
begin
	if winplaylist.SelectedCount > 0 then
  begin
    ChangeCursor(1);
    aNode := WinPlaylist.GetFirstSelected;
    topNodeSelected := aNode = Winplaylist.GetFirst;
    bottomNodeSelected := Winplaylist.Selected[winplaylist.GetLast];
    if assigned(aNode) then
    begin
     if assigned(Winplaylist.GetPrevious(aNode)) then
        aNode := Winplaylist.GetPrevious(aNode)
     else
        aNode := nil
    end;
    WinPlaylist.DeleteSelectedNodes;
    ValidateWinplayEnqueue;
    if assigned(aNode) then
      aNode := Winplaylist.GetNext(aNode);

    if not assigned(aNode) then
    begin
      if topNodeSelected then
        aNode := winplaylist.GetFirst
      else
      if bottomNodeSelected then
      	aNode := winplaylist.GetLast
    end;
    if assigned(aNode) then
    begin
     Winplaylist.Selected[aNode] := true;
     Winplaylist.FocusedNode := aNode
    end;
    winplaysave;
    ChangeCursor(0)
  end
end;

procedure TMainForm.Moveup2Click(Sender: TObject);
var
        aNode, Targetnode : PVirtualnode;
begin
        aNode := Winplaylist.getfirstSelected;
        if aNode = nil then exit;
        Targetnode := Winplaylist.GetPrevious(aNode);
        if targetnode = nil then exit;
        ChangeCursor(1);
        winplaylist.beginupdate;
        while aNode <> nil do
                begin
                        Winplaylist.MoveTo(aNode, Targetnode, amInsertBefore, false);
                        aNode := winplaylist.GetNextSelected(aNode)
                end;
        if continuousPlay1.checked then CheckConPlay;
        winplaysave;
        winplaylist.endupdate;
        ChangeCursor(0)
       { PE := FindWindow('Winamp PE', nil );
                        getwindowrect(PE,r);
                        winplaylist.Items.BeginUpdate;
                        n:=winplaylist.Items.GetFirstSelectedNode;
                        while n<>nil do
                        begin
                            u := n.index;
                            if u = 0 then begin n:=winplaylist.Items.GetNextSelectedNode(n); continue end;
                            if r.bottom - r.top <= 14 then
                                begin //Playlist is Windowshade
                                        Posi := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
                                        winplay.Move(1+(u*2),(u*2)-1);//extinfo
                                        winplay.Move(2+(u*2),(u*2));//filename
                                        winplay.SaveToFile(winampdir + 'Winamp.m3u');
                                        winplaylist.items.move(n.index,n.index-1);
                                        deleteplaylist;
                                        cds.dwData := IPC_PLAYFILE;
                                        cds.lpData := pchar(winampdir + 'Winamp.m3u');
                                        cds.cbData := strlen(cds.lpData) + 1; // include space for null char
                                        SendMessage(hwnd_winamp, WM_COPYDATA, 0, LongInt(@cds));
                                        if posi > u then SendMessage(hwnd_winamp, WM_WA_IPC, posi-1, IPC_SETPLAYLISTPOS) else if posi < u then SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_SETPLAYLISTPOS)
                                end
                                else
                                begin  //playlist is not windowshade
                                        winplay.Move(1+(u*2),(u*2)-1);//extinfo
                                        winplay.Move(2+(u*2),(u*2));//filename
                                        for i:=1 to SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH ) do SendMessage( PE, WM_COMMAND, 105825, 0 ); //rykker markering op til start
                                        //for i:=0 to winplaylist.items.count-1 do if winplaylist.items[i].selected then begin x:=i; break end;
                                        for i:=0 to u-1 do SendMessage(PE, WM_COMMAND, 105826, 0 );
                                        SendMessage( PE, WM_COMMAND, 105751, 0 );//move up in winamplist
                                        winplaylist.items.move(n.index,n.index-1)
                                end;
                        n:=winplaylist.Items.GetNextSelectedNode(n);
                        end;
                        winplaylist.items.EndUpdate  }
end;

procedure TMainForm.Movedown2Click(Sender: TObject);
var       aNode, Targetnode, TargetnodeInit : PVirtualnode;
begin
        aNode := Winplaylist.getfirstselected;
        if aNode = nil then exit;
        while winplaylist.GetNextSelected(aNode) <> nil do aNode := winplaylist.GetNextSelected(aNode);
        targetnode := winplaylist.getnext(aNode);
        if targetnode = nil then exit;
        TargetnodeInit := Targetnode;
        ChangeCursor(1);
        aNode := Winplaylist.getfirstselected;
        winplaylist.beginupdate;
        while (aNode <> nil) and (winplaylist.GetPrevious(aNode) <> TargetnodeInit) do
                begin
                        Winplaylist.MoveTo(aNode, Targetnode, amInsertAfter, false);
                        targetnode := aNode;
                        aNode := winplaylist.getfirstselected
                end;
        if continuousPlay1.checked then CheckConPlay;
        winplaysave;
        winplaylist.endupdate;
        ChangeCursor(0)
   {     PE := FindWindow('Winamp PE', nil );
                        getwindowrect(PE,r);
                        winplaylist.Items.BeginUpdate;
                        n:=winplaylist.Items.GetLastSelectedNode;
                        while n<>nil do
                        begin
                            u := n.index;
                            if u = winplaylist.items.count-1 then begin n:=winplaylist.Items.GetPrevSelectedNode(n); continue end;
                            if r.bottom - r.top <= 14 then
                                begin //Playlist is Windowshade
                                        Posi := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
                                        winplay.Move(2+(u*2),4+(u*2));//extinfo
                                        winplay.Move(1+(u*2),3+(u*2));//filename
                                        winplay.SaveToFile(winampdir + 'Winamp.m3u');
                                        winplaylist.items.move(n.index,n.index+1);
                                        deleteplaylist;
                                        cds.dwData := IPC_PLAYFILE;
                                        cds.lpData := pchar(winampdir + 'Winamp.m3u');
                                        cds.cbData := strlen(cds.lpData) + 1; // include space for null char
                                        SendMessage(hwnd_winamp, WM_COPYDATA, 0, LongInt(@cds));
                                        if posi > u then SendMessage(hwnd_winamp, WM_WA_IPC, posi-1, IPC_SETPLAYLISTPOS) else if posi < u then SendMessage(hwnd_winamp, WM_WA_IPC, posi, IPC_SETPLAYLISTPOS)
                                end
                                else
                                begin  //playlist is not windowshade
                                        winplay.Move(2+(u*2),4+(u*2));//extinfo
                                        winplay.Move(1+(u*2),3+(u*2));//filename
                                        for i:=1 to SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH ) do SendMessage( PE, WM_COMMAND, 105825, 0 ); //rykker markering op til start
                                      //  for i:=0 to winplaylist.items.count-1 do if winplaylist.items[i].selected then begin x:=i; break end;
                                        for i:=0 to u-1 do SendMessage(PE, WM_COMMAND, 105826, 0 );
                                        SendMessage( PE, WM_COMMAND, 105752, 0 );//move Down in winamplist
                                        winplaylist.items.move(n.index,n.index+1)
                                end;
                        n:=winplaylist.Items.GetPrevSelectedNode(n);
                        end;
                        winplaylist.items.EndUpdate  }
end;

procedure TMainForm.WinplaylistCompareNodes(Sender: TBaseVirtualTree;
  Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
var
	p1, p2 : Pointer;
begin
  p1 := sender.GetNodeData(Node1);
  p2 := sender.GetNodeData(Node2);

  doWinplaylistCompareNodes(p1, p2, column, result);
  if (result = 0) and (FWPSortedCol1 <> Column) then
  	doWinplaylistCompareNodes(p1, p2, FWPSortedCol1, result)
end;

procedure TMainForm.doWinplaylistCompareNodes(p1, p2:pointer; Column:integer; var Result: integer);
function GetString(WP:PplstRec):string;
begin
  if assigned(WP.Rec) then
  	result := getFtextP(wp.Rec, column)
  else
  begin
    if column = fArtistTitle then
       result := WP.Text else
    if column = fFName then
       result := getFilename(WP.filename) else
    if column = fFileName then
       result := WP.filename
    else
    	result := ''
  end
end;
begin
  if assigned(PplstRec(p1).Rec) and assigned(PplstRec(p2).Rec) then
  	doTabelCompareNodes(PplstRec(p1).Rec, PplstRec(p2).Rec, column, result)
  else
		result := Q_CompText(GetString(p1), GetString(p2))
end;

procedure TMainForm.ByTitle1Click(Sender: TObject);
begin
	Winplaylist.SortTree(FTitle, sdAscending);
  winplaysave
end;

procedure TMainForm.Byfilename1Click(Sender: TObject);
begin
	Winplaylist.SortTree(fFname, sdAscending);
  winplaysave
end;


procedure TMainForm.Bypathandfilename1Click(Sender: TObject);
begin
	Winplaylist.SortTree(fFilename, sdAscending);
  winplaysave
end;

procedure TMainForm.Shuffle2Click(Sender: TObject);
begin
	ShuffleWinplay;
  winplaysave
end;

procedure TMainForm.ShuffleWinplay(onlySelected: boolean=false);
var
	i, n, r: Integer;
	arr: array of TplstRec;
  aNode: PVirtualNode;
  temp: TplstRec;
begin
  winplaylist.BeginUpdate;
	if onlySelected then
  begin
  	SetLength(arr, winplaylist.selectedCount);
    aNode := winplaylist.GetFirstSelected
  end
  else
  begin
  	SetLength(arr, Winplaylist.RootNodeCount);
    aNode := winplaylist.GetFirst
  end;

  n := length(arr)-1;
  for i:=0 to n do
  begin
  	arr[i] := PplstRec(winplaylist.GetNodeData(aNode))^;
    if onlySelected then
    	aNode := winplaylist.GetNextSelected(aNode)
    else
    	aNode := winplaylist.GetNext(aNode)
  end;

  //shuffle:
  for i:=0 to n do
  begin
    r := random(n+1);
    if r = i then
    	r := random(n+1);
  	temp := arr[r];
    arr[r] := arr[i];
    arr[i] := temp
  end;

  //save:
  if onlySelected then
    aNode := winplaylist.GetFirstSelected
  else
    aNode := winplaylist.GetFirst;

  for i:=0 to n do
  begin
  	PplstRec(Winplaylist.GetNodeData(aNode))^ := TplstRec(arr[i]);
    if onlySelected then
    	aNode := winplaylist.GetNextSelected(aNode)
    else
    	aNode := winplaylist.GetNext(aNode)
  end;
  winplaylist.endUpdate
end;

procedure TMainForm.max1Click(Sender: TObject);
begin
	MainFormInstance.WindowState := wsMaximized
end;

procedure TMainForm.jklMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	configmenu.Popup(mouse.cursorpos.x, mouse.cursorpos.y)
end;


procedure TMainForm.Refresh2Click(Sender: TObject);
begin
	updwinplaylist
end;

Procedure TMainForm.UpdateSearchBools;
begin
	FFiltertree := length(FTreeFilter)>0;
  FilterPL := FPlaylist.count > 0;
//  FInvertGroups := FGroupSelectedInTree or FInvertGroupsChecked
  // fOnlyplay sttes i makeFtreePath
end;

function TMainForm.TextInFields(rec: prec; const s:String): boolean;
var
	i: Integer;
begin
	result := (FFilters[6] and (Q_PosTextFuzzy(s, rec.fname)>0)) or
  	 (FFilters[1] and (Q_PosTextFuzzy(s, rec.Title)>0)) or
  	 (FFilters[3] and (Q_PosTextFuzzy(s, rec.Comment)>0)) or
  	 (FFilters[4] and (Q_PosTextFuzzy(s, GetFTextP(rec, FGenre))>0));

  if not result then
  	for i:=0 to length(rec.CustomFields)-1 do
    	if FFilters[rec.CustomFields[i].FieldIndex + PREDEFINED_SEARCHINFIELDCOUNT] then
      begin
      	case PCustomField(FieldList.List^[rec.CustomFields[i].FieldIndex]).DataType of
        	0: result := Q_PosTextFuzzy(s, PStringData(rec.CustomFields[i].data).Value)>0;
          1: result := Q_PosTextFuzzy(s, IntToStr(PIntegerData(rec.CustomFields[i].data).Value))>0;
          3: result := Q_PosTextFuzzy(s, FloatToStr(PRealData(rec.CustomFields[i].data).Value))>0;
        end;
        if result then
        	break
      end
end;

function TMainForm.PosTextInListNorm(rec:PRec):boolean;
var
  i:integer;
begin
  result := (FFilters[0] and FArtistFilter.Bits[rec.Artist]) or (FFilters[2] and FAlbumFilter.Bits[rec.Album]) or (FFilters[5] and FFilePathFilter.Bits[rec.Fpath]);
  if not result and FFilters[4] then
  	for i:=0 to Length(rec.Genre)-1 do
    	if FGenreFilter.Bits[rec.Genre[i]] then
      begin
      	result := true;
        break
      end;

  if not result then
	  for i:=0 to fNorm.count-1 do
	  begin
	    if TextInFields(rec, fNorm.strings[i]) then
      begin
      	result := true;
        break
      end
	  end
end;

function TMainForm.PosTextInListExclude(rec:Prec):boolean;
var
	i:integer;
begin
  result := (FFilters[0] and FArtistFilter.BitsInBlock[rec.Artist, 1]) or (FFilters[2] and FAlbumFilter.BitsInBlock[rec.Album, 1]) or (FFilters[5] and FFilePathFilter.BitsInBlock[rec.Fpath, 1]);
	if not result and FFilters[4] then
  	for i:=0 to Length(rec.Genre)-1 do
    	if FGenreFilter.BitsInBlock[rec.Genre[i], 1] then
      begin
      	result := true;
        break
      end;

	if not result then
    for i:=0 to fSubst.count-1 do
    begin
      result := false;
      if TextInFields(rec, fSubst.strings[i]) then
      begin
      	result := true;
        break
      end
    end
end;

function TMainForm.PosTextInListAdd(rec:Prec):boolean;	//Only call metod when fAdd.Count > 0
var
	i, j:integer;
begin
  result := false;
  for i:=0 to fAdd.count-1 do
  begin
    result := false;
    if (FFilters[0] and FArtistFilter.BitsInBlock[rec.Artist, 2+i]) or (FFilters[2] and FAlbumFilter.BitsInBlock[rec.Album, 2+i]) or (FFilters[5] and FFilePathFilter.BitsInBlock[rec.Fpath, 2+i]) then
      result := true
    else
    begin
      if FFilters[4] then
      begin
      	for j:=0 to Length(rec.Genre)-1 do
        	if FGenreFilter.BitsInBlock[rec.Genre[j], 2+i] then
          begin
          	result := true;
            break
          end;
        if not result then
        	result := TextInFields(rec, fAdd.strings[i]);
      end
      else
      	result := TextInFields(rec, fAdd.strings[i]);
    end;
    if not result then
    	break
  end
end;

function TMainForm.PosTextInListWholeWord(rec:PRec):boolean;
Function CheckWholeWord(const subs:String; const s:String):boolean;
begin
 result := Q_PosTextFuzzy(' ' + subs + ' ', ' ' + s + ' ')>0
end;
var
i, j:integer;
begin
  result := false;
  for i:=0 to FwholeWord.count-1 do
  begin
    if FFilters[6] and checkWholeWord(FwholeWord.Strings[i], rec.fname) then result := true else
    if FFilters[0] and checkWholeWord(FwholeWord.Strings[i], artistList.strings[rec.Artist]) then result := true else
    if FFilters[1] and checkWholeWord(FwholeWord.Strings[i], rec.Title) then result := true else
    if FFilters[2] and checkWholeWord(FwholeWord.Strings[i], albumList.strings[rec.Album]) then result := true else
    if FFilters[3] and checkWholeWord(FwholeWord.Strings[i], rec.Comment) then result := true else
    if FFilters[5] and checkWholeWord(FwholeWord.Strings[i], FpathList.strings[rec.Fpath]) then result := true else
    if FFilters[4] and checkWholeWord(FwholeWord.Strings[i], GetFTextP(rec, FGenre)) then result := true else

    for j:=0 to Length(rec.CustomFields) - 1 do
      if FFilters[rec.CustomFields[i].FieldIndex + PREDEFINED_SEARCHINFIELDCOUNT] and checkWholeWord(FwholeWord.Strings[i], GetFTextP(Rec, FCustomField + rec.CustomFields[i].FieldIndex)) then
      begin
        result := true;
        break
      end;

    if result then break
  end
end;

Function TMainForm.FilterRec(Rec:Prec; onlyFilterTree:boolean=false):boolean;
begin
	if not onlyFilterTree and Onlyshowaviablefiles1.Checked and not dbs[Rec.location].exists then
  begin
  	result := false
  end
  else
  begin
    // Playlist match is included no matter what
    if filterPL then
    begin
    	result := fOnlyPL or (fPlayList.IndexOf(Rec) >= 0)
    end
    else
    begin
    	if onlyFilterTree then
      	result := rfTreeFiltered in rec.Flags
      else
      	result := [rfTreeFiltered, rfGroupFiltered] <= rec.Flags
    end;

    if not onlyFilterTree then
	    result := result and
	    	(not filterStrings or (((Fsubst.Count=0) or not PosTextInListExclude(rec)) and ((Fnorm.Count=0) or posTextInListNorm(rec)) and ((Fadd.Count=0) or posTextInListAdd(rec))));


  {  if filterPL then
    begin
    	result := fOnlyPL or (fPlayList.IndexOf(Rec) >= 0)
    end
    else
    begin
    	if onlyFilterTree then
      	result := rfTreeFiltered in rec.Flags
      else
      begin
      	result := ([rfTreeFiltered, rfGroupFiltered] <= rec.Flags) and
        	(not filterStrings or (((Fsubst.Count=0) or not PosTextInListExclude(rec)) and ((Fnorm.Count=0) or posTextInListNorm(rec)) and ((Fadd.Count=0) or posTextInListAdd(rec))));
      end
    end     }
  end
end;

procedure TMainForm.LoadToDBS(Fstr:Tstream; Index:integer; Version:integer; storeValues:boolean=true);
var
	s : array[0..MaxSavedChars] of char;
  w:word;
  i, k, j:integer;
  TreeStructure: PTreeStructure;
begin
  Fstr.Read(w, sizeOf(w));
  Fstr.Read(s, w);
  if storeValues then dbs[index].name := Q_CopyLeft(s, w);

  Fstr.Read(w, sizeOf(w));
  Fstr.Read(s, w);
  if storeValues then dbs[index].Filename := Q_CopyLeft(s, w);

  //path + snr
  Fstr.Read(w, sizeOf(w));
  j := w;
  if storeValues then setLength(dbs[index].paths, w);
  if storeValues then setLength(dbs[index].snrs, w);
  for i:=0 to j-1 do
  begin
    Fstr.Read(w, sizeOf(w));
    Fstr.Read(s, w);
    if storeValues then dbs[index].paths[i] := Q_CopyLeft(s, w);

    //snr
    Fstr.Read(k, sizeOf(k));
    if storeValues then dbs[index].snrs[i] := k
  end;

  //excl
  Fstr.Read(w, sizeOf(w));
  j := w;
  setLength(dbs[index].excl, w);
  for i:=0 to j-1 do
  begin
    Fstr.Read(w, sizeOf(w));
    Fstr.Read(s, w);
    if storeValues then dbs[index].excl[i] := Q_CopyLeft(s, w)
  end;

  if storeValues then
  begin
    Fstr.Read(dbs[index].recursive, sizeOf(boolean));
    Fstr.Read(dbs[index].Media, sizeOf(shortInt));
    Fstr.Read(dbs[index].order, sizeOf(smallInt));
    if Version >= 10 then
      Fstr.Read(dbs[index].UseCustomColor, SizeOf(Boolean))
    else
      dbs[index].UseCustomColor := true;
    Fstr.Read(dbs[index].Color, sizeOf(TColor));
    if Version >= 2 then
    begin
      if version = 7 then
      begin
        dbs[index].TreeStructureIndex := 0;
        TreeStructure := LoadTreeStructure(FStr);
        FreeTreeStructure(TreeStructure)
      end
      else
      if version >= 8 then
        Fstr.Read(dbs[index].TreeStructureIndex, SizeOf(dbs[index].TreeStructureIndex))
      else
      begin
        Fstr.Seek(sizeOf(TTreeShow), soFromCurrent);
        dbs[index].TreeStructureIndex := 0
      end;
      if Version >= 3 then
      begin
        FStr.Read(dbs[index].CalculateCRC, SizeOf(boolean));
        if Version >= 5 then
          FStr.Read(dbs[index].repairVBR, SizeOf(Boolean))
        else
          dbs[index].repairVBR := false
      end
      else
        dbs[index].CalculateCRC := true
      end
      else
      begin
        dbs[index].TreeStructureIndex := 0;
        dbs[index].CalculateCRC := true
    end
  end else
  begin
  i := sizeOf(boolean) + sizeOf(shortInt) + sizeOf(smallInt) + sizeOf(Tcolor);
  if Version >= 2 then
  begin
    inc(i, SizeOf(TTreeShow));
    if Version >= 3 then
    begin
      inc(i, SizeOf(boolean))
    end
  end;
  Fstr.seek(i, soFromCurrent)
  end
end;

procedure TMainForm.SaveToDBS(Fstr:Tstream; Index:integer);
var
					w:word;
          i, k:integer;
begin
	WriteString(fstr, dbs[index].name);

  if length(dbs[index].Filename)=0 then
	  dbs[index].filename := createFilename(settingsdir, dbs[index].name + '.db', false, false);
  WriteString(fstr, dbs[index].Filename);

  //path + snr
  w := length(dbs[index].paths);
  Fstr.Write(w, sizeOf(w));
  for i:=0 to length(dbs[index].paths)-1 do
  begin
  	WriteString(fstr, dbs[index].paths[i]);

    //snr
    k := dbs[index].snrs[i];
    Fstr.Write(k, sizeOf(k))
  end;

  //excl
  w := length(dbs[index].excl);
  Fstr.Write(w, sizeOf(w));
  for i:=0 to length(dbs[index].excl)-1 do
  	WriteString(fstr, dbs[index].excl[i]);

  Fstr.Write(dbs[index].recursive, sizeOf(boolean));
  Fstr.Write(dbs[index].Media, sizeOf(shortInt));
  Fstr.Write(dbs[index].order, sizeOf(smallInt));
  FStr.Write(dbs[index].UseCustomColor, SizeOf(Boolean));
  Fstr.Write(dbs[index].Color, sizeOf(TColor));
  Fstr.Write(dbs[index].TreeStructureIndex, sizeOf(dbs[index].TreeStructureIndex));
  Fstr.Write(dbs[index].CalculateCRC, SizeOf(boolean));
  Fstr.Write(dbs[index].repairVBR, sizeOf(boolean))
end;

procedure TMainForm.savedatabase(ReleaseResources: Boolean);
var
	mstr: TMyMemoryStream;
  i, k, size:integer;
  GR : TGroupRec;
  SGR: TSaveGroupRec;
  PR : TplRec;
  CF: PCustomField;
  b:boolean;
  dateTime: TDateTime;
  aNode: PVirtualNode;
begin
	if not dbInitiated then
		exit;

    UnloadAndSaveAll(ReleaseResources, true);

    mstr := TMyMemoryStream.Create;
    mstr.Write(DBS_FileVer, sizeof(DBS_FileVer));

    dateTime := AppFirstRunDate * -1;
    mstr.Write(dateTime, SizeOf(dateTime));

    //Save custom fields
    size := FieldList.Count;
    mstr.Write(Size, SizeOf(Size));
    for i:=0 to FieldList.Count-1 do
    begin
    	CF := FieldList.Items[i];
      mstr.Write(CF.DataType, SizeOf(CF.DataType));
      mstr.Write(CF.IconIndex, SizeOf(CF.IconIndex));
      mstr.Write(CF.Filter, SizeOf(CF.Filter));
      WriteString(mstr, CF.name);
      WriteString(mstr, CF.id3v2FieldName);
      WriteString(mstr, CF.id3v2Description);
      WriteString(mstr, CF.id3v2DefaultLanguage);
      mstr.Write(CF.id3v2ReadAllLanguages, 1);
      WriteString(mstr, CF.oggFieldName);
      WriteString(mstr, CF.apeFieldName);
      WriteString(mstr, CF.wmaFieldName);

      if ReleaseResources then
      begin
      	finalize(CF^);
        Dispose(CF)
      end
    end;

    //Save AudioTypes
    size := Length(audioTypes) - PREDEFINED_AUDIOTYPESCOUNT;
    mstr.Write(size, sizeOf(integer));
    for i:=PREDEFINED_AUDIOTYPESCOUNT to length(audioTypes)-1 do
    with audioTypes[i] do
    begin
    	WriteString(mstr, longname);
			WriteString(mstr, shortname);

      size := length(ext);
      mstr.Write(size, sizeOf(integer));
      for k:=0 to length(ext)-1 do
      	WriteString(mstr, ext[k]);

      size := length(channelNames);
      mstr.Write(size, sizeOf(integer));
      for k:=0 to length(channelNames)-1 do
      	WriteString(mstr, channelNames[k]);

      mstr.Write(StopWinampWhenEdit, SizeOf(boolean));
      mstr.Write(Id3v1, SizeOf(boolean));
      mstr.Write(Id3v2, SizeOf(boolean));
      mstr.Write(Ogg, SizeOf(boolean));
      mstr.Write(ApeV1, SizeOf(boolean));
      mstr.Write(ApeV2, SizeOf(boolean));
      mstr.Write(WMA, SizeOf(boolean));
      mstr.Write(audio, SizeOf(boolean));
      mstr.Write(video, SizeOf(boolean))
    end;

    //Write TreeStructures
    i := Pref.TreeStructureList.RootNodeCount;
    mstr.Write(i, SizeOf(i));
    with Pref.TreeStructureList do
    begin
    	aNode := GetFirst;
      while aNode <> nil do
      begin
      	SaveTreeStructure(PTreeData(GetNodeData(aNode)).p, mstr);
        aNode := GetNext(aNode)
      end
    end;

    // Write groups
    mstr.write(groupList.count, sizeof(Integer));
    for i:=0 to groupList.count-1 do
    begin
         GR := PGroupRec(groupList.items[i])^;
         SGR.Name := GR.Name;
         SGR.Checkstate := GR.Checkstate;
         mstr.write(SGR, sizeof(TSaveGroupRec))
    end;
    // end of writeGroups
    // Write genre
    i:=genreList.count - MAXGENRES-1;
    mstr.write(i, sizeof(Integer));
    for i:=MAXGENRES+1 to genreList.count-1 do
    	WriteString(mstr, genreList.Strings[i]);

    // end of genre
    // Write artist
    i:=artistList.count;
    mstr.write(i, sizeof(Integer));
    for i:=0 to artistList.count-1 do
    	WriteString(mstr, artistList.Strings[i]);

    // end of artist
    // Write album
    i:=albumList.count;
    mstr.write(i, sizeof(Integer));
    for i:=0 to albumList.count-1 do
    	WriteString(mstr, albumList.Strings[i]);

    // end of artist
    // Write FpathList
    i:=FpathList.count;
    mstr.write(i, sizeof(Integer));
    for i:=0 to FpathList.count-1 do
    	WriteString(mstr, fPathList.Strings[i]);

    // end of FpathList
    //Write Autoscan paths
    i:=pref.AutoScanPaths.Items.count;
    mstr.write(i, sizeOf(integer));
    for i:=0 to pref.AutoScanPaths.Items.count-1 do
    begin
    	WriteString(mstr, pref.AutoScanPaths.Items[i]);
      b := pref.AutoScanPaths.Checked[i];
      mstr.write(b, SizeOf(boolean))
    end;
    //eo AutoscanPaths

    for i:=0 to length(dbs)-1 do
    	SaveToDBS(mstr, i);

    mstr.SaveToFile(settingsdir + 'dbs.dat');
    mstr.free;

    //playlist file
    //FS := TFileStream.Create(settingsdir + 'dbpl.dat', fmCreate or fmShareExclusive);
    mstr := TMyMemoryStream.Create;
//    mstr.Size := sizeof(DBPL_FileVer) + (sizeOf(TplRec)*m3uList.count);
//    mstr.Position := 0;
    mstr.Write(DBPL_FileVer, sizeof(DBPL_FileVer));     //fileVersion

    dateTime := AppFirstRunDate * -1;
    mstr.Write(dateTime, SizeOf(dateTime));

    for i:=0 to m3uList.count-1 do
    begin
      PR := PplRec(m3uList.items[i])^;
      mstr.Write(PR, sizeOf(TplRec))
    end;
    mstr.SaveToFile(settingsdir + 'dbpl.dat');
    mstr.free
end;

procedure TMainForm.Refresh3Click(Sender: TObject);
begin
        PlaylistBoxChange(playlistbox, playlistbox.getfirstselected)
end;

procedure TMainForm.sliderenableTimer(Sender: TObject);
begin
	sliderenable.enabled := false;
  slidertimer.enabled := true
end;

Function TMainForm.WinplaylistChanged(const realPlayFilename: String=''):Boolean;
var
	len:integer;
begin
  len := SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH);

  if pref.ControlPlaylist.checked then
  begin
  	result := (WinampPlaylistRealCount <> len) or (not WinampPlaylistJustChangedByMEXP and not (Q_SameText(realPlayFilename, WinampPlaylistFiles[0]) or Q_SameText(realPlayFilename, WinampPlaylistFiles[1]) or Q_SameText(realPlayFilename, WinampPlaylistFiles[2])));
  end
  else
  	result := integer(winplaylist.RootNodeCount) <> len
//        start := GetTickCount;
{        result := false;
				listlength :=  SendMessage(hwnd_winamp, WM_WA_IPC, 0,IPC_GETLISTLENGTH);
        if winplaylist.rootnodecount <> listlength then
                begin
                        result := true;
                end;
        aNode := winplaylist.GetFirst;
        i:=0;
        while aNode <> nil do
                begin
                        Ch := Pointer(Sendmessage(hwnd_winamp, wm_user, i, 211));
                        s := strPas(ch);
                        if ansilowercase(PplstRec(WinPlayList.GetNodeData(aNode))^.Filename) <> ansilowercase(string(s)) then
                                begin
                                        result := true;
                                        exit
                                end;
                        inc(i);
                        aNode := WinPlayList.GetNext(aNode)
                end; }

//        winplaylist.visiblec
{        for i:=winplaylist.TopRow to winplaylist.TopRow + Winplaylist.VisibleRowCount-1 do
                begin
                        if listlength > i then
                                begin
                                        Ch := Pointer(Sendmessage(hwnd_winamp, wm_user, i, 211));
                                        s := strPas(ch);
                                        if i = 0 then if ansilowercase(winplay.strings[2]) <> ansilowercase(string(s)) then begin result := true;  end;
                                        if i > 0 then if ansilowercase(winplay.strings[(i+1)*2]) <> ansilowercase(string(s)) then begin result := true;  end
                                end;
                        if result then break
                end;                          }
//        i := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS);
//        ch := pointer(SendMessage(hwnd_winamp, WM_WA_IPC, i, IPC_GETPLAYLISTFILE));
//        label5.caption := inttostr(gettickcount-start)
end;

{function CompareCleanDoubles(Item1, Item2: Pointer): integer;
begin
     result := Q_CompText(MainFormInstance.getFtextP(item1, fFilename), MainFormInstance.getFtextP(item2, fFilename))
end; }

procedure TMainForm.CleanDoubles;
var
	i:integer;
  rec1, rec2: PRec;
begin
{
Sger efter filnavne som ligger dobbelt i databasen, og fjerner dem
}
	UpdateHashedReclist;
	if recList.count > 1 then
	begin
    BeginUseReclist;
		for i:= fHashedReclist.count-1 downto 1 do
		begin
    	rec1 := fHashedRecList.List^[i];
      rec2 := fHashedRecList.List^[i-1];
      if (rec1.FilenameHash = rec2.FilenameHash) and (rec1.Location = rec2.Location) and (Q_SameText(GetFTextp(rec1, FFilename), GetFTextp(rec2, FFilename))) then
      	Include(rec1.Flags, rfDeletePending)
		end;
    EndUseReclist
	end;
  ReleaseRecs(false, true);
	RecListToTabel(true, true)
end;

procedure TMainForm.filterbarMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
        filespopup.Popup(filterbar.clienttoscreen(point(0,filterbar.height)).x,filterbar.clienttoscreen(point(0,filterbar.height)).y)
end;

procedure TMainForm.Panel1MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
        treepop.Popup(panel1.clienttoscreen(point(0,panel1.height)).x,panel1.clienttoscreen(point(0,panel1.height)).y)
end;

procedure TMainForm.plabel1MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	if Button = mbRight then
		treeplbarMouseDown(treePlBar, Button, Shift, X, Y)
	else
		plboxpopup.Popup(treeplbar.clienttoscreen(point(0,treeplbar.height)).x,treeplbar.clienttoscreen(point(0,treeplbar.height)).y)
end;

procedure TMainForm.plabel2MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
        Winplaypop.Popup(WPbar.clienttoscreen(point(0,WPbar.height)).x,WPbar.clienttoscreen(point(0,WPbar.height)).y)
end;

procedure TMainForm.menuitembblclick1Click(Sender: TObject);
begin
     pref.dblclick.itemindex := (sender as Tmenuitem).parent.IndexOf((sender as Tmenuitem))
end;

procedure TMainForm.TreeStimerTimer(Sender: TObject);
begin
  TreeS := '';
  TreeSTimer.enabled := false;
  TreeFilter
end;

function TMainForm.QuicklistExists(const name: String):Boolean;
var
	aNode: PVirtualNode;
begin
	result := false;
  aNode := playlistbox.GetFirst;
  while aNode <> nil do
  begin
  	if Q_SameText(PPlBoxData(PlayListBox.GetNodeData(aNode))^.text, name) then
    begin
    	result := true;
      break
    end;
    aNode := playlistbox.GetNext(aNode)
  end
end;

procedure TMainForm.SaveasQuicklist1Click(Sender: TObject);
var     s:string;
        aNode : PVirtualNode;
begin
  s := '';
  if InputBoxx(GetText(TXT_EnterNewQLnameCaption), GetText(TXT_EnterNewQLnameText, ['\ / : * ? " < > |']), s) then
  begin
    Q_TrimInPlace(s);
    if QuicklistExists(s) then
    	ShowmessageX(GetText(TXT_QuicklistAlreadyExists, [s]))
    else
    begin
  	  aNode := playlistbox.AddChild(nil);
	    PPlBoxData(PlayListBox.GetNodeData(aNode))^.TopList := false;
	    PPlBoxData(PlayListBox.GetNodeData(aNode))^.text := s;
	    winplaySaveToFile(settingsdir + '-quicklist\' + s + '.m3u')
    end
  end
end;

procedure TMainForm.TreeExchangeAristAlbumClick(Sender: TObject);
// Convert artist - album
var
  Artist, Album, TreeText :string;
  aNode : pVirtualNode;
  i:integer;
  TR : PTreeRec;
  values : TtagValues;
  recs: TList;
begin
	screen.cursor := crhourglass;

  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  SetFilterFlags;
  tr := tree.GetNodeData(tree.GetFirstSelected);
  TreeText := GetTreeText(tree, tree.GetFirstSelected);
  Artist := cleanString(Q_CopyRange(TreeText,1, Q_PosStr(' - ', TreeText)));
  Album := cleanString(Q_CopyFrom(TreeText, Q_PosStr(' - ', TreeText)+3));
  setLength(values, 2);
  values[0].field := fArtist;
  values[0].value := artist;
  values[1].field := fAlbum;
  values[1].value := album;

  recs := TList.Create;

  if fonlyPL then
  	for i:=0 to Fplaylist.count-1 do
			recs.Add(FPlaylist.items[i])
  else
  	for i:=0 to reclist.count-1 do
  		if filterrec(reclist.List^[i]) then
     		recs.Add(reclist.List^[i]);

  UpdateRecValues(recs, values, 'Tagging...', true, GetDefaultUpdateTags);

  SetLength(values, 0);

  BeginSetArtistAlbumFilename;
  try
    TR.tag := GetArtistID(artist);
    with tree do
    begin
      aNode := Addchild(tree.GetFirstSelected);
      with PTreeRec(tree.getnodedata(aNode))^ do
      begin
        tag := GetAlbumID(album);
        kind := TreeKind_Album;
        Location := TR.Location;
        Exists := TR.exists
      end
    end;
  finally
  	EndSetArtistAlbumFilename
  end;

  AfterTagChanged;
  treefilter;
  screen.cursor := crdefault;

  Dec(SafeToAutoScanCount)
end;

procedure TMainForm.Edittag1Click(Sender: TObject);
var       i:integer;
begin
  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  SetFilterFlags;

  Application.CreateForm(Teditor, Editor);

  if fonlyPL then
  for i:=0 to Fplaylist.count-1 do
    editor.recs.Add(FPlaylist.items[i])
  else
  for i:=0 to reclist.count-1 do
    if filterRec(reclist.List^[i], true) then
       editor.Recs.add(reclist.List^[i]);

  disableAOT;
  CurrentActiveForm := editor;
  if editor.Recs.count > 0 then
  begin
  if Editor.init then
    Editor.ShowModal
  end;
  CurrentActiveForm := nil;
  SetMainFormVisible(true);

  //exitter:
  if Editor.ReadMpegInfo.Runing then
  begin
     screen.cursor := crHourGlass;
     Editor.ReadMpegInfo.Thread.waitFor;
     screen.cursor := crDefault
  end;

  if Editor.LyricsThread.Runing then
  begin
   screen.cursor := crHourGlass;
   Editor.LyricsThread.Thread.Terminate;
   try
    Editor.IdHttp.Disconnect;
   except
   end;
   Editor.LyricsThread.Thread.WaitFor;
   screen.cursor := crDefault
  end;

  if Editor.AnythingChanged then
  begin
    AfterTagChanged;
    updateTree(true);
    tabel.repaint;
    if pref.AutoResizeColumnHeaders.Checked then
    AutoResizeAllColumnsToFit;
    winplaylist.repaint
  end;

  Editor.release;
  freeandnil(Editor);
  Dec(SafeToAutoScanCount);
end;

{procedure TMainForm.ShowDirStrucClick(Sender: TObject);
begin
				ShowDirStruc.Checked := true;
				updatetree
end; }

procedure TMainForm.Scanforduplicates1Click(Sender: TObject);
var
   i:integer;
begin
  screen.cursor := crhourglass;
  CleanDoubles;
  disableAOT;
  Application.CreateForm(TDubWizForm, DubWizForm);
  if fonlyPL then
  for i:=0 to Fplaylist.count-1 do
  	DubWizForm.list.Add(FPlaylist.items[i])
  else
  	for i:=0 to reclist.count-1 do
      if filterRec(reclist.List^[i], true) then
      	DubWizForm.list.Add(reclist.List^[i]);

  dubWizForm.ScanDubs(SLcrc);
  CurrentActiveForm := dubWizForm;
  dubwizform.showmodal;
  CurrentActiveForm := nil;
  RecListToTabel(true, true);
  dubwizForm.tree.clear;
  DubWizForm.release;
  FreeAndNil(DubWizForm);
  SaveAllNoRelease(true);
  screen.cursor := crdefault;
  SetMainFormVisible(true)
end;

   {
procedure TMainForm.Explorer1Click(Sender: TObject);
begin
          if tabel.selectedcount = 0 then exit;
          rec := GetRec(tabel.getfirstselected);
          ShellExecute(MainFormInstance.Handle,
							 nil,
							 pChar('c:\winnt\explorer.exe "' + getfilepath(getFtext(fFilename))+'"'),
               nil,
               pChar('c:\'),
							 SW_SHOWNORMAL)
end;      }

{procedure TMainForm.Locateintree1Click(Sender: TObject);
Function getdbindexFN(name:string):string;
        var i:integer;
        begin
                for i:=0 to length(dbs)-1 do if dbs[i].Name = name then result := inttostr(dbs[i].index)
        end;

var
        aNode:Tflynode;
        ts,s:string;
        so:integer;
begin
        rec := tabel.items.GetFirstSelectedNode.data;

        so := getSO;

        if ShowArtistAlbum1.checked and showmedia1.checked then if rec.compilation then ts := inttostr(rec.location) + '\' + rec.Album +'\' else ts := inttostr(rec.location) + '\' + TheFix(rec.Artist) + '\' + rec.Album +'\';
        if ShowArtistAlbum1.checked and not showmedia1.checked then if rec.compilation then ts := rec.Album +'\' else ts := TheFix(rec.Artist) + '\' + rec.Album +'\';

        if ShowArtistAlbum2.checked then        if showmedia1.checked then ts := inttostr(rec.location) + '\' + TheFix(rec.Artist) + ' - ' + rec.Album +'\' else ts := TheFix(rec.Artist) + ' - ' + rec.Album +'\';
        if ShowGenres1.checked then             if showmedia1.checked then ts := inttostr(rec.location) + '\' + genres[rec.Genre] + '\' + TheFix(rec.Artist) + '\' + rec.Album+'\' else ts := genres[rec.Genre] + '\' + TheFix(rec.Artist) + '\' + rec.Album+'\';
        if ShowAlbum1.checked then              if showmedia1.checked then ts := inttostr(rec.location) + '\' + rec.Album +'\' else ts := rec.Album+'\';

        with Tree do
        case so of
{art\alb0:      begin
                        aNode := items.GetFirstNode;
                        While aNode<>nil do begin
                                if (aNode.parent = nil) or ((aNode.parent <> nil) and (not aNode.parent.selected)) then
                                        if showmedia1.checked then
                                        case aNode.Level of
                                        0: s:= (getdbindexFN(aNode.text)+'\');
                                        1: s:= (getdbindexFN(aNode.parent.text) + '\' + aNode.text+'\');
                                        2: s:= (getdbindexFN(aNode.parent.parent.text) + '\' + aNode.parent.text + '\' + aNode.text+'\');
                                        end
                                        else
                                        case aNode.Level of
                                        0: s:= (aNode.text+'\');
                                        1: s:= (aNode.parent.text + '\' + aNode.text+'\');
                                        end;
                                if s=ts then
                                        begin
                                                aNode.Expand(true);
                                                anode.MakeVisible
                                        end;
                                aNode := aNode.getnext
                                end
                end;
{alb   1:      begin
                aNode := items.GetFirstSelectedNode;
                While aNode<>nil do begin
                        if (aNode.parent = nil) or ((aNode.parent <> nil) and (not aNode.parent.selected)) then
                        if showmedia1.checked then
                        case aNode.Level of
                                0: FtreePath.add(getdbindexFN(aNode.text)+'\');
                                1: FTreePath.add(getdbindexFN(aNode.parent.text) + '\' + aNode.text+'\');
                        end
                        else
                        case aNode.Level of
                                0: FtreePath.add(aNode.text+'\');
                        end;
                dbs[GetDBindex(aNode.StateIndex)].Load := true;
                aNode := items.GetNextSelectedNode(aNode)
                end
                end;
{Genre   2:    begin
                aNode := items.GetFirstSelectedNode;
                While aNode<>nil do begin
                        if (aNode.parent = nil) or ((aNode.parent <> nil) and (not aNode.parent.selected)) then
                        if showmedia1.checked then
                        case aNode.Level of
                                        0: FtreePath.add(getdbindexFN(aNode.text)+'\');
                                        1: FTreePath.add(getdbindexFN(aNode.parent.text) + '\' + aNode.text+'\');
                                        2: FTreePath.add(getdbindexFN(aNode.parent.parent.text) + '\' + aNode.parent.text + '\' + aNode.text+'\');
                                        3: FTreePath.add(getdbindexFN(aNode.parent.parent.parent.text) + '\' + aNode.parent.parent.text + '\' + aNode.parent.text + '\' + aNode.text+'\');
                                        end
                                        else
                                        case aNode.Level of
                                        0: FtreePath.add(aNode.text+'\');
                                        1: FTreePath.add(aNode.parent.text + '\' + aNode.text+'\');
                                        2: FTreePath.add(aNode.parent.parent.text + '\' + aNode.parent.text + '\' + aNode.text+'\');
                                        end;
                dbs[GetDBindex(aNode.StateIndex)].Load := true;
                aNode := items.GetNextSelectedNode(aNode)
                end
                end;
{Art - Art  3:    begin
                aNode := items.GetFirstSelectedNode;
                While aNode<>nil do begin
                        if (aNode.parent = nil) or ((aNode.parent <> nil) and (not aNode.parent.selected)) then
                        if showmedia1.checked then
                        case aNode.level of
                                0: FtreePath.add(getdbindexFN(aNode.text)+'\');
                                1: FTreePath.add(getdbindexFN(aNode.parent.text) + '\' + aNode.text+'\');
                        end
                        else
                        case aNode.Level of
                                0: FtreePath.add(aNode.text+'\');
                        end;
                dbs[GetDBindex(aNode.StateIndex)].Load := true;
                aNode := items.GetNextSelectedNode(aNode)
                end
                end;
				end
end;       }

procedure TMainForm.PaintSlider(percent:double; Visible, SliderVisible:Boolean; keepCurrentPosition:boolean=false);
var
	Xpos:Integer;
begin
	if {(not sliderr.Visible) or }(percent>1) or (percent<0) then
		exit;
	PositionSliderBuffer.width := sliderr.Width;
	PositionSliderBuffer.height := sliderr.Height;
	PositionSliderBuffer.Canvas.StretchDraw(rect(0,0,sliderr.width,sliderr.height), ImgSlider);
	if slidervisible or capturing then
	begin
		if keepCurrentPosition then
			Xpos := sliderXpos
		else
			Xpos := (round((SliderR.width - ImgSliderBtn.width) * percent));
		SliderXpos := Xpos;
		PositionSliderBuffer.Canvas.Draw(Xpos,0, ImgSliderBtn)
	end;
{	OldBkMode := SetBkMode(PositionSliderBuffer.Canvas.Handle,TRANSPARENT);
	with PositionSliderBuffer.Canvas do
	begin
		font.Name := 'Verdana';
		font.Color := PositionSliderTextColor;
		font.height := -9;
		if keepCurrentCaption then
			capt := currentSliderCaption
		else
			currentSliderCaption := capt;
		textOut((SliderR.width div 2) - (TextExtent(Capt).cx div 2),0,capt)
	end;
	SetBkMode(PositionSliderBuffer.Canvas.Handle,OldBkMode);  }
	sliderr.Invalidate//Canvas.draw(0,0,PositionSliderBuffer);
//	bm2.free
end;

function TMainForm.SetVolume(percent:single):Boolean;	// returns true if volume have changed
var
	value:integer;
begin
	if percent > 1 then percent := 1;
	if percent < 0 then percent := 0;

	if percent <> GetVolume then
  begin
		value := Trunc(percent * 255);
   	SendMessage(hwnd_winamp,WM_WA_IPC,value,IPC_SETVOLUME);
    result := true
  end
  else
  	result := false
end;

function TMainForm.GetVolume: single;
var
	value:integer;
begin
	value := SendMessage(hwnd_winamp,WM_WA_IPC,-666,IPC_SETVOLUME);
  result := value/255
end;

procedure TMainForm.SortList1Click(Sender: TObject);
begin
	SetScrollpos(tabel.handle,SB_VERT,100,true);
	sendmessage(tabel.handle,wm_vscroll,0,0);
end;

procedure TMainForm.ToggleExpanded1Click(Sender: TObject);
begin
	if tree.selectedCount <> 1 then
		exit;
	tree.Expanded[tree.GetFirstSelected] := not tree.Expanded[tree.GetFirstSelected]
end;

procedure TMainForm.Resetallfiles1Click(Sender: TObject);
var     i:integer;
begin
	for i:=0 to reclist.count-1 do
		PRec(reclist.List^[i]).Playcount := 0;
	PlaylistboxChange(playlistbox, playlistbox.getfirstselected)
end;

procedure TMainForm.sliderrMouseUp(Sender: TObject;
	Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	if partyMode1.Checked and pref.PartyDisablePlaybackControls.Checked then
  	exit;

  if capturing then
  begin
       releaseCapture;
       capturing := false;
       Jumptotime(round(
       ((sliderXpos) / max(1,sliderr.width-ImgSliderBtn.Width))*slidermax
       ), hwnd_winamp);
  end;
  slidertimer.enabled := true
end;

procedure TMainForm.sliderrMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
	percent:double;
begin
	if (partyMode1.Checked and pref.PartyDisablePlaybackControls.Checked) or not FThumbTrackVisible then
  	exit;
    
	if (x<0) or (x>sliderr.width) or (slidermax = 0) then
		exit;

	if capturing then
	begin
		sliderXpos := sliderXpos + (x - sliderMouseDownX);
		sliderMouseDownX := x;
		percent := min(1, max(0, (sliderXpos) / max(1,sliderr.width-ImgSliderBtn.Width)));

		PaintSlider(percent, true, true);
		UpdateCurrentTimeLabel(true, percent);
    PaintFileInfoLabel
	end
	else
	begin
		if (x>sliderXpos) and (x<sliderXpos+ImgSliderBtn.Width) and (ssLeft in shift) and not capturing then
		begin //den er indenfor thumben
			SetCapture(sliderr.Handle);
			Capturing := true
		end;

		if x < 10 then
			percent := 0
		else
			if x > sliderr.width-10 then
				percent := 1
			else
				percent := min(1, max(0, (x-10) / max(1,sliderr.width-20)));

		PaintSlider(percent, true, true, not Capturing);
		UpdateCurrentTimeLabel(true, percent);
    PaintFileInfoLabel
	end
end;

procedure TMainForm.sliderrMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
	percent: Double;
begin
	if (partyMode1.Checked and pref.PartyDisablePlaybackControls.Checked) or not FThumbTrackVisible then
  	exit;

	sliderMouseDownX := x;
	if (x>sliderXpos) and (x<sliderXpos+ImgSliderBtn.Width) and not capturing then
	begin             //den er indenfor thumben
		SetCapture(sliderr.Handle);
		Capturing := true;
    percent :=   (sliderXpos) / max(1,sliderr.width-ImgSliderBtn.Width);
		PaintSlider(percent,true, true);
		UpdateCurrentTimeLabel(true, percent);
    PaintFileInfoLabel
	end
	else
	begin
	 slidertimer.enabled := false;
	 if x < 10 then percent := 0 else
	 if x > sliderr.width-10 then percent := 1 else
	 percent := min(1, max(0, (x-10) / max(1,sliderr.width-20)));
	 PaintSlider(percent,true,true);
	 UpdateCurrentTimeLabel(true, percent);
   PaintFileInfoLabel;
	 Jumptotime(round(percent*slidermax),(hwnd_winamp))
	end
end;

procedure TMainForm.Changetracknumberto1231Click(Sender: TObject);
var
	track:Integer;
	s: String;
	aNode:pVirtualNode;
	values : PTagValues;
  valuesList, recs: TList;
begin
  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  s := '1';
  if not InputBoxx(GetText(TXT_ChangeTrackNo), GetText(TXT_EnterFirstTrackNo), s) then
	  exit;
  Q_TrimInPlace(s);
  if not Q_IsInteger(s) then
	  exit;

  screen.cursor := crHourglass;

  track := StrToInt(s);
  recs := TList.Create;
  valuesList := TList.Create;

  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
  	recs.Add(GetRec(aNode));
	  New(values);
    SetLength(values^, 1);
   	values^[0].field := fTrack;
    values^[0].value := inttostr(track);

    valuesList.Add(values);
    inc(track);

    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecValues(recs, valuesList, nil, 'Tagging...', true, GetDefaultUpdateTags);

  AfterTagChanged;
  if pref.AutoResizeColumnHeaders.Checked then
    AutoResizeAllColumnsToFit;
  screen.cursor := crDefault;

  Dec(SafeToAutoScanCount);
end;

procedure TMainForm.Organizefiles1Click(Sender: TObject);
var       i:integer;
begin
  disableAOT;
  Application.CreateForm(TOrgFiles, OrgFiles);

  if fonlyPL then
    for i:=0 to Fplaylist.count-1 do
        OrgFiles.list.Add(FPlaylist.items[i])
  else
  for i:=0 to reclist.count-1 do
     if filterrec(reclist.List^[i]) then
        OrgFiles.list.Add(reclist.List^[i]);
               
  CurrentActiveForm := OrgFiles;
  if OrgFiles.init then
    OrgFiles.showmodal;
  CurrentActiveForm := nil;
  OrgFiles.release;
  FreeAndNil(OrgFiles);
  UpdateHashedReclist;
  SaveAllNoRelease(true);
  updateTree(true);
  SetMainFormVisible(true)
end;

procedure TMainForm.Help1Click(Sender: TObject);
var
  tmp : PChar;
 begin
	tmp := StrAlloc(Length('file://'+plugindir + AppName + '\help\index.htm')+1);
  tmp := StrPCopy(tmp,'file://'+plugindir + AppName + '\help\index.htm');
  Sendmessage(hwnd_winamp,wm_user,0,241);
  Sendmessage(hwnd_winamp,wm_user,integer(tmp),241);
  StrDispose(tmp)
end;

procedure TMainForm.tabelInitNode(Sender: TBaseVirtualTree; ParentNode,
  Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates);
var     Data: pTreeData;
begin
//	tabel.IsVisible[Node] := fOnlyPL;     //m ikke vre der...
	data :=  tabel.GetNodeData(Node);
	if fOnlyPL then
		data.p := fPlaylist.List^[node.index]
	else
		data.p := reclist.List^[node.index]
end;

procedure TMainForm.tabelGetText(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
  var Text: WideString);
var
	rec: Prec;
begin
	try
  	rec := GetRec(Node);
    if assigned(rec) then
    begin
	  	if column in [22, 24, 26] then //22 er lyrics, 24 er rating, 26 er autoscanned
	      text := ' '
	    else
	    if (column = 25) and (rec.Artist = rec.ArtistSortOrder) then
      	text := ''
      else
	    if column >= 0 then
				GetFTextP(rec, tabel.Header.columns[column].tag, text)
    end
 	except
		text := 'Error: ' + inttostr(tabel.Header.columns[column].tag) ;
	end
end;

procedure TMainForm.tabelPaintText(Sender: TBaseVirtualTree;
  const Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  TextType: TVSTTextType);
var
	r:Prec;
begin
	r := getrec(node);
	if r = nil then
		exit;

	if rfplaying in r.Flags then
	begin
		if not (fsBold in canvas.Font.Style) then
			canvas.font.style := canvas.font.style + [fsBold]
	end else
	begin
		if fsBold in canvas.Font.Style then
			canvas.font.style := canvas.font.style - [fsBold]
	end;

	if vsSelected in node.states then
	begin
		if canvas.font.color <> tabelSelTextcolor then
			canvas.font.color := TabelSelTextColor;
		if dbs[r.location].exists or (not showmedia1.checked) then
		begin
			if fsItalic in canvas.font.Style then
				canvas.font.style := canvas.font.style - [fsitalic]
		end
		else
		begin
			if not (fsItalic in canvas.Font.Style) then
				canvas.font.style := canvas.font.style + [fsitalic]
		end
	end else
	begin
		//if canvas.Font.Color <> dbs[r.location].color then
    canvas.font.color := GetDatabaseColor(r.location);	//dbs[r.location].color;
		if dbs[r.location].exists {or (not showmedia1.checked)} then       // "or (not showmedia1.checked)" removed 13/07/05
		begin
			if fsItalic in canvas.font.Style then
				canvas.font.style := canvas.font.style - [fsitalic]
		end
		else
		begin
			if not (fsItalic in canvas.Font.Style) then
				canvas.font.style := canvas.font.style + [fsitalic]
		end
	end
end;

procedure TMainForm.treeInitNode(Sender: TBaseVirtualTree; ParentNode,
  Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates);
begin
	exclude(InitialStates,ivsSelected);
end;

procedure TMainForm.treeGetText(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType; var Text: WideString);
var
	TR : PTreeRec;
begin
	TR := PTreeRec(sender.getNodeData(Node));

  if (Column <> 500) and pref.cbShowCoverInTree.Checked and not (tree.IsEditing and (Node = Tree.FocusedNode)) and assigned(tr.CoverRec) and ((tr.CoverRec.State = ImageLoaded) and not (crfInvalidateThumb in tr.CoverRec.Flags) and assigned(tr.CoverRec.Image)) and not ((tree.IsEditing or (tsEditPending in tree.TreeStates)) and (Node = Tree.FocusedNode)) then
  begin
  	Text := ' ';
    exit
  end;

  if TR.Kind = TreeKind_Rating then
  begin
  	if Column = 500 then
    	text := inttostr(TR.Tag) + ' star rating'	//bruges til at genkende noden nr updatetree kres
    else
	  	text := ' ';
  end
  else
	if TR.Kind = TreeKind_Group then
		text := PGroupRec(PTreeRec(sender.getNodeData(Node))^.PLrecRef).Name
  else
  if TR.Kind = TreeKind_Playlist then
		text := PplRec(PTreeRec(sender.getNodeData(Node))^.PLrecRef).Name
  else
  if TR.Kind = TreeKind_GroupParent then
  	text := GetText(TXT_Groups)
  else
  if TR.Kind = TreeKind_playlistParent then
  	text := GetText(TXT_Playlists)
  else
  if TR.Kind = TreeKind_CompilationParent then
  	text := GetText(TXT_Compilations)
	else
  if TR.Kind = TreeKind_Artist then
  	text := ArtistList.Strings[TR.tag]
  else
  if TR.Kind = TreeKind_Genre then
  	text := GenreList.Strings[TR.Tag]
  else
  if TR.Kind in [TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum] then
  	text := AlbumList.Strings[TR.tag]
  else
  if (TR.Kind in [TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum]) and tree.IsEditing and (Node = tree.FocusedNode) then
  	text := albumList.Strings[TR.Tag]
  else
  if TR.Kind = TreeKind_Year then
    text := IntToStr(TR.Tag)
  else
  if TR.Kind = TreeKind_Decade then
  	text := GetText(TXT_DecadeIes, [inttostr(TR.Tag)])
	else
  if TR.Kind = TreeKind_GroupSetting then
  begin
  	case TR.Tag of
    	1: text := GetText(TXT_Exclusive);
      2: text := GetText(TXT_AndOperator);
    end
  end
  else
  if TR.Kind = TreeKind_Set then
  begin
  	if GetTotalParts(TR.Tag) > 0 then
    	text := inttostr(GetPartOfSet(TR.Tag)) + '/' + inttostr(GetTotalParts(TR.Tag))
    else
    	text := inttostr(GetPartOfSet(TR.Tag))
  end
	else
		text := PTreeRec(sender.getNodeData(Node))^.Text
end;

procedure TMainForm.treeGetImageIndex(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
  var Ghosted: Boolean; var Index: Integer);
var     Data:PTreeRec;
begin
	Ghosted := false;
	Data := Tabel.GetNodeData(node);
	case data.Kind of
		TreeKind_Harddisk:      Index := 0;
		TreeKind_NetWork:       if dbs[data.location].exists then index := 17 else index := 18;
		TreeKind_CDrom:         if dbs[data.location].exists then index := 5 else index := 4;
		TreeKind_Zip:						if dbs[data.location].exists then index := 3 else index := 2;
		TreeKind_PlaylistParent:        Index := 1;
		TreeKind_Playlist:              Index := 10;
		TreeKind_Artist:        if tree.HasChildren[Node] then Index := 12 else Index := 13;
		TreeKind_Album, TreeKind_YearAlbum, TreeKind_ArtistAlbum: if tree.HasChildren[Node] then Index := 8 else Index := 9;

		TreeKind_CompilationParent:	if tree.HasChildren[Node] then Index := 20 else Index := 21;
		TreeKind_CompilationAlbum:	if tree.HasChildren[Node] then Index := 33 else Index := 34;
    TreeKind_PartialCompilationAlbum:	if tree.HasChildren[Node] then Index := 29 else Index := 30;
    TreeKind_FullCompilationAlbum:	if tree.HasChildren[Node] then Index := 31 else Index := 32;

		TreeKind_GroupParent:	Index := 22;
		TreeKind_Genre:         if tree.HasChildren[Node] then Index := 6 else Index := 7;
		TreeKind_Drive, TreeKind_DriveRecursive:         Index := 14;
		TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive:
			if (vsSelected in node.States) or (vsExpanded in node.states) then
				Index := 16
			else Index := 15;
  	TreeKind_CustomField: index := PCustomField(FieldList.Items[Data.Tag]).IconIndex;

    TreeKind_PartialAlbum, TreeKind_PartialYearAlbum, TreeKind_PartialArtistAlbum:
    												if TreeImgs.Count <= 23 then
    													if tree.HasChildren[Node] then Index := 8 else Index := 9
    												else
                            	if tree.HasChildren[Node] then Index := 23 else Index := 24;

    TreeKind_FullAlbum, TreeKind_FullYearAlbum, TreeKind_FullArtistAlbum:
    												if TreeImgs.Count <= 23 then
    													if tree.HasChildren[Node] then Index := 8 else Index := 9
    												else
                            	if tree.HasChildren[Node] then Index := 25 else Index := 26;

    TreeKind_Set:						if TreeImgs.Count <= 23 then
    													if tree.HasChildren[Node] then Index := 8 else Index := 9
    												else
                            	if tree.HasChildren[Node] then Index := 27 else Index := 28;

  	TreeKind_Year, TreeKind_Decade:
                            	if tree.HasChildren[Node] then Index := 35 else Index := 36

	end
end;

procedure TMainForm.treePaintText(Sender: TBaseVirtualTree;
  const Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
	TextType: TVSTTextType);
var
	data : PTreeRec;
begin
	data := sender.getNodeData(Node);
	if tree.IsEditing and (tree.FocusedNode = node) then
	begin
		canvas.Font.Color := clBtnText;
		exit
	end;
        
	if ((node.Parent = tree.rootnode) and showmedia1.checked) or (data.Kind = TreeKind_CompilationParent) then
	begin
		canvas.font.style := [fsBold]
	end;

	if vsselected in node.states then
	begin
		canvas.font.color := TreeSelTextColor;
		if (not showmedia1.checked) or (data.Location = -1) or dbs[data.Location].exists then
			canvas.font.style := [] + canvas.font.style
		else canvas.font.style := [fsitalic];

		if fOnlyPL and (data.kind = TreeKind_PlayList) then
			canvas.font.style := canvas.font.style + [fsBold]
	end else
	begin
		if not (data.kind in [TreeKind_GroupParent, TreeKind_Group, TreeKind_PlaylistParent, TreeKind_Playlist]) then
			if (data.Location = -1) then
				canvas.font.Color := GetDatabaseColor(0) //dbs[0].color
			else
				canvas.font.color := GetDatabaseColor(Data.Location); //dbs[Data.Location].color;

		if (not showmedia1.checked) or (data.Location = -1) or dbs[data.Location].exists then
			canvas.font.style := [] + canvas.font.style
		else
			canvas.font.style := [fsitalic]
	end;

	case data.Kind of
  	TreeKind_GroupSetting:
    	canvas.Font.Style := [fsBold];

    TreeKind_Group:
    	begin
      	if PGroupRec(data.PLrecRef).SelectedFilesInGroup then
        	canvas.Font.Style := [fsBold]
      end
  end;
end;

procedure TMainForm.treeIncrementalSearch(Sender: TBaseVirtualTree;
  Node: PVirtualNode; const Text: WideString; var Result: Integer);
begin
	if Q_SameTextL(GetTreeText(Tree, Node), text, length(text)) then
  	result := 0
  else
  	result := -1
end;

procedure TMainForm.treeEditing(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
begin
	if PartyMode1.Checked and (pref.DisableTagging.Checked or pref.DisableDBmanagement.checked) then
		Allowed := false
	else
 		Allowed := ((PtreeRec(tree.getnodedata(Node))^.Kind in [TreeKind_Year, TreeKind_Artist, TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_Harddisk, TreeKind_Zip, TreeKind_Network, TreeKind_CdRom, TreeKind_PlayList]) and ((PtreeRec(tree.getnodedata(Node))^.Location = -1) or dbs[PtreeRec(tree.getnodedata(Node))^.Location].exists))
  OR (PtreeRec(tree.getnodedata(Node))^.Kind = TreeKind_Group);

  if Allowed then
  	Tree.InvalidateNode(Node);
end;

function TMainForm.GetProxySettingsFromWinamp(var address: String; var port: Integer; var username: String; var password: String): Boolean;
var
	f: TextFile;
  s: String;
  i: Integer;
begin
//username:userpassword@server:port
  result := false;
  address := '';
  port := 0;
  username := '';
  password := '';
	s := winampDir + 'winamp.ini';
  if Fileexists(s) then
  begin
  	FileMode := 0;
    AssignFile(f, s);
    Reset(f);
    while not eof(f) do
    begin
    	readLn(f, s);
      if Q_SameTextL(s, 'proxy=', 6) then
      begin
        result := true;
      	Q_CutLeft(s, 6);
        Q_TrimInPlace(s);
        //Finder username:password
        i := Q_StrScan(s, '@');
        if i > 0 then
        begin
        	password := Q_CopyRange(s, 1, i-1);
          Q_CutLeft(s, i);
          i := Q_StrScan(password, ':');
          if i > 0 then
          begin
          	username := Q_CopyRange(password, 1, i-1);
            Q_CutLeft(password, i)
          end
        end;
        i := Q_StrScan(s, ':');
        if i > 0 then
        begin
        	address := Q_CopyRange(s, 1, i-1);
          Q_CutLeft(s, i);
          if Q_IsInteger(s) then
          	port := StrToInt(s)
        end
        else
        	address := s;
        break
      end
    end;
    CloseFile(f)
  end
end;

function TMainForm.Id3v1EqualsId3v2(const Fid3v1: TID3v1Tag; const FId3v2: TMyId3Controller): Boolean;
function match(v1Value: String; v2FrameId: TJvID3FrameID; len: Integer): Boolean;
var
	s: String;
begin
	s := Fid3v2.GetText(v2FrameId);
  if length(s) > 0 then
  begin
		if length(s) > length(v1Value) then
    	v1Value := Q_PadRight(v1Value, min(len, length(s)), ' ');
  	result := Q_SameStrL(v1Value, s, len)
  end
  else
  	result := length(trim(v1Value)) = 0
end;
var
	s: String;
  b1, b2, v2CommentFound: Boolean;
  i, id: Integer;
  id3LstFrm: TJvID3SimpleListFrame;
  id3ContentFrm: TJvID3ContentFrame;
begin
	result := assigned(Fid3v1) and assigned(FId3v2);
  if result then
  begin
	  result := result and match(FId3v1.Title, fiTitle, 30);
    result := result and match(FId3v1.Artist, fiLeadArtist, 30);
    result := result and match(FId3v1.Album, fiAlbum, 30);
    result := result and (match(FId3v1.Year, fiYear, 4) or match(FId3v1.Year, fiRecordingTime, 4));

    if result then	//compare track
    begin
      s := fId3v2.GetText(fiTrackNum);
    	if length(s) > 0 then
        result := Fid3v1.Track = GetTrackNoInt(s)
      else
      	result := Fid3v1.Track = 0;
    end;

  	if result then	//compare genre
  	begin
      id3LstFrm := TJvID3SimpleListFrame.Find(FId3v2, fiContentType);
      if Assigned(id3LstFrm) then
      begin
        if (id3LstFrm.List.Count = 0) and (FId3v1.GenreID > MAXGENRES) then
        	result := true
        else
        begin
	        b1 := false;	// check match on genre
          b2 := false;	// check if a valid v1 genre
	        for i:=0 to id3LstFrm.List.Count-1 do
          begin
            id := GetGenreID(id3LstFrm.List[i]);
	        	b1 := b1 or (Fid3v1.GenreID = id);
            b2 := b2 or (id <= MAXGENRES)
          end;
          if not b1 then
          	result := not b2 and (FId3v1.GenreID > MAXGENRES)
        end;
      end
    	else
      	result := FId3v1.GenreID > MAXGENRES
    end;

    if result then	//comment
    begin
    	result := false;
      v2CommentFound := false;

      for i:=0 to FId3v2.Frames.Count-1 do
      	if (FId3v2.Frames[i].FrameID = fiComment) then
        begin
          id3ContentFrm := TJvID3ContentFrame(FId3v2.Frames[i]);
          if length(id3ContentFrm.description) = 0 then
          begin
          	v2CommentFound := true;
	          if FId3v1.v1 then
	          	result := result or Q_SameStrL(FId3v1.Comment, id3ContentFrm.Text, 30)
	          else
	          	result := result or Q_SameStrL(FId3v1.Comment, id3ContentFrm.Text, 28)
          end
        end;
      if not v2CommentFound then
      	result := length(trim(FId3v1.Comment)) = 0
    end
  end;
end;


function TMainForm.HasMexpPrivateFrame(FId3v2:TMyID3Controller; deleteFrame:boolean=false): boolean;
var
	i:integer;
  s: string;
begin
  Result := false;
  i := 0;
  while i < FId3v2.Frames.Count do
  begin
    result := false;
  	if FId3v2.Frames[i].FrameID = fiPrivate then
	  begin
      with TJvID3BinaryFrame(FId3v2.Frames[i]) do
      begin
        if DataSize >= 12 then
        begin
          SetString(s, PAnsiChar(Data), 12);
          Result := Q_SameStr(s, 'www.mexp.dk' + #0)
        end
      end
  	end;

	  if Result and deleteFrame then
    	FId3v2.Frames.Remove(Fid3v2.Frames[i])
    else
    	inc(i);

	  if Result and not deleteFrame then
    	break
  end
end;

function TMainForm.GetTrackString(track, totalTracks: Integer): String;
begin
	if (track >0) and (TotalTracks >0) then
  	result := IntToStr(track) + '/' + IntToStr(TotalTracks)
  else
  if (track >0) and (TotalTracks =0) then
  	result := IntToStr(track)
  else
  if (track =0) and (TotalTracks >0) then
  	result := '/' + IntToStr(TotalTracks)
  else
  	result := ''
end;

function TMainForm.GetPartsString(part, totalParts: Integer): String;
begin
	if (part >0) and (totalParts >0) then
  	result := IntToStr(part) + '/' + IntToStr(totalParts)
  else
  if (part >0) and (totalParts =0) then
  	result := IntToStr(part)
  else
  if (part =0) and (totalParts >0) then
  	result := '/' + IntToStr(totalParts)
  else
  	result := ''
end;

function TMainForm.GetPartsString(rec: Prec): String;
begin
	 result := GetPartsString(rec.PartOfSet);
end;

function TMainForm.GetPartsString(bt: byte): String;
begin
	result := GetPartsString(GetPartOfSet(bt), GetTotalParts(bt));
end;

function TMainForm.GetTrackString(rec: pointer): String;
begin
	result := GetTrackString(Prec(rec).Track, Prec(rec).TotalTracks)
end;

function TMainForm.GetTrackNo(const s: String): String;
begin
	if Q_StrScan(s, '/') > 0 then
  	result := Q_CopyRange(s, 1, Q_StrScan(s, '/')-1)
  else
  	result := s
end;

function TMainForm.GetTotalTracks(const s: String): String;
begin
	if Q_StrScan(s, '/') > 0 then
  	result := Q_CopyFrom(s, Q_StrScan(s, '/')+1)
  else
  	result := ''
end;

function TMainForm.GetTrackNoInt(s: String): Integer;
begin
	s := GetTrackNo(s);
  if Q_IsInteger(s) then
  	result := StrToInt(s)
  else
  	result := 0
end;

function TMainForm.GetTotalTracksInt(s: String): Integer;
begin
	s := GetTotalTracks(s);
  if Q_IsInteger(s) then
  	result := StrToInt(s)
  else
  	result := 0
end;

function TMainForm.GetV2GenreString(p:pointer; version :TJvID3Version):String;
function IsV1Genre(s:String):Boolean;
var      i:integer;
begin
	result := false;
	if length(trim(s))=0 then
		result := true
	else
		for i:=0 to MaxGenres do
			result := result or Q_SameText(s, GenreList.Strings[i])
end;

Function getRealV1Genre(s:String):integer;
var
	i:integer;
begin
	Q_trimInPlace(s);
	result := 255;
	for i:=0 to MAXGENRES do
		if Q_sameText(GENRES[i], s) then result := i
end;

// Returns the string to save in the tag (TCON)
var
	value: string;
	StrLst: TStringlist;
	i: integer;
	rec: PRec;
begin
	rec := p;
	StrLst := TStringlist.Create;
	for i:=0 to length(rec.Genre)-1 do
		StrLst.add(GenreList.Strings[rec.Genre[i]]);

	// find id3v1 genres
	i:=0;
	while i < StrLst.count do
	begin
	 if IsV1Genre(StrLst.strings[i]) then
	 begin
				if version < ive2_4 then
          value := value + '(' + inttostr(getRealV1Genre(StrLst.strings[i])) + ')'
				else
          value := value + #0 + inttostr(getRealV1Genre(StrLst.strings[i]));
				StrLst.Delete(i)
	 end else inc(i)
	end;

	// add the rest of the genres
	for i:=0 to StrLst.count-1 do
	begin
		if version < ive2_4 then
		begin
			if (length(StrLst.Strings[i])>3) and (StrLst.Strings[i][1]='(') then
				value := value + '(' + StrLst.Strings[i]
			else value := value + StrLst.Strings[i];
				break // there can only be one "custom" genre in id3v2.3
		end
		else
    	value := value + #0 + StrLst.Strings[i]
	end;
	StrLst.free;
	Q_TrimInPlace(value);

	result := value
end;

procedure TMainForm.BeginWriteToFile(pr: Pointer);
begin
	FWriteToFileTestPlaying := AudioTypes[PRec(pr).AudioType].StopWinampWhenEdit and isPlayingInWinamp(GetFTextP(pr, FFilename));
	if FWriteToFileTestPlaying then
	begin
		FWriteToFileTestPlayingCode := playbackstatus(hwnd_winamp); //0=stop, 1=playing, 3=paused
		if FWriteToFileTestPlayingCode in [1, 3] then
		begin
			FWriteToFileTestPlayingTime := GetOutPutTime(0, hwnd_winamp);
			Button4(hwnd_winamp) //stop
		end
	end
end;

procedure TMainForm.EndWriteToFile(pr: Pointer);
begin
	if FWriteToFileTestPlaying and (FWriteToFileTestPlayingCode in [1, 3]) and (playbackstatus(hwnd_winamp)=0) then
	begin
			button2(hwnd_winamp);
			JumpToTime(FWriteToFileTestPlayingTime, hwnd_Winamp);
			if FWriteToFileTestPlayingCode = 3 then
				button3(hwnd_winamp)
	end;
	FWriteToFileTestPlaying := false
end;

Procedure TMainForm.SaveId3v2PrivateFrame(const FId3v2: TMyID3Controller; const rec: PRec);
var
	Mstr: TStream;
	Value : String;
	i, k: Integer;
	b: byte;
begin
	//clearing old data:
	HasMexpPrivateFrame(FId3v2, true);

	if (length(rec.groups)>0) or (rfCompilation in rec.Flags) then
	begin
		MStr := TMemoryStream.create;
		value := 'www.mexp.dk' + #0;
		Mstr.Write(Value[1], length(value));
		for i:=0 to length(Rec.groups)-1 do
		if length(PGroupRec(Grouplist.items[Rec.groups[i]]).Name)>0 then
		begin
			b := 1;
			Mstr.write(b, sizeOf(b)); //group

			value := PGroupRec(Grouplist.items[Rec.groups[i]]).Name;
			k := length(value) +1; //+1 er til textencoding
			MStr.write(k, sizeOf(k));

			b := 0; //ASCII
			Mstr.write(b, sizeOf(b)); //text encoding

			MStr.Write(Value[1], length(value))
		end;

		if rfCompilation in rec.Flags then
		begin
			b := 2;
			Mstr.write(b, sizeOf(b)); //compilation
			k := 0;
			Mstr.write(k, sizeOf(K)) //length
		end;

    TJvID3BinaryFrame(FId3v2.AddFrame(fiPrivate)).LoadFromStream(Mstr);
		Mstr.free
	end
end;

procedure TMainForm.SaveAPEprivateFrame(const FApe: TApeTag; const p: Pointer; saveGroups: Boolean =true);
var
	i: Integer;
	s, value: String;
	r: Prec;
begin
	r := p;

	for i := FApe.AddList.Count-1 downto 0 do
	begin
		s := FApe.GetAddListKeyName(TStream(FApe.AddList.Items[i]), value);
		if Q_SameText(s, ApeOggGroupIdent) or Q_SameText(s, ApeOggCompilationIdent) then
		begin
			TStream(FApe.AddList.Items[i]).free;
			FApe.AddList.Delete(i)
		end
	end;

	if saveGroups and (length(r.groups)>0) then
	begin
		value := '';
		for i:=0 to length(R.groups)-1 do
			if length(PGroupRec(Grouplist.items[R.groups[i]]).Name)>0 then
				value := value + #0 + PGroupRec(Grouplist.items[R.groups[i]]).Name;
		if length(value)>0 then
		begin
			Q_CutLeft(value, 1);
			FApe.AddKeyToAddList(ApeOggGroupIdent, value)
		end
	end;

	if saveGroups and (rfCompilation in r.Flags) then
	begin
		value := '1';
		FApe.AddKeyToAddList(ApeOggCompilationIdent, value)
	end;
end;

procedure TMainForm.SaveWMAprivateFrame(const FWMA: TWMAFILE; const p: Pointer; saveGroups: Boolean =true);
var
	i: Integer;
	s: String;
  wsValue: wideString;
	r: Prec;
begin
	//checker groups + compilation
	r := p;
	
	for i := FWMA.AddList.Count-1 downto 0 do
	begin
		s := FWMA.GetAddListKeyName(TStream(FWMA.AddList.Items[i]), wsValue);
		if Q_SameText(s, WMAGroupIdent) or Q_SameText(s, WMACompilationIdent) then
		begin
			TStream(FWMA.AddList.Items[i]).free;
			FWMA.AddList.Delete(i)
		end
	end;

	if saveGroups and (length(r.groups)>0) then
	begin
		wsValue := '';
		for i:=0 to length(R.groups)-1 do
			if length(PGroupRec(Grouplist.items[R.groups[i]]).Name)>0 then
				wsValue := wsValue + #0 + PGroupRec(Grouplist.items[R.groups[i]]).Name;
		if length(wsValue)>0 then
		begin          
    	wsValue := Q_CopyRange(wsValue, 2, length(wsValue));
			//Q_CutLeft(wsValue, 1);
			FWMA.AddKeyToAddList(WMAGroupIdent, wsValue)
		end
	end;

	if saveGroups and (rfCompilation in r.Flags) then
	begin
		wsValue := '1';
		FWMA.AddKeyToAddList(WMACompilationIdent, wsValue)
	end
end;

procedure TMainForm.SaveOGGprivateFrame(const FOgg: TOggVorbis; const p: Pointer; saveGroups: Boolean =true);
var
	i: Integer;
	s, value: String;
	r: Prec;
begin
	//checker groups + compilation
	r := p;

	for i := FOgg.AdditionalTags.Count-1 downto 0 do
	begin
		s := FOgg.GetAddListKeyName(FOgg.AdditionalTags.Strings[i], value);
		if Q_SameText(s, ApeOggGroupIdent) or Q_SameText(s, ApeOggCompilationIdent) then
			FOgg.AdditionalTags.Delete(i)
	end;

	if saveGroups and (length(r.groups)>0) then
		for i:=0 to length(R.groups)-1 do
			if length(PGroupRec(Grouplist.items[R.groups[i]]).Name)>0 then
				FOgg.AddKeyToAddList(ApeOggGroupIdent, PGroupRec(Grouplist.items[R.groups[i]]).Name);

	if saveGroups and (rfCompilation in r.Flags) then
		FOgg.AddKeyToAddList(ApeOggCompilationIdent, '1')
end;

Function TMainForm.GetDefaultUpdateTags: boolean;
begin
	result := pref.MainListUpdateTags.Checked
end;

Function TMainForm.GetDefaultUpdateRecTagOption(updateTags: boolean; tagIdx: integer): UpdateRecTagOption;
var
	force: boolean;
begin
	if not updateTags then
  	result := UpdateRecTagOption_DontUpdate
  else
  begin
		case tagIdx of
	  	tagId3v1: force := Pref.forceId3v1.Checked;
	    tagId3v2: force := Pref.forceId3v2.Checked;
	    tagApe: force := Pref.forceApe.Checked;
	    tagWma: force := Pref.forceWma.Checked;
	    tagOgg: force := Pref.forceOgg.Checked;
	  else
	  	force := false
	  end;

    if force then
    	result := UpdateRecTagOption_UpdateElseCreate
    else
    	result := UpdateRecTagOption_UpdateIfExists
  end
end;

procedure TMainForm.UpdateRecValues(rec: PRec; values: TtagValues; var errMsg: String; updateTags: boolean);
begin
	UpdateRecValues(rec, values, errMsg,
  	GetDefaultUpdateRecTagOption(updateTags, tagId3v1),
  	GetDefaultUpdateRecTagOption(updateTags, tagId3v2), GetDefaultUpdateRecTagOption(updateTags, tagApe),
    GetDefaultUpdateRecTagOption(updateTags, tagWma), GetDefaultUpdateRecTagOption(updateTags, tagOgg))
end;

Function TMainForm.UpdateRecValues(recs: TList; valuesList: TList; rollbackValuesList: TList; progressBoxCaption: String; showCancelButton: boolean; id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmaOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption): UpdateRecValuesResult;
var
	i, j: integer;
	values: PTagValues;
  proForm : TInputbox2;
  cancelPressed: Boolean;
	errMsg, errMsgTotal: string;
begin
	result := UpdateRecValuesResult_Success;
  proForm := nil;
	if (recs.Count > 0) and (recs.Count = valuesList.Count) and ((rollbackValuesList = nil) or (rollbackValuesList.Count = recs.Count))  then
  begin
  	cancelPressed := false;

    if recs.Count > 1 then
    begin
	  	ShowProcessDlg(progressBoxCaption, recs.Count, showCancelButton, ProForm);
		  ProForm.Show;
			ProForm.Repaint
    end;

  	errMsgTotal := '';
  	for i:=0 to recs.Count-1 do
    begin
    	values := valuesList.Items[i];

      errMsg := '';
      UpdateRecValues(recs.Items[i], values^, errMsg, id3v1Opt, id3v2opt, ApeOpt, WmaOpt, OggOpt);
      if length(errMsg) > 0 then
    		errMsgTotal := errMsgTotal + CRLF + CRLF + 'Error tagging file "' + MainFormInstance.GetFTextP(recs.items[i], FFILENAME) + '":' + CRLF + errMsg;

      if assigned(proForm) then
      begin
	      ProForm.Pbar.Position := i+1;
	      application.ProcessMessages;
	      cancelPressed := showCancelButton and ProForm.CancelPressed;
      end;
	    if cancelPressed then
      begin
      	//Rollback
      	ProForm.Button2.Enabled := false;

        if rollbackValuesList <> nil then
        begin
	        for j:=i downto 0 do
          begin
          	values := rollbackValuesList.Items[j];
            errMsg := '';
			      UpdateRecValues(recs.Items[j], values^, errMsg, id3v1Opt, id3v2opt, ApeOpt, WmaOpt, OggOpt);
			      if length(errMsg) > 0 then
			    		errMsgTotal := errMsgTotal + CRLF + CRLF + 'Error tagging file (roll-back) "' + MainFormInstance.GetFTextP(recs.items[j], FFILENAME) + '":' + CRLF + errMsg;

            if assigned(proForm) then
            begin
			      	ProForm.Pbar.Position := j+1;
				      application.ProcessMessages;
            end
          end;
        end;
        result := UpdateRecValuesResult_Cancelled;
        break;	//break for i:=0 to recs.Count-1
    	end;
    end;

    if length(errMsgTotal) > 0 then
		begin
  		Q_CutLeft(errMsgTotal, 2);
		 	MainFormInstance.Showmessagex(errMsgTotal);
      if result = UpdateRecValuesResult_Success then
      	result := UpdateRecValuesResult_Error
	  end;
	end;

  for i:=0 to valuesList.Count-1 do
  begin
  	values := valuesList.Items[i];
    Finalize(values^);
    Dispose(values)
  end;

  if rollbackValuesList <> nil then
  begin
	  for i:=0 to rollbackValuesList.Count-1 do
	  begin
	  	values := rollbackValuesList.Items[i];
	    Finalize(values^);
	    Dispose(values)
	  end;
    rollbackValuesList.Free;
  end;

  valuesList.Free;
  recs.Free;

   if assigned(proForm) then
   begin
   	ProForm.release;
	  FreeAndNil(ProForm)
   end
end;

Function TMainForm.UpdateRecValues(recs: TList; valuesList: TList; rollbackValuesList: TList; progressBoxCaption: String; showCancelButton: boolean; updateTags:boolean): UpdateRecValuesResult;
begin
	result := UpdateRecValues(recs, valuesList, rollbackValuesList, progressBoxCaption, showCancelButton,
  	GetDefaultUpdateRecTagOption(updateTags, tagId3v1),
  	GetDefaultUpdateRecTagOption(updateTags, tagId3v2), GetDefaultUpdateRecTagOption(updateTags, tagApe),
    GetDefaultUpdateRecTagOption(updateTags, tagWma), GetDefaultUpdateRecTagOption(updateTags, tagOgg))
end;

procedure TMainForm.UpdateRecValues(recs: TList; values: TtagValues; progressFormCaption: String; allowCancel:boolean; updateTags:boolean);
var
	i, j: integer;
	valuesList: TList;
  newValues :PTagValues;
begin
	valuesList:= TList.Create;

  for i:=0 to recs.Count-1 do
  begin
  	new(newValues);
    SetLength(newValues^, length(values));
    for j:=0 to length(values)-1 do
    begin
    	newValues^[j].field := values[j].field;
      newValues^[j].customFieldIndex := values[j].customFieldIndex;
    	newValues^[j].value := values[j].value
    end;
    valuesList.Add(newValues);
  end;

  UpdateRecValues(recs, valuesList, nil, progressFormCaption, allowCancel, updateTags)
end;

procedure TMainForm.UpdateRecValues(rec: PRec; values: Ttagvalues; updateTags:boolean);
var
	errMsg: string;
begin
	UpdateRecValues(rec, values, errMsg, updateTags);
	if length(errMsg) > 0 then
  begin
    MainFormInstance.Showmessagex(errMsg)
  end;
end;

procedure TMainForm.UpdateRecValues(rec: PRec; values:  Ttagvalues; var errMsg: String; id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmaOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption);
// Currently supports: artist, title, album, track, TotalTracks, comment, year, genre (FGenre, FAddGenre, FRemoveGenre), compilation, Groups (FAddGRoup, FRemoveGroup), FPartOfSetText, FRating, FCustomField

Procedure SaveV2Frame(FId3v2:TMyId3Controller; fieldId: TJvID3FrameID; const value: String);
var
	i:cardinal;
  contentFrm: TJvID3ContentFrame;
  empty: boolean;
begin
  empty := Length(value) = 0;

  if fieldId = fiComment then
  begin
    // find comment with empty description
    contentFrm := nil;
    for i:=0 to FId3v2.Frames.Count-1 do
    begin
      if (FId3v2.Frames[i].FrameID = fiComment) and (Length(TJvId3ContentFrame(FId3v2.Frames[i]).Description) = 0) then
      begin
        contentFrm := TJvId3ContentFrame(FId3v2.Frames[i]);
        break
      end
    end;

    if not Assigned(contentFrm) and not empty then
    begin
      contentFrm := TJvID3ContentFrame(FId3v2.AddFrame(fiComment));
      contentFrm.Language := 'XXX'
    end
    else if Assigned(contentFrm) and empty then
    begin
      FId3v2.Frames.Remove(contentFrm);
      contentFrm := nil
    end;

    if Assigned(contentFrm) then
      contentFrm.Text := value;

    exit
  end;

  if empty then
  begin
    // Remove the frame if it exists
    if FID3v2.HasFrame(fieldId) then
      FId3v2.Frames.Remove(FId3v2.Frames.FindFrame(fieldId));

    exit;
  end;

  if fieldId in [fiTitle, fiAlbum, fiTrackNum, fiPerformerSortOrder, fiPartInSet] then
  begin
    TJvID3TextFrame.FindOrCreate(FId3v2, fieldId).Text := value;
  end

  else if fieldId in [fiYear, fiRecordingTime] then
  begin
    if Q_IsInteger(value) then
    begin
      i := StrToInt(value);
      if (i >=1) and (i<=9999) then
      begin
        if fieldId = fiYear then
          TJvID3NumberFrame.FindOrCreate(FId3v2, fieldId).Value := StrToInt(value)
        else
          TJvID3TimestampFrame.FindOrCreate(FId3v2, fieldId).Value := EncodeDate(i, 1, 1);

        exit
      end;
    end;
    
    // Invalid year-value. Delete frame
    if FID3v2.HasFrame(fieldId) then
      FId3v2.Frames.Remove(FId3v2.Frames.FindFrame(fieldId));
  end

  else if fieldId in [fiLeadArtist, fiContentType] then
  begin
    TJvID3CustomTextFrame(TJvID3SimpleListFrame.FindOrCreate(FId3v2, fieldId)).Text := value
  end
  else
    ShowMessage(PChar('Update of Id3v2 field ' + ID3_FrameIDToString(fieldId) + ' not supported.'));
end;

Procedure SaveV2CustomField(FId3v2:TMyId3Controller; const cf:PCustomField; const value:string);
var
	i, idx:integer;
  contentFrm: TJvID3ContentFrame;
  userFrm: TJvID3UserFrame;
  newFrame: TJvId3Frame;
  newFrameId: TJvId3FrameId;
begin
	//Clearing old data:
  idx := -1;
  for i:=fid3v2.Frames.Count-1 downto 0 do
  begin
  	if Q_SameText(cf.id3v2FieldName, FId3v2.Frames[i].FrameName) then
    begin
    	if FId3v2.Frames[i].FrameID = fiComment then
      begin
      	contentFrm := TJvId3ContentFrame(FId3v2.Frames[i]);

        //Read preferably from id3v2DefaultLanguage, but also any language if id3v2ReadAllLanguages = true
        if Q_SameText(cf.id3v2Description, contentFrm.Description) and (Q_SameText(cf.id3v2DefaultLanguage, contentFrm.Language) or ((idx=-1) and cf.id3v2ReadAllLanguages)) then
        	idx := i
      end
      else
      if FId3v2.Frames[i].FrameID = fiUserText then
      begin
        userFrm := TJvID3UserFrame(FId3v2.Frames[i]);
        if Q_SameText(cf.id3v2Description, userFrm.Description) then
        	idx := i
      end
      else if Fid3v2.Frames[i] is TJvID3CustomTextFrame then
      	idx := i
    end
  end;

  //Write new data
	if length(value) > 0 then
	begin
    if idx = -1 then
    begin
      newFrameId := ID3_StringToFrameID(cf.Id3v2FieldName);
      if (newFrameId <> fiErrorFrame) and (TMyID3Controller.GetFrameClass(newFrameId).InheritsFrom(TJvID3CustomTextFrame)) then
      begin
        newFrame := FId3v2.AddFrame(newFrameId);
        idx := newFrame.Index;
      end
    end;

    if Q_SameText(cf.id3v2FieldName, 'COMM') then
    begin
    	contentFrm := TJvId3ContentFrame(FId3v2.Frames[idx]);
      contentFrm.Language := cf.id3v2DefaultLanguage;
      contentFrm.Description := cf.id3v2Description;
      contentFrm.Text := value
    end
    else
    if Q_SameText(cf.id3v2FieldName, 'TXXX') then
    begin
      userFrm := TJvID3UserFrame(FId3v2.Frames[idx]);
      userFrm.Description := cf.id3v2Description;
      userFrm.Value := value;
    end
    else
    begin
    	//fid3v2.SetText(0, value, idx)
      TJvID3CustomTextFrame(FId3v2.Frames[idx]).Text := value;
    end
	end
  else
    // Value is empty - delete the frame
  	if idx >= 0 then
    	FId3v2.Frames.Remove (FId3v2.Frames[idx]);
end;

Procedure SaveApeAdditionalField(fApe: TApeTag; field: String; value: String);
var
	i: Integer;
begin
	i := fApe.GetKeyIndex(field);
  if i >= 0 then
  	fApe.DeleteFromAddlist(i);

  if length(value) > 0 then
	  fApe.AddKeyToAddList(field, value);
end;

Procedure SaveOggAdditionalField(fOgg: TOggVorbis; field: String; value: String);
var
	i: Integer;
begin
	i := fOgg.GetKeyIndex(field);
  if i >= 0 then
  	fOgg.DeleteFromAddlist(i);

  if length(value) > 0 then
	  fOgg.AddKeyToAddList(field, value);
end;

Procedure SaveWMAAdditionalField(fWMA: TWMAFile; field: String; value: String);
var
	i: Integer;
begin
	i := fWMA.GetKeyIndex(field);
  if i >= 0 then
  	fWMA.DeleteFromAddlist(i);

  if length(value) > 0 then
	  fWMA.AddKeyToAddList(field, value);
end;

function ValuesInclude(field: Integer): Boolean;
var
	i: Integer;
begin
	result := false;
	for i:=0 to length(values)-1 do
  	result := result or (values[i].field = field)
end;

procedure AddToErrorMsg(s: String);
begin
	if length(errMsg) = 0 then
  begin
  	errMsg := s;
  end
  else
  begin
  	errMsg := errMSg + CRLF + CRLF + s
  end
end;

//Method -> procedure TMainForm.UpdateRecValues()
var
	Fstr : TStream;
	FId3v2 : TMyId3Controller;
	FId3v1 : TID3v1Tag;
	FApe : TApeTag;
	FWMA : TWmaFile;
	FOgg : TOggVorbis;
	HasV1Tag, HasV2Tag, HasApe, HasWMA, HasOgg, Id3v2Exists, b, fileAccessOk : boolean;
	i, g, k, x, j:integer;
	s, value, filename: String;
  bt: byte;
  customField: PCustomField;
  wd: word;
  editFile: boolean;
begin
	screen.Cursor := crAppStart;

  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  filename := getFtextP(rec, fFilename);

  FId3v1 := nil;
  FId3v2 := nil;
  FApe := nil;
  FWMa := nil;
  FOgg := nil;
  Fstr := nil;

//  id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmwOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption

  editFile := (id3v1Opt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) or
  						(id3v2opt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) or
              (ApeOpt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) or
              (WmaOpt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) or
              (OggOpt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]);

  if editFile then
  	BeginWriteToFile(rec);

  if editFile then
  begin
  	fileAccessOk := GetFileAccess(filename, true, true, true);
    if not fileAccessOk then AddToErrorMsg('Error opening "' + filename + '".')
  end
  else
  	fileAccessOk := false;

  if editFile and fileAccessOk then
  begin
    if audioTypes[rec.AudioType].Id3v1 and (id3v1Opt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) then
    	FId3v1 := TId3V1Tag.Create;

    if audioTypes[rec.AudioType].Id3v2 and (id3v2Opt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) then
    	FId3v2 := TMyID3Controller.Create(nil);

    if (audioTypes[rec.AudioType].ApeV1 or audioTypes[rec.AudioType].Apev2) and (apeOpt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) then
    	FApe := TApeTag.Create;

    if audioTypes[rec.AudioType].Wma and (wmaOpt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) then
    	FWma := TWmaFile.Create;

    if audioTypes[rec.AudioType].Ogg and (oggOpt in [UpdateRecTagOption_UpdateIfExists, UpdateRecTagOption_UpdateElseCreate]) then
    	FOgg := TOggVorbis.Create;


    if assigned(Fid3v1) or assigned(Fid3v2) or assigned(FApe) or assigned(FWMA) or assigned(FOgg) then
    	FStr := TFilestream.Create(getFtextP(rec, fFilename), fmOpenReadWrite or fmShareDenyNone);

    if assigned(Fid3v1) then
    begin
      FId3v1.LoadFromStream(Fstr, Fstr.Size);
      if not FId3v1.Ok and (id3v1Opt = UpdateRecTagOption_UpdateElseCreate) then
      begin
      	HasV1Tag := true;
        if not ValuesInclude(FTitle) then
        	Fid3v1.Title := GetFTextP(rec, FTitle);
        if not ValuesInclude(FArtist) then
        	Fid3v1.Artist := GetFTextP(rec, FArtist);
        if not ValuesInclude(FAlbum) then
        	Fid3v1.Album := GetFTextP(rec, FAlbum);
        if not ValuesInclude(FYear) then
        	Fid3v1.Year := GetFTextP(rec, FYear);
        if not ValuesInclude(FTrack)  then
        	Fid3v1.Track := rec.Track;
        if not ValuesInclude(FComment) then
        	Fid3v1.Comment := GetFTextP(rec, FComment);
        if not ValuesInclude(FGenre) then
          for i:=0 to length(rec.Genre)-1 do
          	if rec.Genre[i] <= MAXGENRES then
            begin
            	Fid3v1.GenreID := rec.Genre[i];
              break
            end
      end
      else
      	HasV1Tag := FId3v1.Ok or (id3v1Opt = UpdateRecTagOption_UpdateElseCreate)
    end
    else
    	HasV1Tag := false;

    if assigned(Fid3v2) then
    begin
      try
        Fid3v2.LoadFromStream(Fstr);
        Id3v2Exists := Fid3v2.TagSize > 0;
      except
        Id3v2Exists := false;
        FId3v2.Reset;
      end;

      // If the file does not have any id3v2 tag, create a new tag with all values from the db
      if (not Id3v2Exists or (FId3v2.ReadVersion <= ive2_2)) and (id3v2Opt = UpdateRecTagOption_UpdateElseCreate) then
      begin
        if not Id3v2Exists or (FId3v2.ReadVersion <= ive2_2) then
          FId3v2.WriteVersionAs := ifv2_4;

        HasV2Tag := true;
        if not ValuesInclude(FTitle) then
        	SaveV2Frame(FId3v2, fiTitle, GetFTextP(rec, FTitle));

        if not ValuesInclude(FArtist) then
        	SaveV2Frame(FId3v2, fiLeadArtist, GetFTextP(rec, FArtist));

        if not ValuesInclude(FAlbum) then
        	SaveV2Frame(FId3v2, fiAlbum, GetFTextP(rec, FAlbum));

        if not ValuesInclude(FYear) and (length(GetFTextP(rec, FYear))>0) then
        begin
          if FId3v2.WriteVersion < ive2_4 then
          	SaveV2Frame(FId3v2, fiYear, GetFTextP(rec, FYear))
          else
            SaveV2Frame(FId3v2, fiRecordingTime, GetFTextP(rec, FYear))
        end;

        if length(GetTrackString(rec)) > 0 then
        	SaveV2Frame(FId3v2, fiTrackNum, GetTrackString(rec));

        if not ValuesInclude(FComment) then
        	SaveV2Frame(FId3v2, fiComment, GetFTextP(rec, FComment));

        if not ValuesInclude(FGenre) and (length(rec.Genre)>0) then
        	SaveV2Frame(FId3v2, fiContentType, GetV2GenreString(rec, FId3v2.WriteVersion));

        SaveId3v2PrivateFrame(FId3v2, rec)
      end
    	else
      begin
      	HasV2Tag := Id3v2Exists or (id3v2Opt = UpdateRecTagOption_UpdateElseCreate);
      	if HasV2Tag and (FId3v2.ReadVersion <= ive2_2) then
      		HasV2Tag := (id3v2Opt = UpdateRecTagOption_UpdateElseCreate)
      end
    end
    else
    	HasV2Tag := false;

    if assigned(FApe) then
    begin
      FApe.ReadFromStream(Fstr);
      if not FApe.Exists and (apeOpt = UpdateRecTagOption_UpdateElseCreate) then
      begin
        HasApe := true;
        if not ValuesInclude(FTitle) then
        	FApe.Title := GetFTextP(rec, FTitle);
        if not ValuesInclude(FArtist) then
        	FApe.Artist := GetFTextP(rec, FArtist);
        if not ValuesInclude(FAlbum) then
        	FApe.Album := GetFTextP(rec, FAlbum);
        if not ValuesInclude(FYear) then
        	FApe.Year := GetFTextP(rec, FYear);
        FApe.Track := GetTrackString(rec);
        if not ValuesInclude(FComment) then
        	FApe.Comment := GetFTextP(rec, FComment);
        if not ValuesInclude(FGenre) and (length(rec.Genre)>0) then
        	FApe.Genre := Genrelist.Strings[rec.Genre[0]]
      end
    	else
      	HasApe := FApe.Exists or (apeOpt = UpdateRecTagOption_UpdateElseCreate)
    end else HasApe := false;

    if assigned(FWMA) then
    begin
      FWMA.ReadFromStream(Fstr);
      if not FWMA.Valid and (wmaOpt = UpdateRecTagOption_UpdateElseCreate) then
      begin
      	HasWMA := true;
        if not ValuesInclude(FTitle) then
        	FWMA.Title := GetFTextP(rec, FTitle);
        if not ValuesInclude(FArtist) then
        	FWMA.Artist := GetFTextP(rec, FArtist);
        if not ValuesInclude(FAlbum) then
        	FWMA.Album := GetFTextP(rec, FAlbum);
        if not ValuesInclude(FYear) then
        	FWMA.Year := GetFTextP(rec, FYear);
        if not ValuesInclude(FTrack)  then
        	FWMA.Track := rec.Track;
        if not ValuesInclude(FComment) then
        	FWMA.Comment := GetFTextP(rec, FComment);
        if not ValuesInclude(FGenre) and (length(rec.Genre)>0) then
        	FWMA.Genre := Genrelist.Strings[rec.Genre[0]]
      end
      else
      	HasWMA := FWMA.valid or (wmaOpt = UpdateRecTagOption_UpdateElseCreate)
    end else HasWMA := false;

    if assigned(FOgg) then
    begin
      FOgg.ReadFromStream(Fstr);
      if not FOgg.Valid and (oggOpt = UpdateRecTagOption_UpdateElseCreate) then
      begin
      	HasOgg := true;
        if not ValuesInclude(FTitle) then
        	FOgg.Title := GetFTextP(rec, FTitle);
        if not ValuesInclude(FArtist) then
        	FOgg.Artist := GetFTextP(rec, FArtist);
        if not ValuesInclude(FAlbum) then
        	FOgg.Album := GetFTextP(rec, FAlbum);
        if not ValuesInclude(FYear) then
        	FOgg.Date := GetFTextP(rec, FYear);
        FOgg.Track := GetTrackString(rec);
        if not ValuesInclude(FComment) then
        	FOgg.Comment := GetFTextP(rec, FComment);
        if not ValuesInclude(FGenre) and (length(rec.Genre)>0) then
        	FOgg.Genre := Genrelist.Strings[rec.Genre[0]]
      end
      else
      	HasOgg := FOgg.Valid or (oggOpt = UpdateRecTagOption_UpdateElseCreate)
    end else HasOgg := false
  end else
  begin
    HasV1Tag := false;
    HasV2Tag := false;
    HasApe := false;
    HasWMA := false;
    HAsOgg := false;

    id3v1Opt := UpdateRecTagOption_DontUpdate;
    id3v2Opt := UpdateRecTagOption_DontUpdate;
    apeOpt := UpdateRecTagOption_DontUpdate;
    oggOpt := UpdateRecTagOption_DontUpdate;
    wmaOpt := UpdateRecTagOption_DontUpdate;
    editFile := false
  end;

  // Set new values
  BeginSetArtistAlbumFilename;
  try
  	for i:=0 to length(values)-1 do
		begin
    	if values[i].field = fArtist then
      begin
        setArtist(rec, values[i].value);
        if HasV1Tag then
          FId3v1.Artist := values[i].value;
        if HasV2Tag then
          SaveV2Frame(FId3v2, fiLeadArtist, values[i].value);
        if HasApe then
          Fape.Artist := values[i].Value;
        if HasOgg then
          FOgg.Artist := values[i].Value;
        if HasWMA then
          FWMA.Artist := values[i].Value
      end else
      if values[i].field = fArtistSortOrder then
      begin
        SetArtistSortOrder(rec, values[i].value);
        if rec.Artist = rec.ArtistSortOrder then
        	values[i].value := '';

        if HasV2Tag then
        	SaveV2Frame(Fid3v2, fiPerformerSortOrder, values[i].value);
        if HasApe then
        	SaveApeAdditionalField(FApe, 'ArtistSortOrder', values[i].value);
        if HasOgg then
        	SaveOggAdditionalField(FOgg, 'ARTISTSORTORDER', values[i].value);
        if HasWMA then
        	SaveWMAAdditionalField(FWma, 'WM/ArtistSortOrder', values[i].value);
      end
      else
      if values[i].field = fTitle then
      begin
      	SetPCharString(rec.Title, values[i].value);
        //rec.Title := values[i].value;
        if HasV1Tag then
          FId3v1.Title := values[i].value;
        if HasV2Tag then
          SaveV2Frame(FId3v2, fiTitle, values[i].value);
        if HasApe then
          Fape.Title := values[i].Value;
        if HasOgg then
          FOgg.Title := values[i].Value;
        if HasWMA then
          FWMA.Title := values[i].Value
      end else
      if values[i].field = fAlbum then
      begin
        rec.album := GetAlbumID(values[i].value);
        if HasV1Tag then
          FId3v1.Album := values[i].value;
        if HasV2Tag then
          SaveV2Frame(FId3v2, fiAlbum, values[i].value);
        if HasApe then
          Fape.Album := values[i].Value;
        if HasOgg then
          FOgg.Album := values[i].Value;
        if HasWMA then
          FWMA.Album := values[i].Value
      end else

      if values[i].field = fComment then
      begin
        rec.Comment := values[i].value;
        if HasV1Tag then
          FId3v1.Comment := values[i].value;
        if HasV2Tag then
          SaveV2Frame(FId3v2, fiComment, values[i].value);
        if HasApe then
          Fape.Comment := values[i].Value;
        if HasOgg then
          FOgg.Comment := values[i].Value;
        if HasWMA then
          FWMA.Comment := values[i].Value
      end else

      if values[i].field = fTrack then
      begin
        if Q_IsInteger(values[i].value) and (values[i].value <> '0') then
        begin
        	j := strToInt(values[i].value);
          if (j >= 0) and (j < high(word)) then
	          rec.track := j;
          if HasV1Tag then
            FId3v1.Track := strToInt(values[i].value);

          if HasV2Tag then
          begin
            s := Fid3v2.GetText(fiTrackNum);
          	if Length(s) > 0 then
            	SaveV2Frame(FId3v2, fiTrackNum, GetTrackString(StrToInt(values[i].Value), GetTotalTracksInt(s)))
            else
            	SaveV2Frame(FId3v2, fiTrackNum, GetTrackString(StrToInt(values[i].Value), 0))
          end;

          if HasApe then
        		FApe.Track := GetTrackString(StrToInt(values[i].Value), GetTotalTracksInt(FApe.Track));
          if HasOgg then
						FOgg.Track := GetTrackString(StrToInt(values[i].Value), GetTotalTracksInt(FOgg.Track));
          if HasWMA then
            FWMA.Track := StrToInt(values[i].Value)
        end else
        begin
          rec.track := 0;
          if HasV1Tag then
            FId3v1.Track := 0;

          if HasV2Tag then
          begin
            s := Fid3v2.GetText(fiTrackNum);
            if Length(s) > 0 then
            	SaveV2Frame(FId3v2, fiTracknum, GetTrackString(0, GetTotalTracksInt(s)))
            else
            	SaveV2Frame(FId3v2, fiTracknum, GetTrackString(0, 0));
          end;

          if HasApe then
            FApe.Track := GetTrackString(0, GetTotalTracksInt(FApe.Track));
          if HasOgg then
            FOgg.Track := GetTrackString(0, GetTotalTracksInt(FOgg.Track));
          if HasWMA then
            FWMA.Track := 0
        end
      end else

      if values[i].field = FTotalTracks then
      begin
        if Q_IsInteger(values[i].value) and (values[i].value <> '0') then
        begin
        	j := strToInt(values[i].value);
          if (j >= 0) and (j < high(word)) then
	          rec.TotalTracks := j;

          if HasV2Tag then
          begin
            s := Fid3v2.GetText(fiTracknum);
          	if Length(s) > 0 then
            	SaveV2Frame(FId3v2, fiTrackNum, GetTrackString(GetTrackNoInt(s), StrToInt(values[i].Value)))
            else
            	SaveV2Frame(FId3v2, fiTrackNum, GetTrackString(0, StrToInt(values[i].Value)));
          end;

          if HasApe then
        		FApe.Track := GetTrackString(GetTrackNoInt(FApe.Track), StrToInt(values[i].Value));
          if HasOgg then
						FOgg.Track := GetTrackString(GetTrackNoInt(FOgg.Track), StrToInt(values[i].Value))
        end
        else
        begin

          rec.TotalTracks := 0;

          if HasV2Tag then
          begin
            s := Fid3v2.GetText(fiTracknum);
          	if Length(s) > 0 then
            	SaveV2Frame(FId3v2, fiTrackNum, GetTrackString(GetTrackNoInt(s), 0))
            else
            	SaveV2Frame(FId3v2, fiTrackNum, GetTrackString(0, 0))
          end;

          if HasApe then
            FApe.Track := GetTrackString(GetTrackNoInt(FApe.Track), 0);
          if HasOgg then
            FOgg.Track := GetTrackString(GetTrackNoInt(FOgg.Track), 0)
        end
      end else

      if values[i].field = FPartOfSetText then
      begin
      	bt := 0;
        if SetPartOfSetFromString(bt, values[i].value) then
        begin
          rec.PartOfSet := bt;
          if HasV2Tag then
            	SaveV2Frame(FId3v2, fiPartInSet, values[i].Value);
          if HasApe then
        		SaveApeAdditionalField(fApe, 'PartOfSet', values[i].Value);
          if HasOgg then
						SaveOggAdditionalField(fOgg, 'DISCNUMBER', GetPartsString(GetPartOfSet(bt), 0));
          if HasWMA then
          	SaveWMAAdditionalField(fWMA, 'WM/PartOfSet', values[i].Value);
        end
      end else

      if values[i].field = FCustomField then
      begin
      	if SetCustomFieldData(rec, values[i].customFieldIndex, values[i].value) then
        begin
        	customField := FieldList.Items[values[i].customFieldIndex];

        	if HasV2Tag and (length(customField.id3v2FieldName) > 0) then                 //v2customfield
          	SaveV2CustomField(Fid3v2, customField, values[i].Value);

          if HasApe and (length(customField.apeFieldName) > 0) then
        		SaveApeAdditionalField(fApe, customField.apeFieldName, values[i].Value);

          if HasOgg and (length(customField.oggFieldName) > 0) then
						SaveOggAdditionalField(fOgg, customField.oggFieldName, values[i].Value);

          if HasWMA and (length(customField.wmaFieldName) > 0) then
          	SaveWMAAdditionalField(fWMA, customField.wmaFieldName, values[i].Value);
        end
      end
      else

      if values[i].field = fYear then
      begin
        if Q_IsInteger(values[i].value) and (values[i].value <> '0') then
        begin
          rec.year := strToInt(values[i].value);
          if HasV1Tag then
            FId3v1.year := values[i].value;

          if HasV2Tag then
          begin
            if FId3v2.WriteVersion < ive2_4 then
              SaveV2Frame(FId3v2, fiYear, values[i].value)
            else
              SaveV2Frame(FId3v2, fiRecordingTime, values[i].value)
          end;

          if HasApe then
            Fape.Year := values[i].value;
          if HasOgg then
            FOgg.Date := values[i].value;
          if HasWMA then
            FWMA.Year := values[i].value
        end else
        begin
          rec.year := 0;
          if HasV1Tag then
            FId3v1.year := '';
          if HasV2Tag then
            if FId3v2.WriteVersion < ive2_4  then
              SaveV2Frame(FId3v2, fiYear, '')
            else
              SaveV2Frame(FId3v2, fiRecordingTime, '');

          if HasApe then
            Fape.Year := '';
          if HasOgg then
            FOgg.Date := '';
          if HasWMA then
            FWMA.Year := ''
        end
      end else

      if values[i].field = fGenre then
      begin
        g := GetGenreID(values[i].value);
        if g = -1 then
          setLength(rec.genre, 0)
        else
        begin
          setLength(rec.genre, 1);
          rec.genre[0] := g
        end;
        if HasV1Tag then
        if (g > MAXGENRES) or (g = -1) then
          FId3v1.GenreID := 255
        else FId3v1.GenreID := g;

        if HasV2Tag then
          SaveV2Frame(FId3v2, fiContentType, GetV2GenreString(rec, FId3V2.WriteVersion));

        if HasApe then
          Fape.genre := values[i].value;
        if HasOgg then
          FOgg.genre := values[i].value;
        if HasWMA then
          FWMA.genre := values[i].value
      end else

      if values[i].field = FAddGenre then
      begin
        g := GetGenreID(values[i].value);
        if g = -1 then
          continue
        else
        begin
          b := false;
          for x:=0 to length(rec.Genre)-1 do
            b := b or (g = rec.Genre[x]);
          if not b then
          begin
            setLength(rec.genre, length(rec.Genre)+1);
            rec.genre[length(rec.Genre)-1] := g;

            if HasV1Tag then
            if (g > MAXGENRES) or (g = -1) then
              FId3v1.GenreID := 255
            else FId3v1.GenreID := g;

            if HasV2Tag then
              SaveV2Frame(FId3v2, fiContentType, GetV2GenreString(rec, FId3V2.WriteVersion));
            if HasApe then
              Fape.genre := values[i].value;
            if HasOgg then
              FOgg.genre := values[i].value;
            if HasWMA then
              FWMA.genre := values[i].value
          end
        end
      end else
      if values[i].field = FRemoveGenre then     ///////////////////
      begin
        g := GetGenreID(values[i].value);
        if g = -1 then
          continue
        else
        begin
          b := false;
          for x:=0 to length(rec.Genre)-1 do
            b := b or (g = rec.Genre[x]);
          if b then
          begin
            for x:=length(rec.Genre)-1 downto 0 do
              if g = rec.Genre[x] then
              begin
                for k:=x to length(rec.Genre)-2 do
                  rec.Genre[k] := rec.Genre[k+1];
                SetLength(rec.Genre, length(rec.Genre)-1)
              end;

              if length(rec.Genre)>0 then
              begin
                g := rec.Genre[0];
                s := GenreList.Strings[rec.Genre[0]]
              end
              else
              begin
                g:= -1;
                s := ''
              end;

              if HasV1Tag then
              if (g > MAXGENRES) or (g = -1) then
                FId3v1.GenreID := 255
              else FId3v1.GenreID := g;

              if HasV2Tag then
                SaveV2Frame(FId3v2, fiContentType, GetV2GenreString(rec, FId3V2.WriteVersion));
              if HasApe then
                Fape.genre := s;
              if HasOgg then
                FOgg.genre := s;
              if HasWMA then
                FWMA.genre := s
            end
        end
      end
      else

      if values[i].field = fRating then
      begin
				rec.Rating := strToInt(values[i].value);

        if HasV2Tag then
          SaveId3v2Rating(FId3v2, rec.Rating);
        if HasApe then
          SaveApeRating(FApe, rec.Rating);
        if HasOgg then
          SaveOggRating(FOgg, rec.Rating);
        if HasWMA then
          SaveWMARating(FWMA, rec.Rating)
      end
      else

      if values[i].field = fCompilation then //compilation, use "0" or "1" as value
      begin
      	if values[i].value = '1' then
        	Include(rec.Flags, rfCompilation)
        else
        	Exclude(rec.Flags, rfCompilation);

        if HasV2Tag then
          SaveId3v2PrivateFrame(FId3v2, rec);
        if HasApe then
          SaveAPEprivateFrame(Fape, rec, true);
        if HasOgg then
          SaveOGGprivateFrame(FOgg, rec, true);
        if HasWMA then
          SaveWMAprivateFrame(FWMA, rec, true)
      end else

      if values[i].field = FAddGroup then
      begin
        g := -1;
        for k:=0 to GroupList.Count-1 do
          if Q_SameText(values[i].value, PGroupRec(GroupList.Items[k]).Name) then
            g := k;

        if g = -1 then
          continue
        else
        begin
          b := false;
          for x:=0 to length(rec.Groups)-1 do
            b := b or (g = rec.Groups[x]);
          if not b then
          begin
            setLength(rec.Groups, length(rec.Groups)+1);
            rec.Groups[length(rec.Groups)-1] := g;

            if HasV2Tag then
              SaveId3v2PrivateFrame(FId3v2, rec);
            if HasApe then
              SaveAPEprivateFrame(Fape, rec, true);
            if HasOgg then
              SaveOGGprivateFrame(FOgg, rec, true);
            if HasWMA then
              SaveWMAprivateFrame(FWMA, rec, true)
          end
        end
      end else //of AddGroups

      if values[i].field = FRemoveGroup then
      begin
        g := -1;
        for k:=0 to GroupList.Count-1 do
          if Q_SameText(values[i].value, PGroupRec(GroupList.Items[k]).Name) then
            g := k;

        if g = -1 then
          continue
        else
        begin
          b := false;
          for x:=0 to length(rec.Groups)-1 do
            b := b or (g = rec.Groups[x]);
          if b then
          begin
            for x:=length(rec.Groups)-1 downto 0 do
              if g = rec.Groups[x] then
              begin
                for k:=x to length(rec.Groups)-2 do
                  rec.Groups[k] := rec.Groups[k+1];
                SetLength(rec.Groups, length(rec.Groups)-1)
              end;

              if HasV2Tag then
                SaveId3v2PrivateFrame(FId3v2, rec);
              if HasApe then
                SaveAPEprivateFrame(Fape, rec, true);
              if HasOgg then
                SaveOGGprivateFrame(FOgg, rec, true);
              if HasWMA then
                SaveWMAprivateFrame(FWMA, rec, true)
          end
        end
      end //of RemoveGroups
  end;
  finally
  	EndSetArtistAlbumFilename;
  end;
  //END OF set values

  if editFile then
  begin
    if HasV1Tag and Fid3v1.Modified then
    begin
      Fid3v1.SaveToFile(getFtextP(rec, fFilename));
      Include(rec.Flags, rfHasId3v1)
    end;
    if HasV2Tag then
    begin
      try
        Fid3v2.saveToStream(Fstr);
      except
        on E: Exception do
        begin
          AddToErrorMsg(E.Message);
        end;
      end;
    end;
    if HasApe and AudioTypes[rec.AudioType].ApeV2 then
    begin
      FApe.SaveToStream(Fstr, 2000);
      Include(rec.Flags, rfHasApeTag)
    end
    else
    if HasApe and AudioTypes[rec.AudioType].ApeV1 then
    begin
      if FApe.SaveToStream(Fstr, 1000) then
	      Include(rec.Flags, rfHasApeTag)
      else
      	AddToErrorMsg('Error saving Ape tag')
    end;
    if HasWMA then
    begin
      if FWMA.WriteToStream(FStr) then
	      Include(rec.Flags, rfHasWmaTag)
      else
      	AddToErrorMsg('Error saving WMA tag')
    end;
    if HasOgg then
    begin
      if FOgg.SaveTag then
	      Include(rec.Flags, rfHasOggTag)
      else
      	AddToErrorMsg('Error saving Ogg tag')
    end;

    if Id3v1EqualsId3v2(FId3v1, FId3v2) then
    	Include(rec.Flags, rfEqualId3)
    else
    	Exclude(rec.Flags, rfEqualId3);


    if assigned(FId3v1) then Fid3v1.free;
    if assigned(Fid3v2) then Fid3v2.free;
    if assigned(FApe) then FApe.free;
    if assigned(FWMA) then FWMA.Free;
    if Assigned(FOgg) then FOgg.FRee;
    if assigned(Fstr) then FStr.free;
    rec.LastWriteTime := fileAge(getFtextP(rec, fFilename));
    EndWriteToFile(rec)
  end;

	Dec(SafeToAutoScanCount);

  screen.Cursor := crDefault
end;

Procedure TMainForm.SaveApeRating(const FApe: TApetag; rating: byte);
var
	index: Integer;
  existingRating: byte;
  key: string;
begin
	index := GetApeRatingTagIndex(FApe, existingRating);

  if (index >= 0) then
  	if rating = existingRating then
    	//No need to update rating
    	exit
    else
			//Remove existing frame and write a new one
			FApe.DeleteFromAddlist(index);

  if rating > 0 then
  begin
    //Create new frame
    if length(pref.txtEmail.Text) > 0 then
    	key := 'Rating:' + pref.txtEmail.Text
    else
    	key := 'Rating';
    FApe.AddKeyToAddList(key, intToStr(rating))
  end
end;

Function TMainForm.GetApeRatingTagIndex(const FApe: TApetag; var rating:byte): Integer;
var
	i, intValue: Integer;
  lookFor, value: string;
begin
	//Format Rating:mail@server
  result := -1;
  if FApe.AddList.Count > 0 then
  begin
    if length(pref.txtEmail.Text) > 0 then
      lookFor := 'Rating:' + pref.txtEmail.Text
    else
      lookFor := 'Rating';
    for i:=0 to FApe.AddList.Count-1 do
      if Q_SameText(lookFor, FApe.GetAddListKeyName(i, value)) and Q_IsInteger(value) then
      begin
        intValue := StrToInt(value);
        if (intValue >= 0) and (intValue<=255) then
        begin
        	rating := intValue;
          result := i;
          exit
        end
      end
    end
end;

Function TMainForm.GetApeRatingTagIndex(const FApe: TApetag): Integer;
var
	rating: byte;
begin
	result := GetApeRatingTagIndex(FApe, rating);
end;

Function TMainForm.GetOggRatingTagIndex(const FOgg: TOggVorbis; var rating: byte): Integer;
var
	i, intValue: Integer;
  lookFor, value: string;
begin
	//Format Rating:mail@server
  result := -1;
  if FOgg.AdditionalTags.Count > 0 then
  begin
    if length(pref.txtEmail.Text) > 0 then
      lookFor := 'Rating:' + pref.txtEmail.Text
    else
      lookFor := 'Rating';
    for i:=0 to FOgg.AdditionalTags.Count-1 do
      if Q_SameText(lookFor, FOgg.GetAddListKeyName(i, value)) and Q_IsInteger(value) then
      begin
        intValue := StrToInt(value);
        if (intValue >= 0) and (intValue<=255) then
        begin
        	rating := intValue;
          result := i;
          exit
        end
      end
    end
end;

Function TMainForm.GetOggRatingTagIndex(const FOgg: TOggVorbis): Integer;
var
	rating: byte;
begin
	result := GetOggRatingTagIndex(FOgg, rating);
end;

Procedure TMainForm.SaveOggRating(const FOgg: TOggVorbis; rating: byte);
var
	index: Integer;
  existingRating: byte;
  key: string;
begin
	index := GetOggRatingTagIndex(FOgg, existingRating);

  if (index >= 0) then
  	if rating = existingRating then
    	//No need to update rating
    	exit
    else
			//Remove existing frame and write a new one
			FOgg.DeleteFromAddlist(index);

  if rating > 0 then
  begin
    //Create new frame
    if length(pref.txtEmail.Text) > 0 then
    	key := 'Rating:' + pref.txtEmail.Text
    else
    	key := 'Rating';
    FOgg.AddKeyToAddList(key, intToStr(rating))
  end
end;

Function TMainForm.GetWMARatingTagIndex(const FWMA: TWMAFile): Integer;
var
	rating: byte;
begin
	result := GetWMARatingTagIndex(FWMA, rating);
end;

Function TMainForm.GetWMARatingTagIndex(const FWMA: TWMAFile; var rating: byte): Integer;
var
	i, intValue: Integer;
  lookFor: string;
  wsValue: wideString;
begin
	//Format Rating:mail@server
  result := -1;
  if FWMA.AddList.Count > 0 then
  begin
    if length(pref.txtEmail.Text) > 0 then
      lookFor := 'Rating:' + pref.txtEmail.Text
    else
      lookFor := 'Rating';
    for i:=0 to FWMA.AddList.Count-1 do
      if Q_SameText(lookFor, FWMA.GetAddListKeyName(i, wsValue)) and Q_IsInteger(wsValue) then
      begin
        intValue := StrToInt(wsValue);
        if (intValue >= 0) and (intValue<=255) then
        begin
        	rating := intValue;
          result := i;
          exit
        end
      end
    end
end;

Procedure TMainForm.SaveWMARating(const FWMA: TWMAFile; rating: byte);
var
	index: Integer;
  existingRating: byte;
  key: string;
begin
	index := GetWMARatingTagIndex(FWMA, existingRating);

  if (index >= 0) then
  	if rating = existingRating then
    	//No need to update rating
    	exit
    else
			//Remove existing frame and write a new one
			FWMA.DeleteFromAddlist(index);

  if rating > 0 then
  begin
    //Create new frame
    if length(pref.txtEmail.Text) > 0 then
    	key := 'Rating:' + pref.txtEmail.Text
    else
    	key := 'Rating';
    FWMA.AddKeyToAddList(key, intToStr(rating))
  end
end;

Procedure TMainForm.SaveId3v2Rating(const FId3v2: TMyID3Controller; rating: byte);
var
	index: integer;
  existingRating: byte;
  popFrm: TJvID3PopularimeterFrame;
begin
	index := GetId3v2RatingFrameIndex(FId3v2, existingRating);

  if (index >= 0) then
  	if rating = existingRating then
    	//No need to update rating
    	exit
    else
			//Remove existing frame and write a new one
			FId3v2.Frames.Remove(FId3v2.Frames[index]);

  if rating > 0 then
  begin
    //Create new frame
    popFrm := TJvID3PopularimeterFrame(FId3v2.AddFrame(fiPopularimeter));
    popFrm.EMailAddress := pref.txtEmail.Text;
    popFrm.Rating := rating
  end
end;

Function TMainForm.GetId3v2RatingFrameIndex(const FId3v2: TMyID3Controller): Integer;
var
	rating: byte;
begin
	result := GetId3v2RatingFrameIndex(FId3v2, rating);
end;

Function TMainForm.GetId3v2RatingFrameIndex(const FId3v2: TMyID3Controller; var rating: byte): Integer;
var
	i: Integer;
  popFrm: TJvID3PopularimeterFrame;
begin
	result := -1;
  for i:=0 to FId3v2.Frames.Count-1 do
  begin
  	if FId3v2.Frames[i].FrameID = fiPopularimeter then
    begin
      popFrm := TJvID3PopularimeterFrame(FId3v2.Frames[i]);

      if Q_SameText(popFrm.EMailAddress, pref.txtEmail.Text) then
      begin
      	rating := popFrm.Rating;
        result := i;
        exit
      end;
    end
  end;
end;

procedure TMainForm.treeNewText(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; Text: WideString);

Function getdbindex(name:string):string;
var i:integer;
begin
  i:= locateDBname(name);
  if i > -1 then result :=inttostr(i)
end;

Function NodePath(aNode:PVirtualNode):String;
var
	bNode:PVirtualNode;
  s: WideString;
begin
  result := '';
  bNode := aNode;
  while bNode <> nil do
  begin
  	TreeGetText(Tree, bNode, 0, ttStatic, s);
    result := s + '\' + result;
    bNode := bNode.parent;
    if bNode = tree.rootnode then
    	bNode := nil
  end;
  if showmedia1.checked then
  	result := Q_CopyFrom(result, Q_StrScan(result, '\')+1)
end;
//Procedure procedure TMainForm.treeNewText(Sender: TBaseVirtualTree;  Node: PVirtualNode; Column: TColumnIndex; Text: WideString);
var
  dbindex,x:integer;
  d, s :string;
  OldFn, NewFn:String;
  TR:PtreeRec;
  rec: Prec;
  recs, valuesList: TList;
  tagValues: PTagvalues;
  aNode:PVirtualNode;
  ws: WideString;
begin
	TR := tree.GetNodeData(Node);
  TreeGetText(tree, Node, 0, ttStatic, ws);
	if ws = Text then
		exit;

  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  recs := TList.Create;
  valuesList := TList.Create;

  case TR.Kind of
    TreeKind_Group:
    begin
      ChangeGroupName(TR.PLRecRef, TRim(text));
      tabel.Refresh
    end;

    TreeKind_Harddisk, TreeKind_Zip, TreeKind_Cdrom, TreeKind_Network:  //Navnet p databasen skal ndres
    begin
      dbindex := strtoint(getdbindex(tr.text));
      if not Q_SameText(dbs[dbindex].name, trim(text)) then
      begin
        deleteFile(settingsdir + dbs[dbindex].Filename);
        dbs[dbindex].Filename := '';
        dbs[dbindex].name := trim(text)
      end;
      tr.text := text;
      if tr.Kind = TreeKind_Harddisk then
      begin
        pref.harddisk.text := text;
        Settings.writeString('harddisk', text)
      end
    end;
    TreeKind_Directory, TreeKind_DirectoryRecursive:
    begin
      d:=nodepath(node.parent) + text;
      x:=length(nodepath(node));
      if movefile(pchar(nodepath(node)), pchar(d)) then
      begin
        tr.text := text;
        aNode := tabel.GetFirst;
        while aNode <> nil do
        begin
          if filterRec(getRec(aNode), true) then
          begin
            FileSetAttr(pchar(GetFtextP(getRec(aNode), ffilename)), faarchive);
            setFilename(getRec(aNode), d + Q_CopyFrom(GetFtextP(getRec(aNode), ffilename),x), true);
            Prec(getRec(aNode)).LastWriteTime := FileAge(getFtextP(getrec(aNode), fFilename));
          end;
          aNode := tabel.GetNext(aNode)
        end;
        treefilter;
      end
      else
        showMessageX(GetText(TXT_CouldNotRenameDir))
    end;
    TreeKind_Artist:
    begin
      aNode := tabel.GetFirst;
      while aNode <> nil do
      begin
      	rec := GetRec(aNode);
        if FilterRec(rec, true) then
        begin
        	new(tagValues);
          SetLength(tagValues^, 1);
        	if (TR.Contents = tscArtists) or (rec.Artist = rec.ArtistSortOrder) then
						tagValues^[0].field := FArtist
          else
          	tagValues^[0].field := fArtistSortOrder;
          tagValues^[0].value := cleanString(text);
          valuesList.Add(tagValues);
          recs.Add(rec);
        end;
        aNode := tabel.GetNext(aNode)
      end;

      {if TR.Contents = tscArtistsSortOrder then
      	values[0].field := fArtistSortOrder
      else
	      values[0].field := fArtist;
      values[0].value := cleanString(text);
      aNode := tabel.GetFirst;
      while aNode <> nil do
      begin
        if filterRec(getRec(aNode), true) then
           UpdateRecValues(getRec(aNode), values, Pref.MainListUpdateTags.Checked, pref.ForceId3v1.Checked, pref.ForceId3v2.Checked, pref.forceApe.Checked, pref.ForceWMA.Checked, pref.ForceOgg.Checked);
        aNode := tabel.GetNext(aNOde)
      end;   }
      TR.tag := GetArtistID(cleanString(text));
    end;
    TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum:
    begin
      aNode := tabel.GetFirst;
      while aNode <> nil do
      begin
        if filterRec(getRec(aNode), true) then
        begin
        	New(tagValues);
      		SetLength(tagValues^, 1);
      		tagValues^[0].field := fAlbum;
      		tagValues^[0].value := cleanString(text);
          valuesList.Add(tagValues);
          recs.Add(GetRec(aNode));

					if TR.Kind in [TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum] then
	          s := GetYearAlbum(getRec(aNode))
          else
          	s := GetFTextP(getRec(aNode), FAlbum)
        end;
        aNode := tabel.GetNext(aNode)
      end;
      tr.text := s;
      TR.tag := GetAlbumID(cleanString(text));
    end;

    TreeKind_Year:
    begin
    	if Q_IsInteger(text) then
      begin
        aNode := tabel.GetFirst;
        while aNode <> nil do
        begin
          if filterRec(getRec(aNode), true) then
          begin
	          New(tagValues);
	      		SetLength(tagValues^, 1);
	      		tagValues^[0].field := fYear;
	      		tagValues^[0].value := text;
	          valuesList.Add(tagValues);
	          recs.Add(GetRec(aNode));
          end;

          aNode := tabel.GetNext(aNode)
        end;
        TR.tag := strtoint(text);
      end
    end;

    TreeKind_Playlist:
    begin
      oldFn := PplRec(TR.PlRecRef).filename;
      newFn := createFilename(getfilepath(oldFn), trim(text) + '.m3u', true, false);
      if movefile(pchar(oldFn), pchar(newFn)) then
      begin
        PplRec(TR.PlRecRef).filename := newFn;
        PplRec(TR.PlRecRef).Name := trim(text)
      end
      else
        showmessagex(GetText(TXT_CouldNotRenamePlaylist))
    end
  end;//of case

  if recs.Count > 0 then
  begin
		UpdateRecValues(recs, valuesList, nil, 'Tagging...', true, GetDefaultUpdateTags);
	  treefilter
  end
  else
  begin
  	recs.Free;
    valuesList.Free
  end;

  Dec(SafeToAutoScanCount);
end;

function TMainForm.GetWinplaylistText(const aNode: PVirtualNode; const p: Pointer): String;
var
	rec: Prec;
	artist, album, title, track, track0, year, comment, filename: String;
begin
	rec := p;

	artist := GetFTextP(rec, Fartist);

	album := GetFTextP(rec, Falbum);
	if length(album) = 0 then album := '?';

	title := GetFTextP(rec, Ftitle);
	if length(title) = 0 then title := '?';

	comment := GetFTextP(rec, Fcomment);
	if length(comment) = 0 then comment := '?';

  filename := GetFTextP(rec, Ffname);
	if length(filename) = 0 then filename := '?';

	if rec.Track > 0 then
	begin
		track := IntToStr(rec.Track);
		if rec.Track < 10 then
			track0 := '0' + IntToStr(rec.track)
		else track0 := IntToStr(rec.track)
	end
	else
	begin
		track := '?';
		track0 := '?'
	end;

	if rec.year > 0 then
		year := IntToStr(rec.year)
	else year := '?';

	if (rfCompilation in rec.Flags) and pref.WinPlayCompilationEnabled.Checked then
		result := pref.WinPlayCompilationTitleFormatEdit.Text
	else
		result := pref.WinPlayTitleFormatEdit.text;
		
	result := Q_ReplaceStr(result, '%artist%', artist);
	result := Q_ReplaceStr(result, '%album%', album);
	result := Q_ReplaceStr(result, '%title%', title);
	result := Q_ReplaceStr(result, '%track%', track);
	result := Q_ReplaceStr(result, '%track0%', track0);
	result := Q_ReplaceStr(result, '%year%', year);
	result := Q_ReplaceStr(result, '%comment%', comment);
  result := Q_ReplaceStr(result, '%filename%', filename);
	result := Q_ReplaceStr(result, '%playlistpos%', IntToStr(aNode.index+1));

	//fjerner mellemrum mellem ' ? '
	result := Q_ReplaceStr(result, ' - ? - ? - ', ' - ');
	result := Q_ReplaceStr(result, '- ? - ?', '-');
	result := Q_ReplaceStr(result, ' - ? - ', ' - ');
	result := Q_ReplaceStr(result, ' ?', '?');
	result := Q_ReplaceStr(result, '? ', '?');
	result := Q_ReplaceStr(result, '?- ', '?');
	result := Q_ReplaceStr(result, ' -?', '?');
	result := Q_ReplaceStr(result, '?-', '?');
	result := Q_ReplaceStr(result, '-?', '?');
	result := Q_ReplaceStr(result, '?. ', '?');
	result := Q_ReplaceStr(result, '?.', '?');
	result := Q_ReplaceStr(result, ' .?', '?');
  Q_DeleteStr(result, '(?)');
	result := Q_ReplaceStr(result, '?', ' ');
end;


procedure TMainForm.WinPlayListGetText(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
  var Text: WideString);
var
  b:Boolean;
  pl : PplstRec;
  Tag: Integer;
begin
	if column < 0 then exit;

	pl := winplaylist.getNodeData(Node);
  Tag := Winplaylist.Header.Columns[Column].Tag;

  if Tag = FWinplayEnqueue then
  	if pl.EnqueueNo > 0 then
    	text := IntToStr(pl.EnqueueNo)
    else
    	text := ''
  else

  if hoVisible in WinplayList.Header.Options then
  begin
  	try
    	if Column = 26 then	//Rating
      	text := ' '
      else
      if Tag = FWinPlayPos then
      	text := IntToStr(Node.Index+1) + '.'
      else
      	if assigned(pl.Rec) then
					GetFTextP(pl.Rec, Tag, text)
        else
        begin
        	if Tag = FFilename then
          	Text := pl.Filename
          else
          if Tag = FLength then
          	Text := IntTimeToStr(pl.Seconds*1000 , false, false)
          else
          if Column = WPRegularTextColumn then
          begin
          	if pl.Playing and (Q_PosStr('://', GetWinplayFilename(pl))>0) then
            	pl.Text := FCurPlayText;
          	Text := pl.Text
          end
          else
          	Text := ''
        end
			except
				text := 'Error: Winplaylist_' + inttostr(tag) ;
			end
  end
  else
  begin
		case column of
			1: if assigned(pl.Rec) then
					text := GetWinplaylistText(Node, pl.Rec)
				else
					text := pl.text;
			2:if assigned(pl.Rec) then
      		text := getFtextP(pl.Rec, FLENGTH)
      	else
				begin
					Text := IntTimeToStr(pl.Seconds*1000, false, false);
					if not pref.ControlPlaylist.checked and (GetTickCount - UpdTimer > 1000) then
					begin
						b := Q_SameText(pl.Filename, pchar(SendMessage(hwnd_winamp, WM_WA_IPC, node.Index-deltaPlaylist, IPC_GETPLAYLISTFILE)));
						if not B then
            begin
            	UpdTimer := GetTickCount;
							updwinplaylist
            end;
						UpdTimer := GetTickCount
					end
			end
		end
  end
end;

procedure TMainForm.WinPlayListPaintText(Sender: TBaseVirtualTree;
  const Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  TextType: TVSTTextType);
begin
	if Column = 0 then
  begin
  	canvas.font.style := [fsBold];
    canvas.font.color := Winplayingcolor
  end
  else
  begin
    if PplstRec(sender.GetNodeData(node)).Playing then
    begin
      if PplstRec(sender.GetNodeData(node)).kill = kill_none then
        canvas.font.style := [fsBold]
      else canvas.font.style := [fsBold, fsItalic];
        canvas.font.color := Winplayingcolor
    end else
    begin
      canvas.font.style := [];
      if vsSelected in node.States then canvas.font.color := winplaylistSelTextColor else
      canvas.font.color := winplaylist.Font.color
    end;

    if PplstRec(sender.GetNodeData(node)).kill = Kill_Del then
      if PplstRec(sender.GetNodeData(node)).Playing then
        canvas.font.color := mixColors(WinKillcolor, WinPlayingColor)
      else
        canvas.font.color := WinKillColor
    else
      if PplstRec(sender.GetNodeData(node)).kill = Kill_ConPlay then
        if PplstRec(sender.GetNodeData(node)).Playing then
          canvas.font.color := mixColors(mixColors(canvas.font.color, winplaylist.color), WinPlayingColor)
        else canvas.font.color := mixColors(canvas.font.color, winplaylist.color)
  end
end;

procedure TMainForm.MoveAddRecListToReclist;
var       aNode:PVirtualNode;
          TD : PTreeData;
          i:integer;
begin
  if AddRecList.count>0 then
  begin
    BeginUseReclist;
    tabel.beginupdate;
    //for i:=0 to AddRecList.count-1 do
    while AddRecList.count > 0 do
    begin
       i := AddRecList.count-1;
       reclist.Add(AddRecList.List^[i]);
       aNode := tabel.AddChild(nil);
       TD := tabel.GetNodeData(aNode);
       TD.p := AddRecList.List^[i];
       if fOnlyPl then
          tabel.IsVisible[aNode] := false
       else tabel.IsVisible[aNode] := filterRec(TD.p);
       AddReclist.Delete(i)
    end;

    UpdateHashedReclist;
    EndUseReclist;
    tabel.endupdate
  end
end;

Procedure TMainForm.TabelToRecList;
var     aNode :PVirtualNode;
begin
  MoveAddRecListToReclist;
  aNode := tabel.getfirst;
  while aNode <> nil do
  begin
    reclist.List^[aNode.index] := PTreeData(tabel.getnodedata(aNode))^.p;
    aNode := tabel.getnext(aNode)
  end
end;

procedure TMainForm.FormDragOver(Sender, Source: TObject; X, Y: Integer;
  State: TDragState; var Accept: Boolean);
begin
        Accept := true
end;

procedure TMainForm.WinPlayListDragOver(Sender: TBaseVirtualTree;
  Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint;
  Mode: TDropMode; var Effect: Integer; var Accept: Boolean);
begin
	if PartyMode1.Checked and pref.DisableDeleteMoveWinampPlaylist.Checked and (Source = WinPlaylist) then
		accept := false
	else
	begin
		Effect := DROPEFFECT_COPY or DROPEFFECT_SCROLL;
		Accept := true
	end
end;

function TMainForm.HasSupportedExtension(const fn:String; SupportedAudioFiles:Boolean; audioFiles:Boolean; playlists:boolean):boolean;
var      ext:String;
         i, x:integer;
begin
     ext := getfileext(fn);
     result := false;
     if SupportedAudioFiles or audioFiles then
        for i:=0 to length(AudioTypes)-1 do
            for x:=0 to length(AudioTypes[i].ext)-1 do
                result := result or Q_SameText(ext, AudioTypes[i].ext[x]);

     result := result or (audiofiles and
               (Q_SameText(ext, '.wav') or Q_SameText(ext, '.mid') or Q_SameText(ext, '.cda') or Q_SameText(ext, '.ogg') or Q_SameText(ext, '.wma')));

     result := result or (playlists and Q_SameText(ext, '.m3u'))
end;

Function TMainForm.GetDropFiles(Sender: TBaseVirtualTree;
// Retunerer alle audio files'ere (ogs geted fra m3u)
             Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
             Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode; const plstRecList:TList):Boolean;
var     FileList:TStringlist;
        PL :PplstRec;
        i, x:integer;
        root, s, s2, fn : String;
        f:textfile;
        r: Prec;
begin
     plstRecList.clear;
     FileList := TStringlist.create;
     result := doGetDropFiles(sender, source, DataObject, Formats, shift, Pt, Effect, Mode, FileList);
     if result then
     begin
          for i:=0 to FileList.count-1 do
          begin
               if HasSupportedExtension(fileList.strings[i], false, false, true) then //Filen er en playlist
               begin
                    //Henter alle filerne ud af playlisten
                    root := getFilePath(FileList.strings[i]);
                    assignfile(f,FileList.strings[i]);
                    Filemode := 0;
                    reset(f);
                    while not eof(f) do
                    begin
                         readln(f,s);
												 if Q_SameTextL(s, '#EXTINF', length('#EXTINF')) then
                         begin
                              readLn(f, fn); //lser filename
                              GetAbsoluteFilename(root, fn);
                              r := findInReclist(fn);
                              if assigned(r) then
                              begin
                                   new(pl);
                                   fillChar(pl^, sizeOf(pl^), #0);
                                   pl.Rec := r;
                                   plstRecList.add(pl)
                              end
                              else
                              if fileexists(s) then
                              begin
																	 new(pl);
                                   fillChar(pl^, sizeOf(pl^), #0);
                                   pl.Text := Q_CopyFrom(s, Q_StrScan(s, ',')+1);
                                   x:= Q_StrScan(s, ':');
                                   s2 := Q_CopyRange(s, x+1, Q_StrScan(s, ',', x)-1);
                                   if Q_IsInteger(s2) then x:=strToInt(s2) else x:=0;
                                   if (x>=0) and (x<=high(word)) then pl.Seconds := x else pl.seconds := 0;
                                   pl.Filename := fn;
                                   plstRecList.add(pl)
                              end
                         end
                         else
                         if (s <> '') and (s[1] <> '#') then
                         begin
                              GetAbsoluteFilename(root, s);
                              r := findInReclist(s);
                              if assigned(r) then
                              begin
                                   new(pl);
                                   fillChar(pl^, sizeOf(pl^), #0);
                                   pl.Rec := r;
                                   plstRecList.add(pl)
                              end
                              else
                              if fileexists(s) then
                              begin
                                   new(pl);
                                   fillChar(pl^, sizeOf(pl^), #0);
                                   pl.text := getFileName(s, false);
                                   pl.filename := s;
                                   plstRecList.add(pl)
                              end
                         end
                    end;
                    closefile(f)
               end
               else
               if HasSupportedExtension(FileList.strings[i], true, true, false) then        //filen er en musik-fil
               begin
                    r := findInReclist(FileList.strings[i]);
                    if assigned(r) then
                    begin
                         new(pl);
                         fillChar(pl^, sizeOf(pl^), #0);
                         pl.Rec := r;
                         plstRecList.add(pl)
                    end
                    else
                    begin
                         new(pl);
                         fillChar(pl^, sizeOf(pl^), #0);
                         pl.text := getFileName(FileList.strings[i], false);
                         pl.filename := FileList.strings[i];
                         plstRecList.add(pl)
                    end
               end
          end
     end
end;

Function TMainForm.doGetDropFiles(Sender: TBaseVirtualTree;
  Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
  Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode; const FilenamesList:TStringList):Boolean;
var     I: Integer;
        Buffer: array[0..2048] of Char;
        fmtetc: tagFORMATETC;
        stgmed: tagSTGMEDIUM;
        dropH: HDROP;
        nFiles, nNames: Cardinal;
        szFileName: array[0..MAX_PATH + 1] of Char;
Begin
        result := true;
     if Length(Formats) < 1 then begin
        result := false;
        Exit;
     end;

     for I := 0 to High(Formats) do begin
         if Formats[I] = CF_VIRTUALTREE then begin
            // From the tree
            //DragDrop(Sender, Shift);
            result := false;
            //Break;
         end else begin
            // From the desktop
//            FilenamesList:=nil;
            if GetClipboardFormatName(Formats[I], @Buffer, 2048) < 1 then continue;
            if not Assigned(DataObject) then continue;

            // Get the data from the clipboard
            fmtetc.cfFormat:=CF_HDROP;
            fmtetc.ptd:=nil;
            fmtetc.dwAspect:=DVASPECT_CONTENT;
            fmtetc.lindex:= -1;
            fmtetc.tymed:=TYMED_HGLOBAL;
            if DataObject.GetData(fmtetc, stgmed)<>S_OK then continue;

            // Lock the data
            dropH:=HDROP(Windows.GlobalLock(stgmed.hGlobal));
            try
               if dropH=0 then continue;

               try
                  // Get the number of filenames
                  nFiles := DragQueryFile(dropH, $FFFFFFFF, nil, 0);
                  result := true;
                  // Get the filenames of each file
//                  FilenamesList:=TStringList.Create;
                  for nNames:=0 to nFiles - 1 do begin
											ZeroMemory(@szFileName, MAX_PATH + 1);
                      DragQueryFile(dropH, nNames, szFilename, MAX_PATH + 1);

                      if FileExists(szFilename) then
                         FilenamesList.Add(szFilename)
                      else if DirectoryExists(szFilename) then
                      begin
                           screen.cursor := crHourGlass;
                           DragFF.Files.Clear;
                           DragFF.RootDirectory := szFilename;
                           DragFF.Search;
                           FilenamesList.AddStrings(DragFF.Files);
                           DragFF.Files.Clear;
                           screen.cursor := crDefault
                      end
                  end;

                  // Get the files
//                  DropFiles(Sender, Shift, FilenamesList);
                  Break;
               finally
                  // Clean-up
//                  FreeAndNil(FilenamesList);
                  GlobalUnlock(stgmed.hGlobal);
               end;
            finally
               ReleaseStgMedium(stgmed);
            end;
         end;
     end;
end;

function SortListByArtistAlbumTrack(Item1, Item2: Pointer): Integer;
begin
	if (rfCompilation in PRec(item1).Flags) and (rfCompilation in PRec(item2).Flags) then
		result :=  integer(Prec(Item1).track) - integer(Prec(Item2).track)
	else
		result := 0;
	if result = 0 then
		result := Prec(Item1).Artist - Prec(Item2).Artist;
	if result = 0 then
		result := Prec(Item1).Album - Prec(Item2).Album;
	if result = 0 then
		result :=  integer(Prec(Item1).track) - integer(Prec(Item2).track)
end;

procedure TMainForm.getDragRecs(aTree: TBaseVirtualTree; recs:TList);
function createFromRec(r:pointer):Pointer;
var      pl:PplstRec;
begin
     new(pl);
     FillChar(pl^, sizeOf(pl^), #0);
     pl.Rec := r;
     result := pl
end;
////////////////////////////////////
var       i:integer;
          sortlist:Tlist;
          aNode:PVirtualNode;
          plConRec:PplConRec;
					plstRec:PplstRec;
          pl:PplstRec;
begin
// Understtter: tree, tabel, playlistbox, plcon, winplaylist
// hvis recs[] er = nil tilfjes filnavnet fil nilFiles
     recs.Clear;
     if aTree = Tree then
     begin
          if fonlyPL then
          begin
               for i:=0 to Fplaylist.count-1 do recs.add(createFromRec(FPlaylist.items[i]))
          end
          else
          begin //NOT onlyPL
            SortList:=Tlist.create;
            for i:=0 to reclist.count-1 do if filterrec(reclist.List^[i], true) then
              SortList.add(reclist.List^[i]);

            SortList.Sort(SortListByArtistAlbumTrack);
            for i:=0 to SortList.count-1 do recs.add(createFromRec(SortList.List^[i]));
            SortList.free
          end
     end
     else
     if aTree = tabel then
     begin
          aNode := tabel.GetFirstSelected;
          while aNode <> nil do
          begin
               recs.Add(createFromRec(getRec(aNode)));
               aNode := tabel.GetNextSelected(aNode)
          end
     end
     else
     if aTree = winplaylist then
     begin
          aNode := winplaylist.GetFirstSelected;
          while aNode <> nil do
          begin
               plstRec := winplaylist.GetNodeData(aNode);
               new(pl);
							 if not assigned(plstRec.Rec) then
								plstRec.Rec := findInReclist(plstRec.filename);

							 pl.Rec := plstRec.Rec;
							 pl.Seconds := plstRec.Seconds;
							 pl.Playing := plstRec.playing;
							 pl.Kill := plstRec.kill;
							 pl.Filename := plstRec.Filename;
							 pl.Text := plstRec.Text;
               recs.add(pl);
               aNode := winplaylist.GetNextSelected(aNode)
          end
     end
     else
     if (aTree = playlistbox) or (aTree = plCon) then
     begin
          if aTree = playlistbox then
             aNode := plCon.GetFirst
          else aNode := plCon.GetFirstSelected;

          while aNode <> nil do
          begin
               plConRec := plCon.GetNodeData(aNode);
               new(pl);
               FillChar(pl^, sizeOf(pl^), #0);
               if not assigned(plConRec.Rec) then plConRec.Rec := findInReclist(plConRec.filename);
               pl.Filename := plConRec.Filename;
               pl.Seconds := plConRec.Seconds;
               pl.Text := plConRec.Text;
               pl.Rec := plConRec.Rec;
               recs.add(pl);
               if aTree = playlistbox then
                  aNode := plCon.GetNext(aNode)
             else aNode := plCon.GetNextSelected(aNode)
          end
     end
end;

function TMainForm.ValidNode(aTree:TVirtualStringTree; Node:pointer):boolean;
var      aNode:PVirtualNode;
begin
     result := false;
     if assigned(Node) then
     begin
          aNode := aTree.GetFirst;
          while (aNode <> nil) and not result do
          begin
               result := aNode = Node;
               aNode := aTree.GetNext(aNode)
          end
     end
end;

procedure TMainForm.WinPlayListDragDrop(Sender: TBaseVirtualTree;
  Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
  Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode);
var     Attachmode: TVTNodeAttachMode;
        aNode, TargetNode, dupNode: PVirtualNode;
        i:integer;
        recs:TList;
        PL:PPlstRec;
        kill:byte;
        playing:boolean;
begin
				UpdateSearchBools;
        SaveWinplayUndo;

				if (ssShift in shift) or (GetKill = Kill_Del) then
           kill := Kill_Del
        else kill := Kill_None;

				if PartyMode1.Checked and pref.AlwaysEnqueueToWP.Checked then
					AttachMode := amNowhere
				else
					case Mode of
								dmAbove:
												AttachMode := amInsertBefore;
								dmOnNode:
                        AttachMode := amInsertAfter;
                dmBelow:
                        AttachMode := amInsertAfter;
								else
												AttachMode := amNowhere;
					end;
        TargetNode := sender.DropTargetNode;
        recs := nil;
        if source is TBaseVirtualTree then
        begin
						 if (source = tabel) or (source = tree) or (source = playlistbox) or (source = plcon) then
             begin
                  recs := TList.create;
                  getDragRecs(TBaseVirtualTree(source), recs)
             end
             else
             if source = winplaylist then
             begin
									i := DROPEFFECT_MOVE;
									winplaylist.ProcessDrop(DataObject, sender.droptargetnode, i, AttachMode);
                  winplaysave
             end
        end
        else //FILES
        begin
             recs := TList.create;
             GetDropFiles(Sender, Source, DataObject, Formats, Shift, Pt, Effect, Mode, recs)
        end;

        if assigned(recs) then
        begin
             winplaylist.beginupdate;
             if continuousPlay1.Checked then
						 begin
                  RemoveConplay;
                  if not ValidNode(winplaylist, TargetNode) then
                     TargetNode := winplaylist.GetLast
             end;

             for i:=0 to recs.count-1 do
             begin
	             if AllowedToAddMoreSongsToPlaylist then
	             begin
                  playing := false;
                  if (kill <> kill_conPlay) and ignoreDuplicates1.Checked then
                  begin
                       dupNode := WinplayFindRef(pPlstRec(recs.items[i]).Rec);
                       if assigned(dupNode) then //der behves ikke at teste om kill=0, dette bliver gjort i winplayfindref
                       begin
                            if pref.ignoreDuplicatesSettings.ItemIndex = 0 then
                            begin
                                 dispose(PPlstRec(recs.items[i]));
                                 continue
                            end else
                            begin
                                 playing := PplstRec(Winplaylist.GetNodeData(dupNode)).playing;
                                 if dupNode=TargetNode then
                                 begin
                                      if AttachMode=amInsertBefore then
                                      begin
                                           TargetNode := winplaylist.GetNext(TargetNode);
                                           if not assigned(TargetNode) then
                                              AttachMode:=amNowhere//fr den til at kre addchild(nil) i stedet
                                      end else
                                      if AttachMode=amInsertAfter then
																			begin
                                           TargetNode := winplaylist.GetPrevious(TargetNode);
                                           if not assigned(TargetNode) then
                                           begin
                                                TargetNode := winplaylist.GetFirst;
                                                AttachMode:= amInsertBefore
                                           end
                                      end
                                 end;
                                 WinplayDequeue(dupNode);
                                 Winplaylist.DeleteNode(dupNode)
                            end
                       end
									end;
									if Attachmode = amNowhere then aNode := winPlayList.AddChild(nil) else aNode := Winplaylist.InsertNode(TargetNode, Attachmode);
									if Attachmode =  amInsertAfter then TargetNode := aNode;
									pl := WinPlayList.GetNodeData(aNode);
									//move(PplstRec(recs.items[i])^, pl^, SizeOf(PplstRec(recs.items[i])^) - SizeOf(PplstRec(recs.items[i]).Filename) + SizeOf(PplstRec(recs.items[i]).Text)); //duer ikke!
									pl.Rec := PplstRec(recs.items[i]).Rec;
									pl.Seconds := PplstRec(recs.items[i]).Seconds;
									pl.Filename := PplstRec(recs.items[i]).Filename;
									pl.Text := PplstRec(recs.items[i]).Text;
									pl.Playing := playing;
									pl.Kill := kill;
               end;
               dispose(PPlstRec(recs.items[i]))
						 end;
             recs.free;
             if continuousPlay1.checked then CheckConPlay;
						 winplaysave;
						 winplaylist.endupdate
				end
end;

procedure TMainForm.searchlabelClick(Sender: TObject);
begin
  if pref.DeOp.itemindex = 0 then pref.DeOp.itemindex := 1 else pref.DeOp.itemindex := 0;
  case pref.DeOp.itemindex of
    0:searchlabel.caption := GetText(150);
    1:searchlabel.caption := GetText(151);
  end;

  filterbarResize(sender);

  screen.cursor := crhourglass;
  ApplyFilter;
  screen.cursor := crdefault
end;

procedure TMainForm.treeDragAllowed(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
begin
	allowed := true
end;

procedure TMainForm.plconGetText(Sender: TBaseVirtualTree;
	Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
  var Text: WideString);
var   pl:pPlconRec;
begin
      pl := plCon.getNodeData(Node);
      if assigned(pl.Rec) then
      begin
           text := getFtextP(pl.Rec, fArtistTitle);
           if pref.topcountshow.checked and PPlBoxData(playlistbox.getNodeData(playlistbox.GetFirstSelected)).toplist then
              text := '[' + inttostr(pl.Rec.playcount) + '] ' + text
      end
      else
          text := pl.text
end;


function TMainForm.GetHint(rec: PRec):string;
begin
        result := GetFtextP(rec, fFilename) + #13 +
                        GetText(TXT_ColumnArtist) + ':            ' + getFtextP(rec, fArtist) + #13+
                        GetText(TXT_ColumnTITLE) + ':               ' +  getFtextP(rec, fTitle);
        if rec.track > 0 then text := text + '  [Track ' + inttostr(rec.track) + ']';
        if getFtextP(rec, fAlbum) <> '' then text := text + #13 +
                        GetText(TXT_ColumnAlbum)+':             ' + getFtextP(rec, fAlbum);
        result := result + #13;
        result := result + GetText(TXT_ColumnLength) + ':             ' + getFtextP(rec, fLength) +#13 +
												GetText(TXT_SAMPLERATE) + ':        ' + inttostr(rec.Khz) + ' Hz ' + GetFtextP(rec, fChannels) + #13 +
												GetText(TXT_BITRATE) + ':                ' + getFtextP(rec, FKBPS) + ' KBps' + #13;
				if rec.Playcount <> 1 then
					result := result + GetText(TXT_PlayedXtimes, [inttostr(rec.Playcount)])
				else
					result := result + GetText(TXT_PlayedOneTime)
end;

procedure TMainForm.DoTabelCompareNodes(rec1, rec2:PRec; Column:integer; var Result: integer);
{function GetTagTagValue(flags: Word): Integer;
begin
	if GetFlag(flags, RF_HasId3v1 or RF_HasId3v2) then
  	result := 3
  else
  if GetFlag(flags, RF_HasId3v1) then
  	result := 1
  else
  if GetFlag(flags, RF_HasId3v2) then
  	result := 2
  else
  if GetFlag(flags, RF_HasApeTag) then
  	result := 4
  else
  if GetFlag(flags, RF_HasOggTag) then
  	result := 5
  else
  if GetFlag(flags, RF_HasWmaTag) then
  	result := 6
  else
  	result := 7
end;  }

Function GetCustomFieldData(rec: PRec): Pointer;
var
	i: Integer;
begin
	result := nil;
	for i:=0 to length(rec.CustomFields)-1 do
  	if rec.CustomFields[i].FieldIndex = Column - FCustomField then
    begin
   		result := rec.CustomFields[i].data;
      break
    end
end;

var
	CustomFieldData1, CustomFieldData2: Pointer;
begin
  case Column of
    FFILENAME, FGENRE, FCOMMENT, FGROUPS, FFNAME, FQUALITY
                    :if pref.CaseSensitiveSort.Checked then
                      result := Q_CompStr(GetFtextP(rec1, Column), GetFtextP(rec2, Column))
                    else
                    	result := Q_CompText(GetFtextP(rec1, Column), GetFtextP(rec2, Column));

    FTITLE:         if pref.CaseSensitiveSort.Checked then
    									result := Q_PCompStr(rec1.Title, rec2.Title)
    								else
                    	result := Q_PCompText(rec1.Title, rec2.Title);

    FFILEPATH       :if pref.CaseSensitiveSort.Checked then
                      result := rec1.Fpath - rec2.Fpath
    								else
                    	result := Q_CompText(GetFTextP(rec1, FFilePath), GetFTextP(rec2, FFilePath));

    FARTIST         :if pref.CaseSensitiveSort.Checked then
    									result := rec1.Artist - rec2.Artist
    								else
                    	result := Q_PCompText(pchar(artistlist.Strings[rec1.Artist]), pchar(artistlist.Strings[rec2.Artist]));

  	FArtistSortOrder:if pref.CaseSensitiveSort.Checked then
                      result := rec1.ArtistSortOrder - rec2.ArtistSortOrder
    								else
                    	result := Q_PCompText(pchar(artistlist.Strings[rec1.ArtistSortOrder]), pchar(artistlist.Strings[rec2.ArtistSortOrder]));

    FALBUM          :if pref.CaseSensitiveSort.Checked then
                      result := rec1.Album - rec2.Album
    								else
                    	result := Q_PCompText(pchar(albumList.Strings[rec1.Album]), pchar(albumList.Strings[rec2.Album]));

    FYEAR           :result := CompSmallInt(rec1.Year, rec2.Year);
    FTRACK   :    	begin
    									result := CompWord(rec1.Track, rec2.Track);
                      if result = 0 then
                      	result := CompWord(rec1.TotalTracks, rec2.TotalTracks);
                    end;
    FTrackInfo		:	begin
                      result := integer(GetPartOfSet(rec1)) - integer(GetPartOfSet(rec2));
                      if result = 0 then
                      begin
                      	result := integer(rec1.Track) - integer(rec2.Track);
                        if result = 0 then
                        	result := integer(rec1.TotalTracks) - integer(rec2.TotalTracks)
                      end
    								end;
    FPartOfSetText	:result := CompByte(GetPartOfSet(rec1), GetPartOfSet(rec2));
    FKBPS           :result := CompSmallInt(abs(rec1.Kbps), abs(rec2.Kbps));
    FLENGTH         :result := CompCardinal(rec1.Length,  rec2.Length);
    FLOCATION       :result := rec1.Location - rec2.Location;
    FCHANNELS       :result := CompShortInt(rec1.Channels, rec2.Channels);
    FFSIZE          :result := CompCardinal(rec1.Fsize, rec2.Fsize);
    FKHZ            :result := CompWord(rec1.Khz, rec2.Khz);
    FCRC            :result := CompCardinal(rec1.CRC, rec2.CRC);
    FAUDIOTYPE      :result := AudioTypes[rec1.AudioType].SortIndex - AudioTypes[rec2.AudioType].SortIndex;
    FDATABASETIME   :result := CompareDates(rec1.DatabaseTime, rec2.DatabaseTime);
    FLASTWRITEDATE  :result := CompareDates(rec1.LastWriteTime, rec2.LastWriteTime);
    FTags						:result := Q_CompStr(GetFtextP(rec1, Column), GetFtextP(rec2, Column)); //GetTagTagValue(rec1.Flags) - GetTagTagValue(rec2.Flags);
    FLyrics					:result := integer(rfHasLyrics in rec2.Flags) - integer(rfHasLyrics in rec1.Flags);
    FAutoScanned	  :result := integer(rfAutoScanned in rec2.Flags) - integer(rfAutoScanned in rec1.Flags);
    FRating					:result := CompByte(rec1.Rating, rec2.Rating);
    FPlaycount			:result := integer(rec1.Playcount) - integer(rec2.PlayCount)
  else
  	if Column >= FCustomField then
    begin
    	CustomFieldData1 := GetCustomFieldData(rec1);
      CustomFieldData2 := GetCustomFieldData(rec2);
      if not Assigned(CustomFieldData1) and not Assigned(CustomFieldData2) then
      	result := 0
      else
      if not Assigned(CustomFieldData1) and Assigned(CustomFieldData2) then
      	result := -1
      else
      if Assigned(CustomFieldData1) and not Assigned(CustomFieldData2) then
      	result := 1
      else
      	case PCustomField(FieldList.Items[Column - FCustomField]).dataType of
        	0: result := Q_CompText(PStringData(CustomFieldData1).Value, PStringData(CustomFieldData2).Value);
          1: result := PIntegerData(CustomFieldData1).Value - PIntegerData(CustomFieldData2).Value;
          2: result := CompSingle(PRealData(CustomFieldData1).Value, PRealData(CustomFieldData1).Value);
        end
    end
    else
		  result := 0
  end
end;

procedure TMainForm.tabelCompareNodes(Sender: TBaseVirtualTree; Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
var      p1, p2:pointer;
begin
  p1 := PTreeData(sender.GetNodeData(Node1))^.p;
  p2 := PTreeData(sender.GetNodeData(Node2))^.p;

  DoTabelCompareNodes(p1, p2, column, result);
  if (result = 0) and (FMLSortedCol1 <> Column) then
     doTabelCompareNodes(p1, p2, FMLSortedCol1, result)
end;

function GetTreeKindSortValue(tk:PTreeRec):integer;  				//used in treeCompareNodes
begin
	case tk.Kind of
  	TreeKind_GroupParent: result := 1;
   	TreeKind_GroupSetting: result := 2;
    TreeKind_CompilationParent: result := 3;
  	TreeKind_Harddisk: result := 4;
    TreeKind_Zip: result := 5;
    TreeKind_CDROM: result := 6;
    TreeKind_Network: result := 7;
    TreeKind_PlaylistParent: result := 8;
  else
  	result := 100
  end;
end;

function GetBasicTreeKind(kind: TTreeKind): TTreeKind;
begin
	case kind of
  	TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum: result := TreeKind_Album
  else
  	result := kind
  end
end;

function IsCompilationKind(kind: TTreeKind): Boolean;  				//used in treeCompareNodes
begin
	result := Kind in [TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum]
end;

procedure TMainForm.treeCompareNodes(Sender: TBaseVirtualTree; Node1,
  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
var
	s1, s2: WideString;
  tr1, tr2: PTreeRec;
  commonKind: TtreeKind;	//Set if both tr1.kind and tr2.kind are the same.
begin
	tr1 := sender.GetNodeData(Node1);
	tr2 := sender.GetNodeData(Node2);

  commonKind := GetBasicTreeKind(tr1.Kind);
  if commonKind <> GetBasicTreeKind(tr2.Kind) then
  	commonKind := TTreeKind(-1);

  if CommonKind = TreeKind_Set then
  begin
    result := integer(GetTotalParts(tr1.tag)) - integer(GetTotalParts(tr2.tag));
    if result = 0 then
      result := integer(GetPartOfSet(tr1.tag)) - integer(GetPartOfSet(tr2.tag));
    exit;
  end
  else
  if (CommonKind in [TreeKind_Artist, TreeKind_Album, TreeKind_Year, TreeKind_Decade, TreeKind_Rating]) then
  begin
    result := tr1.Tag - tr2.Tag;
    exit;
  end
  else
  if IsCompilationKind(tr1.Kind) and (not IsCompilationKind(tr2.Kind)) and (pref.CompilationPlacement.ItemIndex <> 1) then
  begin
    result := pref.CompilationPlacement.ItemIndex -1;
    exit;
  end
  else
  if IsCompilationKind(tr2.Kind) and (not IsCompilationKind(tr1.Kind)) and (pref.CompilationPlacement.ItemIndex <> 1) then
  begin
    result := -1*(pref.CompilationPlacement.ItemIndex -1);
    exit;
  end;

  if integer(CommonKind) <> -1 then
  begin
	  result := GetTreeKindSortValue(tr1) - GetTreeKindSortValue(tr2);
    if result <> 0 then
    	exit
  end;

  TreeGetText(Tree, Node1, 500, ttNormal, s1);
  TreeGetText(Tree, Node2, 500, ttNormal, s2);
  result := Q_CompText(s1, s2)
end;

procedure TMainForm.TreeSaveNode(Node: PVirtualNode; Stream: TStream; sortedCoverImgs: TList);
function FindCoverRecIndex(p: pointer; var index: Integer): Boolean;
var
  H, I, C: Integer;
begin
  Result := False;
  index := 0;
  H := sortedCoverImgs.Count - 1;
  while index <= H do
  begin
    I := (index + H) shr 1;
    C := CompInteger(integer(PPointerAndInt(sortedCoverImgs.List^[i]).p), integer(p));
    if C < 0 then Index := I + 1 else
    begin
      H := I - 1;
      if C = 0 then
      begin
        Result := True;
        index := I;
      end;
    end;
  end;
end;
var
	TR:PTreeRec;
  flags, TextSize: byte;
  coverRecIndex: Integer;
begin
  TR := tree.getnodedata(node);
  if TR.Kind = treeKind_Playlist then
    TR.tag := m3uList.IndexOf(TR.PlRecRef);

  stream.write(TR^, sizeof(TTreeRecSave));

  if TR.Kind in [TreeKind_Drive, TreeKind_DriveRecursive, TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive] then
  	stream.Write(TR.PathListIndex, SizeOf(TR.PathListIndex));

  flags := 0;
  TextSize := min(length(TR.Text), 255);

  if TR.Exists then
  	flags := flags or $1;

  if TR.Editable then
  	flags := flags or $2;

  if TR.TotalTime > high(Integer) then
  	flags := flags or $4;

  if not (TR.Kind in [TreeKind_Artist, TreeKind_Album, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_Genre, TreeKind_Group, TreeKind_GroupParent, TreeKind_Playlist, TreeKind_playlistParent, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_CompilationParent, TreeKind_Year, TreeKind_Decade]) and (TextSize > 0) then
  	flags := flags or $8;

  if Assigned(TR.CoverRec) and FindCoverRecIndex(TR.CoverRec, coverRecIndex) then
  begin
  	//coverRecIndex := fCoverImgs.IndexOf(TR.CoverRec);
    coverRecIndex := PPointerAndInt(sortedCoverImgs.List^[coverRecIndex]).i;
    if coverRecIndex >= 0 then
	  	flags := flags or $10;
  end;

  Stream.Write(flags, SizeOf(flags));

  if flags and $4 = $4 then
  	Stream.Write(TR.TotalTime, SizeOf(int64))
  else
  	Stream.Write(TR.TotalTime, SizeOf(Integer));

  if flags and $8 = $8 then
  begin
	  stream.Write(TextSize, sizeOf(TextSize));
	  if TextSize > 0 then
	  	stream.Write(TR.Text[1], TextSize)
  end;

  if flags and $10 = $10 then  //Cover-rec
    stream.Write(coverRecIndex, SizeOf(coverRecIndex))
end;

procedure TMainForm.treeLoadNode(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Stream: TStream);
var
  TR: PTreeRec;
  flags, TextSize: Byte;
  i: Integer;
begin
  TR := tree.GetNodeData(Node);
  Fillchar(TR^, SizeOf(TR^), 0);
  stream.Read(TR^, sizeof(TTreeRecSave));

  if TR.Kind in [TreeKind_Drive, TreeKind_DriveRecursive, TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive] then
  	stream.Read(TR.PathListIndex, SizeOf(TR.PathListIndex));

  Stream.Read(flags, SizeOf(flags));

  TR.Exists := flags and $1 = $1;
  TR.Editable := flags and $2 = $2;

	if flags and $4 = $4 then
  	Stream.Read(TR.TotalTime, SizeOf(int64))
  else
  	Stream.Read(TR.TotalTime, SizeOf(integer));

  if flags and $8 = $8 then
  begin
	  stream.Read(TextSize, sizeOf(TextSize));
    SetLength(TR.Text, TextSize);
    if TextSize > 0 then
		  stream.Read(TR.Text[1], TextSize)
  end;

  if flags and $10 = $10 then
  begin
  	stream.Read(i, SizeOf(i));
    if (i >= 0) and (i < fCoverImgs.Count) then
    	TR.CoverRec := fCoverImgs.List^[i]
  end;

  if TR.Kind = treeKind_Playlist then
  begin
	  if (TR.tag>=0) and (TR.tag<m3uList.count) then
	    TR.PlRecRef := m3uList.Items[TR.tag]
	  else TR.PlRecRef := nil
	  end else TR.PlRecRef := nil
end;

Procedure TMainForm.AdjustNodeHeight(aTree:TVirtualStringTree);
var
	aNode : PvirtualNode;
begin
	aTree.beginupdate;
	aTree.DefaultNodeHeight := abs(aTree.Font.Height) + 6;
	aNode := aTree.GetFirst;
	while aNode <> nil do
	begin
		aTree.NodeHeight[aNode] := aTree.DefaultNodeHeight;
		aNode := aTree.GetNext(aNode)
	end;

  if ((aTree = tabel) or ((aTree = winplaylist) and (hoVisible in winplaylist.Header.Options))) or (aTree = tree) then
  	SetRatingStarFontSize(aTree);

	aTree.endupdate
end;

procedure TMainForm.SetRatingStarFontSize(sender: TVirtualStringTree);   //Works with tabel and winplaylist
var
	bm: TBitmap;
begin
	bm := TBitmap.Create;
  bm.Canvas.Font.Name := 'Wingdings';
  bm.Canvas.Font.Style := [fsBold];
  bm.Canvas.Font.Size := 1;

  while bm.Canvas.TextHeight('') <= (sender.DefaultNodeHeight * 1) do
  	bm.Canvas.Font.Size := bm.Canvas.Font.Size +1;

  FStarFontSize[GetTreeIndex(Sender)] := bm.Canvas.Font.Size;

  //  Set8087CW(Default8087CW);

	if (sender=tabel) or (sender=winplaylist) then
	  sender.Header.Columns[24 + 2*GetTreeIndex(Sender)].Width := Trunc(bm.Canvas.TextWidth('') * 1.1);

  bm.Free
end;

function TMainForm.GetTreeIndex(tree: TVirtualStringTree): Integer;
begin
	if tree = tabel then
  	result := 0
  else
  	result := 1
end;

procedure TMainForm.plconDragDrop(Sender: TBaseVirtualTree;
  Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
	Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode);
var     Attachmode: TVTNodeAttachMode;
        aNode, TargetNode : PVirtualNode;
        i:integer;
        recs:Tlist;
        PL:PplConRec;
        PW:PplstRec;
begin
        UpdateSearchBools;
        case Mode of
                dmAbove:
                        AttachMode := amInsertBefore;
                dmOnNode:
                        AttachMode := amInsertAfter;
                dmBelow:
                        AttachMode := amInsertAfter;
                else
                        AttachMode := amNowhere;
                end;
        TargetNode := sender.DropTargetNode;
        recs := nil;
        if source is TBaseVirtualTree then
        begin
             if (source = tabel) or (source = tree) or (source = winplaylist) then
             begin
                  recs := TList.create;
                  getDragRecs(TBaseVirtualTree(source), recs)
             end
             else
             if source = plcon then
             begin
                  i := DROPEFFECT_MOVE;
                  plcon.ProcessDrop(DataObject, sender.droptargetnode, i, AttachMode);
                  updateplaylist
             end
        end
        else //FILES
        begin
             recs := TList.create;
             GetDropFiles(Sender, Source, DataObject, Formats, Shift, Pt, Effect, Mode, recs)
        end;

        if assigned(recs) then
        begin
             plCon.beginupdate;
             for i:=0 to recs.count-1 do
             begin
                  if Attachmode = amNowhere then aNode := plCon.AddChild(nil) else aNode := plCon.InsertNode(TargetNode, Attachmode);
                  if Attachmode =  amInsertAfter then TargetNode := aNode;
                  pl := plCon.GetNodeData(aNode);
                  fillChar(pl^, sizeof(pl^), #0);
                  pw := recs.items[i];
                  if assigned(pw.Rec) then
                     pl.Rec := pw.Rec
                  else
                  begin
                       pl.Filename := pw.Filename;
                       pl.Seconds := pw.Seconds;
                       pl.Text := pw.text
                  end;
                  dispose(pw)
             end;
             recs.free;
             updateplaylist;
             plCon.endupdate
        end
end;



procedure TMainForm.plconDragAllowed(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
begin
        allowed := true
end;

procedure TMainForm.plconDragOver(Sender: TBaseVirtualTree;
  Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint;
	Mode: TDropMode; var Effect: Integer; var Accept: Boolean);
begin
	if (playlistbox.SelectedCount = 0) or (PartyMode1.Checked and pref.DisableEditQuicklist.Checked) then
		accept := false
	else
		accept := not PPlBoxData(playlistbox.getnodedata(playlistbox.GetFirstSelected))^.toplist
end;

procedure TMainForm.treeDragOver(Sender: TBaseVirtualTree;
  Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint;
  Mode: TDropMode; var Effect: Integer; var Accept: Boolean);
var
	aNode:PVirtualNode;
	i:integer;
	TK: TtreeKind;
begin
	aNode := tree.getnodeat(pt.x, pt.y, true, i);
	if aNode = nil then
	begin
		Effect := DROPEFFECT_NONE or DROPEFFECT_SCROLL;
		Accept := false
	end else
	begin
		TK := PtreeRec(tree.getnodedata(aNode))^.Kind;
		if (TK = treeKind_PlayList) and (Mode = dmOnNode) and not (PartyMode1.Checked and pref.DisableEditPlaylist.Checked) then
		begin
			Effect := DROPEFFECT_COPY or DROPEFFECT_SCROLL;
			Accept := true
		end else
		if (Mode = dmOnNode) and (TK in [TreeKind_Artist, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_Album, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_Genre, TreeKind_Group, TreeKind_CompilationParent, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_Year, TreeKind_Rating{, TreeKind_Directory, TreeKind_Directory2}]) and pref.TreeTagging.Checked and ((ssAlt in Shift) or not pref.TreeTagAltPressed.Checked or (tk = treekind_genre)) and not (partyMode1.Checked and pref.DisableTagging.Checked) then
		begin    	
			Accept := true;
			if (ssShift in Shift) and (TK in [TreeKind_Group, TreeKind_CompilationParent]) then
				Effect := DROPEFFECT_MOVE or DROPEFFECT_SCROLL
			else
				Effect := DROPEFFECT_COPY or DROPEFFECT_SCROLL
		end
		else
		begin
			Effect := DROPEFFECT_NONE or DROPEFFECT_SCROLL;
			Accept := false
		end
	end
end;

function TMainForm.GetTreeText(tree: TVirtualStringTree; Node: PVirtualNode):WideString;
begin
	result := '';
  if Assigned(tree.OnGetText) then
  	tree.OnGetText(tree, Node, 500, ttStatic, result)
end;

procedure TMainForm.WinPlayListDragAllowed(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
begin
	if PartyMode1.Checked and pref.DisableDeleteMoveWinampPlaylist.Checked and Winplaylist.Dragging then
		Allowed := false
	else
		Allowed := true
end;

procedure TMainForm.treeDragDrop(Sender: TBaseVirtualTree;
	Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
  Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode);
function newExtStr(PL:pPLrec; r:Prec):String;
begin
	result := GetFtextP(r, fExtStr) + CRLF;
  if pref.RelativePaths.Checked then
  	result := result + GetRelativePath(getFilePath(PL.filename), GetFTextP(r, FFilePath)) + GetFTextP(r, Ffname) + CRLF
  else
  	result := result + GetFtextP(r, fFilename) + #13#10
end;

procedure AddToMsg(var msg: String; const prepend: String);
begin
	if length(msg) =0 then
		msg := prepend
	else msg := prepend + #13 + msg
end;

Function NodePath(aNode:PVirtualNode):String;
var
	bNode:PVirtualNode;
begin
  result := '';
  bNode := aNode;
  while bNode <> nil do
  begin
    result := GetTreeText(tree, bNode) + '\' + result;
    bNode := bNode.parent;
    if bNode = tree.rootnode then
    	bNode := nil
  end;
  if showmedia1.checked then
  	result := Q_CopyFrom(result, Q_StrScan(result, '\')+1)
end;

var
	TargetNode, aNode : PVirtualNode;
  i, index:integer;
  recs, recsToTag : TList;
  Fstr : TStream;
  S, msg :String;
  c:Char;
  b :boolean;
  PL : pPLrec;
  TR : pTreeRec;
  PW:PplstRec;
  PrevKind : TTreeKind;
  tagValues : TtagValues;
begin
	if Mode <> dmOnNode then
		exit;

	UpdateSearchBools;
	TargetNode := sender.DropTargetNode;

	TR := tree.getNodeData(TargetNode);
	if ((TR.Kind = TreeKind_Playlist) and (PartyMode1.Checked and pref.DisableEditPlaylist.Checked)) or ((TR.Kind <> TreeKind_Playlist) and (PartyMode1.Checked and pref.DisableTagging.Checked)) then
		exit;

	recs := nil;
	if source is TBaseVirtualTree then
	begin
	 if (source = tabel) or (source = tree) or (source = winplaylist) or (source = plcon) or (source = playlistbox) then
	 begin
   	recs := TList.create;
    getDragRecs(TBaseVirtualTree(source), recs)
	 end
	end
	else //FILES
	begin
	 recs := TList.create;
	 GetDropFiles(Sender, Source, DataObject, Formats, Shift, Pt, Effect, Mode, recs)
	end;

	if assigned(recs) then
	begin
  	try
      if TR.Kind = TreeKind_Playlist then
      begin
        PL := TR.PlRecRef;
        TR.Count := 0;
        TR.TotalTime := 0;
        //bner Playlist filen fra HD
        if getFileAccess(PL.filename, true, true, true) then
        begin
          Fstr := TFileStream.create(PL.filename, fmOpenReadWrite or fmShareExclusive);
          if Fstr.Size <= 2 then
          begin
            //Skriver hoved
            s:= '#EXTM3U' + #13#10;
            Fstr.writeBuffer(pointer(s)^, length(s))
          end;
          b := false;
          Fstr.position := Fstr.size-2;
          Fstr.Read(c, sizeof(c));
          if c=#13 then b := true;
          Fstr.Read(c, sizeof(c));
          if c=#13 then b := true;

          if not b then
          begin
            s:= CRLF;
            Fstr.writeBuffer(pointer(s)^, length(s))
          end;
          s := '';

          for i:=0 to recs.count-1 do
          begin
            pw := recs.items[i];
            if assigned(pw.Rec) then
              s := newExtStr(PL, pw.Rec)
            else
            	if pref.RelativePaths.Checked then
              	s := '#EXTINF' + ':' + inttostr(pw.Seconds) + ',' + pw.text + CRLF + GetRelativePath(getFilePath(PL.filename), GetfilePath(pw.Filename)) + GetFilename(pw.Filename) + CRLF
              else
	              s := '#EXTINF' + ':' + inttostr(pw.Seconds) + ',' + pw.text + CRLF + pw.Filename + CRLF;
            Fstr.writeBuffer(pointer(s)^, length(s))
          end;
          Fstr.free;
          UpdatePLcache(PL, true);
          TreeFilter
        end
        else showmessageX(GetText(TXT_CouldNotOpenPLforWriting));
      end //of if kind = Playlist
      else
     { if TR.Kind in [TreeKind_Directory, TreeKind_Directory2] then
      begin
        //finder target dir:
      	dir := fpathList.Strings[TR.Tag];
        showmessagex(dir);
        if tree = source then
        begin
        	//Finder CommonKind
          aNode := tree.GetFirstSelected;
          CommonKind := pTreeRec(tree.GetNodeData(aNode)).Kind;
          aNode := tree.GetNextSelected(aNode);
          SameKind := true;
          while aNode <> nil do
          begin
          	SameKind := SameKind and (CommonKind = pTreeRec(tree.GetNodeData(aNode)).Kind);
            aNode := tree.GetNextSelected(aNode)
          end
        end
        else
        	SameKind := false;

				if tree = source then
        begin
        	//Der er flytet fra tret


        end
        else
        begin


        end
      end	//of TR.Kind = TreeKind_Directory
      else    }
      begin
        msg := '';
        setLength(tagValues, 0);
        aNode := TargetNode;
        while (aNode <> nil) and (aNode <> Tree.rootnode) do
        begin
          TR := tree.GetNodeData(aNode);
          if (TR.Kind in [TreeKind_Artist, TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_Album, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_Genre, TreeKind_Group, TreeKind_CompilationParent, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum, TreeKind_Year, TreeKind_Rating {, TreeKind_Directory}]) and pref.TreeTagging.Checked and ((ssAlt in Shift) or not pref.TreeTagAltPressed.Checked or (TR.Kind = treekind_genre)) and not (partyMode1.Checked and pref.DisableTagging.Checked) then
          begin
            setLength(tagValues, length(tagValues)+1);
            index := length(tagValues)-1;

            if TR.Kind = TreeKind_Artist then
            begin
              AddToMsg(Msg, GetText(TXT_SetArtistTo, [GetTreeText(tree, aNode)]));
              tagValues[index].field := FArtist;
              tagValues[index].value := GetTreeText(tree, aNode)
            end
            else
            if TR.Kind in [TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_Album, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum] then
            begin
              s := AlbumList.Strings[PtreeRec(tree.GetNodeData(aNode)).tag];
              AddToMsg(Msg, GetText(TXT_SetAlbumTo, [s]));
              tagValues[index].field := FAlbum;
              tagValues[index].value := s
            end
            else
            if TR.Kind = TreeKind_Year then
            begin
            	s := inttostr(PtreeRec(tree.GetNodeData(aNode)).tag);
							AddToMsg(Msg, GetText(TXT_SetYearTo, [s]));
              tagValues[index].field := FYear;
              tagValues[index].value := s
            end
            else
            if TR.Kind = TreeKind_Genre then
            begin
            	TreeDropPopup.Popup(pt.x, pt.y);
              while not fTreeDropMenuClosed do
              	Application.ProcessMessages;
              Application.ProcessMessages;

              if TreeDropPopup.Tag in [1, 2, 3] then
              	tagValues[index].value := GetTreeText(tree, aNode);
              case TreeDropPopup.Tag of
              	1:
                begin
                	AddToMsg(Msg, GetText(TXT_SetGenreTo, [GetTreeText(tree, aNode)]));
                	tagValues[index].field := FGenre;
                end;

                2:
                begin
                	AddToMsg(Msg, GetText(TXT_AddToGenre, [GetTreeText(tree, aNode)]));
                	tagValues[index].field := FAddGenre;
                end;

                3:
                begin
                	AddToMsg(Msg, GetText(TXT_RemoveFromGenre, [GetTreeText(tree, aNode)]));
                	tagValues[index].field := FRemoveGenre;
                end;

                0:
                	setLength(tagValues, length(tagValues)-1);
              end;


            {  if ssShift in Shift then
              begin
                AddToMsg(Msg, GetText(TXT_RemoveFromGenre, [GetTreeText(tree, aNode)]));
                tagValues[index].field := FRemoveGenre;
              end else
              begin
                AddToMsg(Msg, GetText(TXT_AddToGenre, [GetTreeText(tree, aNode)]));
                tagValues[index].field := FAddGenre
              end; }
            end
            else
            if TR.Kind = TreeKind_Group then
            begin
              if ssShift in Shift then
              begin
                AddToMsg(Msg, GetText(TXT_RemoveFromGroup, [GetTreeText(tree, aNode)]));
                tagValues[index].field := FRemoveGroup
              end else
              begin
                AddToMsg(Msg, GetText(TXT_AddToGroup, [GetTreeText(tree, aNode)]));
                tagValues[index].field := FAddGroup
              end;
              tagValues[index].value := GetTreeText(tree, aNode)
            end
            else
            if TR.Kind = TreeKind_CompilationParent then
            begin
              if ssShift in Shift then
              begin
                AddToMsg(Msg, GetText(TXT_UnsetCompilation));
                tagValues[index].value := '0'
              end else
              begin
                AddToMsg(Msg, GetText(TXT_SetCompilation));
                tagValues[index].value := '1'
              end;
              tagValues[index].field := FCompilation
            end
            else
            if TR.Kind in [TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum] then
            begin
              AddToMsg(Msg, GetText(TXT_SetCompilationAlbumTo, [GetTreeText(tree, aNode)]));
              tagValues[index].field := FCompilation;
              tagValues[index].value := '1';
              setLength(TagValues, length(TagValues)+1);
              inc(index);
              tagValues[index].field := FAlbum;
              tagValues[index].value := GetTreeText(tree, aNode)
            end
            else
            if TR.Kind = TreeKind_Rating then
            begin
            	AddToMsg(Msg, GetText(TXT_SetRatingTo, [inttostr(TR.Tag)]));
              tagValues[index].field := FRating;
              tagValues[index].value := inttostr(Round(TR.Tag/5 * 255))
            end;

            PrevKind := TR.Kind;
            aNode := aNode.Parent;
            if assigned(aNode) then
            begin
              TR := tree.GetNodeData(aNode);
              if (PrevKind in [TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum]) and (TR.Kind = TreeKind_CompilationParent) then
                aNode := aNode.Parent
            end
          end //if kind = [, , , , ]
          else
            aNode := aNode.parent
        end; //of while

        if length(TagValues) > 0 then
          if pref.TreeTagShowConfirm.Checked then
            b := YesNoBoxx(GetText(TXT_TagFiles), msg, GetText(TXT_Yes), GetText(TXT_No), 1)
          else b := true
        else b := false;

        if b then
        begin
        	recsToTag := TList.Create;

          for i:=0 to recs.Count-1 do
          begin
            pw := recs.items[i];
            if assigned(pw.Rec) then
              recsToTag.Add(pw.Rec);
          end;

          UpdateRecValues(recsToTag, tagValues, 'Tagging...', true, GetDefaultUpdateTags)

        end
      end;
      for i:=0 to recs.Count-1 do
      begin
        finalize(PplstRec(recs.items[i])^);
        dispose(PplstRec(recs.items[i]))
      end;
    finally
    end;
		recs.free;

    PostMessage(Self.Handle, WM_UPDATE_TREE, 1, 0);
	end; //of "if assigned(recs) then"
end;

procedure TMainForm.doPaintForm(clientWidth: Integer; clientHeight: Integer);
begin
  if quitting then
  	exit;
	if clientHeight <> WindowShadeHeight then
	begin
  	updateTopImageBuffer;
    if MainFormInstance.ClientWidth > SmallWindowLimit then
    	Self.prepareCurPlayText(false, false);

		//tegner sider
		TileDraw(Canvas, imgLeft, rect(0, 0, imgLeft.Width, clientHeight));
		TileDraw(Canvas, imgRight, rect(clientWidth - imgRight.Width, 0, clientWidth, clientHeight));

		//tegner bunden
		TileDraw(Canvas, imgLower, rect(imgLowerLeft.Width, clientHeight - imgLower.Height, clientWidth-imgLowerRight.Width, clientHeight));
		//Canvas.Draw(0, clientHeight - imgLowerLeft.Height, imgLowerLeft);
    BitBlt(canvas.handle, 0, clientHeight-imgLowerLeft.Height, imgLowerLeft.Width, imgLowerLeft.Height, imgLowerLeft.Canvas.Handle, 0, 0, SRCCOPY);
		//Canvas.Draw(clientWidth-imgLowerRight.Width, clientHeight-imgLowerRight.Height, imgLowerRight);
    BitBlt(canvas.handle, clientWidth-imgLowerRight.Width, clientHeight-imgLowerRight.Height, imgLowerRight.Width, imgLowerRight.Height, imgLowerRight.Canvas.Handle, 0, 0, SRCCOPY);

    //tegner curplaylabel
    if MainFormInstance.ClientWidth > SmallWindowLimit then
    begin
    	//Self.prepareCurPlayText(false, false);
    	//Canvas.Draw(FCurPlayRect.Left, FCurPlayRect.Top, FCurPlayBitmap)
      BitBlt(canvas.Handle, FCurPlayRect.Left, FCurPlayRect.Top, FCurPlayBitmap.width, FCurPlayBitmap.Height, FCurPlayBitmap.Canvas.Handle, 0, 0, SRCCOPY)
    end;

		//tegner volbar + repeat/shuffle
		volbarPaint(nil, Canvas);
	end;
	//tegner toppen
//	updateTopImageBuffer;                 //Flyttet til toppen (01/07-05)
	//Canvas.Draw(0, 0, topImageBuffer)
  BitBlt(canvas.handle, 0, 0, topImageBuffer.Width, topImageBuffer.Height, topImageBuffer.Canvas.Handle, 0, 0, SRCCOPY)
end;

procedure TMainForm.FormPaint(Sender: TObject);
begin
	doPaintForm(clientWidth, clientHeight)
end;
		{
procedure TMainForm.WinPlayListBeforePaint(Sender: TBaseVirtualTree;
	Canvas: TCanvas);
begin
				//Ellers flipper den i updaten (winplaylist.gettext)
        sender.Tag := SendMessage(hwnd_winamp, WM_WA_IPC, 0, IPC_GETLISTPOS)
end;

procedure TMainForm.WinPlayListAfterPaint(Sender: TBaseVirtualTree;
  Canvas: TCanvas);
begin
				SendMessage(hwnd_winamp, WM_WA_IPC, sender.tag, IPC_GETPLAYLISTFILE);
end;  }

procedure TMainForm.playlistboxGetText(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
  var Text: WideString);
begin
        text := PPlBoxData(PlayListBox.GetNodeData(Node))^.text
end;

procedure TMainForm.plconGetPopupMenu(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; const P: TPoint;
  var AskParent: Boolean; var PopupMenu: TPopupMenu);
begin
				if (playlistbox.SelectedCount = 0) or (node=nil) then exit;
				if PPlBoxData(PlayListBox.GetNodeData(playlistbox.getfirstselected))^.TopList then PopUpMenu := TopListPop else PopUpMenu := qlsongspop
end;

procedure TMainForm.treeplbarMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
        SetCapture((sender as Tpanel).Handle);
        Capturing := true;
        MouseDownSpot.X := x;
        MouseDownSpot.Y := Y;
        Resizing := true;
        if (sender = treeplbar) and (MinimizeQ2.Caption = arrowup) and (Button = mbRight) then
                begin
                        plconbar.top := plconbar.top - 1;
                        playlistbox.Height := playlistbox.height -1;
                        MinimizeQ2.caption := arrowdown
                end
end;

procedure TMainForm.treeplbarMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var     top,Wheight:integer;
        DragPlcon : boolean;
begin
        if Capturing then
                begin
                        top := treeplbar.Top - (MouseDownSpot.y - y);

                        //if top > plconbar.top then exit;
                        if top+treeplbar.height > treepanel.height then exit;

                        Wheight := plconbar.Top - top - treeplbar.Height;

												Wheight := NearestDiv(Wheight, playlistbox.DefaultNodeHeight);

                        top := plconbar.top - Wheight - treeplbar.Height;

                        if top <> treeplbar.Top then
                                begin
                                        DragPLcon := Wheight > playlistbox.GetTreeRect.Bottom; 
                                        if top <= panel1.height then top := panel1.height;
                                        if top + treeplbar.height >= plconbar.top then
                                                begin
                                                        if MinimizeQ2.caption = arrowup then //plcon is hidden
                                                                top := treepanel.height - treeplbar.Height else
                                                                begin
                                                                        plconbar.Top := top + treeplbar.height;
                                                                        UpdateSizesTreePanel(plconbar);
                                                                        if MinimizeQ2.caption = arrowup then top := treepanel.height - treeplbar.Height
                                                                end;
                                                        MinimizeQ1.caption := arrowup
                                                end else MinimizeQ1.caption := arrowdown;
                                        if DragPLcon then
                                                begin
                                                        plconbar.Top := top + treeplbar.height + playlistbox.DefaultNodeHeight*(1+playlistbox.RootNodeCount);
                                                        UpdateSizesTreePanel(plconbar)
                                                end;
                                        treeplbar.Top := top;
                                        UpdateSizesTreePanel(treeplbar)
                                end
                end
end;

procedure TMainForm.treeplbarMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var     top:Integer;
begin
        if Capturing then
                begin
                        ReleaseCapture;
                        Capturing := false;
                        top := treeplbar.Top - (MouseDownSpot.y - y);
                        if top + treeplbar.height >= treepanel.height then
                                begin
                                        top := treepanel.height - treeplbar.height;
                                        MinimizeQ1.caption := arrowup
                                end else MinimizeQ1.caption := arrowdown;
                        if top <= panel1.height then top := panel1.height;
                        treeplbar.Top := top;
                        UpdateSizesTreePanel(treeplbar);
                        if treeplbar.top + treeplbar.height >= plconbar.top then
                                begin
                                        treeplbar.top := treepanel.height - treeplbar.height;
                                        UpdateSizesTreePanel(treeplbar)
                                end
                end
end;

procedure TMainForm.plconbarMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var     top, Wheight:Integer;
begin
     if Capturing then
     begin
          top := plconbar.Top - (MouseDownSpot.y - y);

          Wheight := treepanel.height - top - plconbar.Height;

          Wheight := NearestDiv(Wheight, plcon.DefaultNodeHeight);

          top := treepanel.Height - Wheight - plconbar.height;

          if top <> plconbar.top then
          begin
               if top <= treeplbar.Top + treeplbar.height then top := treeplbar.height + treeplbar.top;
               if top + plconbar.height > treepanel.height - plcon.DefaultNodeHeight then top := treepanel.height - plconbar.height;
               plconbar.Top := top;
               UpdateSizesTreePanel(plconbar)
          end
     end
end;

procedure TMainForm.plconbarMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
        playlistbox.tag := 0;
        if Capturing then
                begin
                        ReleaseCapture;
                        Capturing := false;
                end
end;

procedure TMainForm.tabelDrawHeader(Sender: TVTHeader; Canvas: TCanvas;
  Column: TVirtualTreeColumn; R: TRect; Hover, Pressed: Boolean);
var
	re:Trect;
begin
	re := r;
	re.top := -1;
	Canvas.Brush.Color := clRed;
	Canvas.FillRect(re)
end;

procedure TMainForm.WPbarMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var     Wheight, top:Integer;
begin
	FixRatingPainting(tabel);

  if Capturing then
  begin
    top := WPbar.Top - (MouseDownSpot.y - y);
    if top >= tabelpanellow.height - WPbar.height - winplaylist.DefaultNodeHeight then top := tabelpanellow.height - WPbar.height;
    if top <= filterbar.height then top := filterbar.height;
    Wheight := tabelpanellow.height - top - WPbar.height;
    Wheight := NearestDiv(Wheight, WinPlaylist.DefaultNodeHeight);
    top := tabelpanellow.Height - Wheight - Wpbar.height;
    if top <> WPbar.top then
    begin
      WPbar.Top := top;
      UpdateSizesTreePanel(WPbar)
    end
  end
end;

procedure TMainForm.WPbarMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if Capturing then
  begin
    ReleaseCapture;
    Capturing := false;

    tree.Visible := true;
    playlistbox.Visible := true;
    plcon.Visible := true;
    tabel.Visible := true;
    winplaylist.Visible := true;
    Resizing := false;
{    tabelscrollH.Visible := true;
    tabelScrollV.Visible := true;
    treescrollV.Visible := true;
    treeScrollH.Visible := true;
    WinplayScrollV.visible := true;
    WinplayScrollH.visible := true; }
    UpdateTreeBounds(tabel);
    UpdateTreeBounds(winplaylist);
    UpdateTreeBounds(tree)
  end
end;


procedure TMainForm.tabelpanellowCanResize(Sender: TObject;
  var NewWidth, NewHeight: Integer; var Resize: Boolean);
var     percent : double;
begin
	if NewHeight <> tabelpanellow.Height then
	begin
		if MinimizeWinplay.caption = arrowdown then
		begin
			if WPbar.Top <> 0 then
			begin
				percent := WPbar.top / max(1,(tabelpanellow.Height - WPbar.Height));
				WPbar.Top := round((newHeight - WPbar.Height) * percent) end
			end else
			begin
				if WPbar.tag <> 0 then
				begin
					percent := WPbar.tag / max(1,(tabelpanellow.Height - WPbar.Height));
					WPbar.tag := round(newHeight * percent)
				end
			end
		end;
		if NewWidth <> tabelpanellow.Width then
		begin
			wpanelheight := newHeight;
			WPbar.Width := newwidth;
			UpdateTreeBounds(tabel);
			UpdateTreeBounds(winplaylist)
		end
end;

{procedure TMainForm.QuitTimerTimer(Sender: TObject);
begin
     QuitTimer.enabled := false;
     if quitting then exit;
     ForceQuit := true;
     Quit
end;  }

procedure TMainForm.playlistboxDragAllowed(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
begin
	Allowed := not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked)
end;

function SortToplist(Item1, Item2: Pointer): Integer;
begin
     result := CompWord(Prec(Item1).playCount, Prec(Item2).playCount)
end;

procedure TMainForm.playlistboxChange(Sender: TBaseVirtualTree;
  Node: PVirtualNode);
var
        s, d, fn:string;
        f:textfile;
        i,u:integer;
        PR : pPLconRec;
        sortlist:Tlist;
        aNode : pVirtualNode;
        p:pointer;
begin
  if (node = nil) or (not playlistbox.selected[Node]) then exit;
  if PPlBoxData(PlayListBox.GetNodeData(Node))^.Toplist then
  begin
    sortlist := Tlist.create;
    sortList.Capacity := reclist.count;
    for i:=0 to reclist.count-1 do sortList.Add(reclist.List^[i]);
	    SortList.Sort(SortToplist);
    plcon.beginupdate;
    plcon.Clear;
    for i:=sortlist.count-1 downto Max(sortlist.count - pref.topnr.value, 0) do
    	if (i < sortlist.count) and (Prec(sortlist.items[i]).playcount>0) then plconAdd(sortlist.items[i]);
    sortlist.free;
    plcon.endupdate
  end else
  begin
  if not getFileAccess(settingsdir + '-quicklist\' + PPlBoxData(PlayListBox.GetNodeData(Node))^.text + '.m3u', true, false) then
    exit;
  assignfile(f,settingsdir + '-quicklist\' + PPlBoxData(PlayListBox.GetNodeData(Node))^.text + '.m3u');
  Filemode := 0;
  reset(f);
  plcon.beginupdate;
  plcon.Clear;
  while not eof(f) do
  begin
      readln(f,s);
      Q_TrimInPlace(s);
      if Q_SameTextL(s, '#EXTINF', 7) then
      begin
           aNode := plcon.AddChild(nil);
           pr := plCON.GetNodeData(aNode);
           fillChar(PR^, Sizeof(PR^), #0);
           readln(f, fn);
           Q_TrimInPlace(fn);
           GetAbsoluteFilename(settingsdir + '-quicklist\', fn);
           p := findInReclist(fn);
           if assigned(p) then
                pr.Rec := p
           else
           begin
                pr.Text := Q_CopyFrom(s, Q_StrScan(s, ',')+1);
                u := Q_StrScan(s, ':')+1;
                d := Q_CopyRange(s, u, Q_StrScan(s, ',', u)-1);
                if Q_IsInteger(d) and not Q_SameStr(d, '-1') then
                  pr.Seconds := strtoint(d)
                else
                  pr.seconds := 0;
                pr.Filename := fn
           end
      end
      else
      if (length(s)>0) and (s[1] <> '#') then
      begin
           aNode := plcon.AddChild(nil);
           pr := plcon.GetNodeData(aNode);
           fillChar(PR^, sizeOf(PR^), #0);
           GetAbsoluteFilename(settingsdir + '-quicklist\', s);
           p := findInReclist(s);
           if assigned(p) then
              pr.Rec := p
              else
           begin
                pr.text := getFilename(s, false);
                pr.filename := s
           end
      end
  end;
  closefile(f);
  plcon.endupdate
  end
end;

procedure TMainForm.tabelScroll(Sender: TBaseVirtualTree; DeltaX,
  DeltaY: Integer);
begin
  if Pref.Scrollbars.itemindex = 2 then
  begin
    if DeltaY <> 0 then UpdateVScroll(TabelScrollV, tabel);
    if DeltaX <> 0 then
    begin
      UpdateHScroll(TabelScrollH, tabel);
      tabel.UpdateHorizontalScrollBar (false);
    end
  end
end;

Procedure TMainForm.UpdateVScroll(aScroll:TWinampScrollVert; aTree:TVirtualStringTree);
begin
	if (not Pref.Scrollbars.itemindex = 2) and (aScroll.Visible) then
  	exit;

	aScroll.SMax := aTree.gettreerect.Bottom;
  aScroll.PageSize := aTree.clientheight;
	aScroll.Position := -(aTree.OffsetY)
end;

Procedure TMainForm.UpdateHScroll(aScroll:TWinampScrollVert; aTree:TVirtualStringTree);
begin
  if (not Pref.Scrollbars.itemindex = 2) and (aScroll.Visible) then exit;
  //if aScroll.Width <> aTree.Width then aScroll.Width := aTree.Width; {ellers repainter den mske}
  aScroll.SMax := aTree.gettreerect.Right;
  aScroll.PageSize := aTree.clientwidth;
  aScroll.Position := -(aTree.OffsetX)
end;

procedure TMainForm.TabelScrollVScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
				case SBcode of
								SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN :     tabel.perform(WM_VSCROLL, SBcode, 0);
                SB_THUMBPOSITION : tabel.OffsetY := -Param
        end
end;

procedure TMainForm.tabelResize(Sender: TObject);
begin
        if Pref.Scrollbars.itemindex = 2 then
                begin
                        UpdateVScroll(TabelScrollV, tabel);
                        UpdateHScroll(TabelScrollH, tabel)
                end
end;

procedure TMainForm.TreeScrollVScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
        case SBcode of
                SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN :  tree.perform(WM_VSCROLL, SBcode, 0);
                SB_THUMBPOSITION : tree.OffsetY := -Param
        end
end;

procedure TMainForm.treeScroll(Sender: TBaseVirtualTree; DeltaX,
  DeltaY: Integer);
begin
  if Pref.Scrollbars.itemindex = 2 then
  begin
     {if DeltaX <> 0 then UpdateHScroll(TreeScrollH, tree);
     if DeltaY <> 0 then UpdateVScroll(TreeScrollV, tree) }
     if (DeltaY<>0) or (DeltaX<>0) then UpdateTreeBounds(Sender)
  end
end;

procedure TMainForm.WinPlayScrollVScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
  case SBcode of
    SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN :     winplaylist.perform(WM_VSCROLL, SBcode, 0);
    SB_THUMBPOSITION : winplaylist.OffsetY := -Param
  end
end;

procedure TMainForm.WinPlayListScroll(Sender: TBaseVirtualTree; DeltaX,
  DeltaY: Integer);
begin
  if Pref.Scrollbars.itemindex = 2 then
  begin
    if DeltaY <> 0 then UpdateVScroll(WinPlayScrollV, winplaylist);
    if DeltaX <> 0 then
    begin
      UpdateHScroll(WinPlayScrollH, winplaylist);
      Winplaylist.UpdateHorizontalScrollBar(false)
    end
  end
end;

procedure TMainForm.TabelBarMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var     left:Integer;
begin
	FixRatingPainting(winplaylist);
  FixRatingPainting(tabel);

  if Capturing then
  begin
    left := TabelBar.Left - (MouseDownSpot.x - x);
    //venstre margin:
    if left <= 5 then
    	left := 0;
    //hjre margin:
    if left >= tabelpanel.clientwidth - tabelbar.Width then
    	left := tabelpanel.clientwidth - tabelbar.Width
    else
    	left := NearestDiv(left, 14);

    if left <> TabelBar.Left then
    begin
      tabel.Visible := false;
      //winplaylist.Visible := false;
      tree.Visible := false;
      playlistbox.Visible := false;
      plcon.Visible := false;

      tabelscrollH.Visible := false;
      tabelScrollV.Visible := false;
      treescrollV.Visible := false;
      winplayScrollV.Visible := false;
      WinplayScrollH.visible := false;

      TabelBar.Left := Left;
      UpdateSizesTreePanel(TabelBar)
    end
  end;
end;

procedure TMainForm.OnTreeSelectionChanged;
begin
  if pref.enablereset.checked and (not autoresettabel.enabled) and (trim(f0.text) <> '') then
  begin
    dontfilter:=true;
    f0.Text := ''
  end;
  TreeFilter;
  autoresettabel.enabled:=false;
  autoresettabel.enabled:=true;
  autoresettree.enabled:=false;
  autoresettree.enabled:=true;
end;

procedure TMainForm.treeChange(Sender: TBaseVirtualTree; Node: PVirtualNode);
begin
  timTreeSelectionChanged.Enabled := false;
  timTreeSelectionChanged.Enabled := true;
end;

procedure TMainForm.filterbarResize(Sender: TObject);
var
	can : Tbitmap;
  f0width, groupLabelLeft, MainListCountLabelLeft: integer;
begin
	can := TBitmap.create;
	can.canvas.Font := filterbar.font;
	searchlabel.Left := can.canvas.TextWidth(filterbar.caption)+15;
  can.free;

  f0width := filterbar.clientwidth - (searchlabel.left + searchlabel.width+5);
  groupLabelLeft := filterbar.ClientWidth - grouplabel.Width;
  MainListCountLabelLeft := filterbar.ClientWidth - lblMainListCount.Width - 5;

  if pref.cbShowTotalDurationLabel.Checked then
  begin
  	dec(f0Width, lblMainListCount.Width + 5);
    inc(groupLabelLeft, lblMainListCount.Width);
    lblMainListCount.Left := MainListCountLabelLeft;
  end;

	if pref.ShowGroupsAtFilter.checked then
  begin
  	dec(f0width, grouplabel.width+5);
    dec(MainListCountLabelLeft, groupLabel.Width + 4);
    Grouplabel.Left := groupLabelLeft;
  end;

  F0.SetBounds(searchlabel.left + searchlabel.width + 5, 1, f0width, filterbar.clientheight-1);

  lblMainListCount.Left := MainListCountLabelLeft;
	GroupLabel.Visible := pref.ShowGroupsAtFilter.Checked;
  lblMainListCount.Visible := pref.cbShowTotalDurationLabel.Checked;
end;

procedure TMainForm.TabelBarMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var     left:Integer;
begin
        if Capturing then
                begin
                        left := TabelBar.Left - (MouseDownSpot.x - x);
                        //if left >= tabelpanellow.height - WPbar.height then top := tabelpanellow.height - WPbar.height;
                        if left <= 5 then left := 0;
                        left := NearestDiv(left, 14);
                        if left <> TabelBar.Left then TabelBar.Left := Left;
                        UpdateSizesTreePanel(TAbelBar);
                        ReleaseCapture;
                        Capturing := false;
                end
end;

procedure TMainForm.treepanelCanResize(Sender: TObject; var NewWidth,
  NewHeight: Integer; var Resize: Boolean);
begin
				treeplbar.Width := newwidth;
				plconbar.Width := newwidth;

				if (MinimizeQ1.caption = arrowup) and (treeplbar.tag > 0) then treeplbar.tag := treeplbar.tag - (treepanel.ClientHeight - NewHeight);
        if (MinimizeQ2.caption = arrowup) and (plconbar.tag > 0) then plconbar.tag := plconbar.tag - (treepanel.ClientHeight - NewHeight);

        UpdateTreeBounds(tree);
        UpdateTreeBounds(playlistbox);
        UpdateTreeBounds(plcon)
end;

procedure TMainForm.TabelScrollHScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
  case SBcode of
    SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN :     tabel.perform(WM_HSCROLL, SBcode, 0);
    SB_THUMBPOSITION : tabel.OffsetX := -Param;
  end;
  // moved to tabel.OnScroll
  // tabel.UpdateHorizontalScrollBar(false);
end;

procedure TMainForm.tabelHeaderMouseUp(Sender: TVTHeader;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	if Pref.Scrollbars.itemindex = 2 then
  	UpdateTreeBounds(tabel)
end;

procedure TMainForm.PlaylistboxScrollVScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
  case SBcode of
    SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN :     playlistbox.perform(WM_VSCROLL, SBcode, 0);
    SB_THUMBPOSITION : playlistbox.OffsetY := -Param
  end
end;

procedure TMainForm.ResizeWinplaylistColumns(adjustEnqueueNoColumn: boolean=true);
var
	i, w:Integer;
begin
	if not assigned(Pref) or (winplaylist.Header.Columns.Count = 0) or Resizing then
  	exit;

  if not pref.WinplayShowColumns.Checked then
  begin
  	if adjustEnqueueNoColumn then
    	AdjustWinplaylistEnqueueNoColumnWidth(false);

		//Resizer length columns
    if coVisible in winplaylist.Header.Columns[0].Options then
    	w := winplaylist.Header.Columns[0].Width
    else
    	w:=0;

		i := winplaylist.GetMaxColumnWidth(2);

		if winplaylist.Width - 20 - 40 > 2 then
			winplaylist.header.Columns[1].width := winplaylist.clientWidth - i - w;

		winplaylist.header.Columns[2].width := i;
  end
end;

Procedure TMainForm.UpdateTreeBounds(aTree:TBaseVirtualTree);
var     ShowHoriz, ShowVert:Boolean;
				Fheight, FWidth, Aheight, Awidth : Integer;
begin
  // De 13 der trkkes fra i resizerne er hjden p winplaylistene
  if pref.Scrollbars.itemindex = 2 then
  begin
    if aTree = tabel then
    begin
      FWidth := WPbar.clientwidth;
      FHeight := wpbar.top - filterbar.height;
      Awidth := tabel.GetVirtualTreeRect.Right - tabel.GetVirtualTreeRect.left;
      Aheight := tabel.GetVirtualTreeRect.Bottom;

      ShowHoriz := Awidth > FWidth;
      if ShowHoriz then Fheight := Fheight-13;

      ShowVert := Aheight > (Fheight - tabel.Header.Height);
      if ShowVert then Fwidth := Fwidth-13;

      if not ShowHoriz then
      begin
        ShowHoriz := Awidth > FWidth;
        if ShowHoriz then Fheight := Fheight-13
      end;

      //resize:
      tabel.SetBounds(0, filterbar.Height, FWidth, FHeight);
      if ShowVert then
      begin
        tabelscrollV.SetBounds(FWidth, filterbar.height, 13, FHeight);
        if not capturing then
        	tabelscrollV.visible := true;
        UpdateVScroll(tabelScrollV, tabel)
      end else
      begin
        tabelscrollV.Visible := false;
        tabel.OffsetY := 0
      end;

      if ShowHoriz then
      begin
        tabelscrollH.SetBounds(0, WPbar.top-13, WPbar.ClientWidth, 13);
        if not capturing then tabelscrollH.visible := true;
        UpdateHScroll(TabelScrollH, tabel);
        WPbar.PaintTop := false;
        WPbar.Repaint
      end else
      begin
        tabelscrollH.Visible := false;
        tabel.OffsetX := 0;
        tabel.UpdateHorizontalScrollBar(false);
        WPbar.PaintTop := true;
        WPbar.repaint
      end
      end else

      if aTree = Tree then
      begin
        FWidth := panel1.clientwidth;
        FHeight := treepanellow.height-panel1.height;
        Awidth := tree.GetVirtualTreeRect.Right - tree.GetVirtualTreeRect.left;
        Aheight := Tree.GetVirtualTreeRect.Bottom - Tree.GetVirtualTreeRect.top;

        ShowHoriz := Awidth > FWidth;
        if ShowHoriz then Fheight := Fheight-13;
        ShowVert := Aheight > Fheight;
        if ShowVert then Fwidth := Fwidth-13;

        tree.SetBounds(0, panel1.ClientHeight, FWidth, FHeight);

        if ShowVert then
        begin
          TreeScrollV.SetBounds(FWidth, panel1.ClientHeight, 13, FHeight);
          if not capturing then TreeScrollV.visible := true;
          UpdateVScroll(TreeScrollV, tree)
        end else
        begin
          TreeScrollV.Visible := false;
          tree.OffsetY := 0
        end;

        if ShowHoriz then
        begin
          TreeScrollH.SetBounds(0, treepanellow.Height-13, treepanellow.width, 13);
          if not capturing then TreeScrollH.visible := true;
          UpdateHScroll(TreeScrollH, tree);
          treeplbar.PaintTop := false;
          treeplbar.Repaint
        end else
        begin
          TreeScrollH.Visible := false;
          tree.OffsetX := 0;
          tree.UpdateHorizontalScrollBar(false);
          treeplbar.PaintTop := true;
          treeplbar.Repaint
        end
      end else


      if aTree = WinPlayList then
      begin
        FWidth := WPbar.clientwidth;
        FHeight := tabelpanellow.ClientHeight -  wpbar.boundsrect.Bottom - WPbarLow.Height;
        Aheight := winplaylist.GetVirtualTreeRect.Bottom - winplaylist.GetVirtualTreeRect.top;
        Awidth := winplaylist.GetVirtualTreeRect.Right - winplaylist.GetVirtualTreeRect.left;

        ShowHoriz := (Awidth > FWidth) and pref.WinplayShowColumns.Checked;
        if ShowHoriz then Fheight := Fheight-13;

        ShowVert := Aheight > Fheight;
        if ShowVert then Fwidth := Fwidth-13;

        if not ShowHoriz and pref.WinplayShowColumns.Checked then
      	begin
	        ShowHoriz := Awidth > FWidth;
	        if ShowHoriz then Fheight := Fheight-13
	      end;

        //resize:
        if hoVisible in Winplaylist.Header.Options then
	        Winplaylist.BackgroundOffsetY := wpbar.boundsrect.Bottom - tabel.Top + Winplaylist.Header.Height + 1
        else
        	Winplaylist.BackgroundOffsetY := wpbar.boundsrect.Bottom - tabel.Top + 1;

        winplaylist.SetBounds(0, wpbar.boundsrect.Bottom, FWidth, FHeight);

        if ShowVert then
        begin
	        WinPlayScrollV.SetBounds(FWidth, wpbar.boundsrect.Bottom, 13, FHeight);
	        if not capturing then
		        WinPlayScrollV.visible := true;
	        UpdateVScroll(WinPlayScrollV, winplaylist)
        end else
        begin
					WinPlayScrollV.Visible := false;
	        Winplaylist.OffsetY := 0
        end;

        if ShowHoriz then
        begin
          WinPlayScrollH.SetBounds(0, Winplaylist.Top + Winplaylist.Height, WPbar.ClientWidth, 13);
          if not capturing then WinPlayScrollH.visible := true;
          UpdateHScroll(WinPlayScrollH, winplaylist);
          WPbarLow.PaintTop := false;
          WPbarLow.Repaint
        end else
        begin
          WinPlayScrollH.Visible := false;
          winplaylist.OffsetX := 0;
          winplaylist.UpdateHorizontalScrollBar(false);
          WPbarLow.PaintTop := true;
          WPbarLow.repaint
        end;

        ResizeWinplaylistColumns;

        WPbarLow.SetBounds(0, tabelpanellow.ClientHeight - WPbarLow.Height, WPBar.Width, WPbarLow.Height)
      end else

      if aTree = Playlistbox then
      begin
      FWidth := tabelbar.left;
      FHeight := plconbar.top -  treeplbar.BoundsRect.Bottom;
      Aheight := Playlistbox.GetVirtualTreeRect.Bottom - Playlistbox.GetVirtualTreeRect.top;

      ShowVert := Aheight > Fheight;
      if ShowVert then Fwidth := Fwidth-13;

      PlaylistBox.BackgroundOffsetY := treeplbar.BoundsRect.Bottom - treePlBar.Height;
      playlistbox.SetBounds(0, treeplbar.BoundsRect.Bottom, FWidth, FHeight);

      if ShowVert then
      begin
        PlaylistboxScrollV.SetBounds(FWidth, treeplbar.BoundsRect.Bottom, 13, FHeight);
        PlaylistboxScrollV.visible := true;
        UpdateVScroll(PlaylistboxScrollV, playlistbox)
      end else
      begin
        PlaylistboxScrollV.Visible := false;
        Playlistbox.OffsetY := 0
      end
      end else

      if aTree = plcon then
      begin
      FWidth := tabelbar.left;
      FHeight := treepanel.height - plconbar.BoundsRect.Bottom;
      Aheight := plcon.GetVirtualTreeRect.Bottom - plcon.GetVirtualTreeRect.top;

      ShowVert := Aheight > Fheight;
      if ShowVert then Fwidth := Fwidth-13;

      plcon.BackgroundOffsetY := plconbar.boundsrect.bottom - plConBar.Height;
      plcon.SetBounds(0, plconbar.boundsrect.bottom, Fwidth, Fheight);

      if ShowVert then
      begin
        plConScrollV.SetBounds(FWidth, plconbar.BoundsRect.Bottom, 13, FHeight);
        plConScrollV.visible := true;
        UpdateVScroll(plConScrollV, plcon)
      end else
      begin
        plConScrollV.Visible := false;
        plcon.OffsetY := 0
      end
      end
      end
      else
  begin
    WPbar.PaintTop := true;
    TreeScrollV.Visible := false;
    WinPlayScrollV.Visible := false;
    WinPlayScrollH.Visible := false;
    TabelScrollV.Visible := false;
    TabelScrollH.Visible := false;
    TreeScrollV.Visible := false;
    TreeScrollH.Visible := false;
    PlaylistboxScrollV.Visible := false;
    if aTree = tabel then
            tabel.SetBounds(0, filterbar.Height, tabelpanellow.clientwidth, wpbar.top - filterbar.height);
    if aTree = WinPlayList then
    begin
      winplaylist.SetBounds(0, wpbar.boundsrect.Bottom, tabelpanellow.clientwidth, tabelpanellow.ClientHeight -  wpbar.boundsrect.Bottom - WPbarLow.Height);
      WPbarLow.SetBounds(0, Winplaylist.BoundsRect.Bottom, WPBar.Width, WPbarLow.Height);
      ResizeWinplaylistColumns
    end;
    if aTree = playlistbox then
      playlistbox.SetBounds(0, treeplbar.BoundsRect.Bottom, tabelbar.left, plconbar.top -  treeplbar.BoundsRect.Bottom);
    if aTree = plcon then
            plcon.SetBounds(0, plconbar.boundsrect.bottom, tabelbar.left, treepanel.height - plconbar.BoundsRect.Bottom);
    if aTree = Tree then
            tree.SetBounds(0, panel1.ClientHeight, panel1.clientwidth, treepanellow.height-panel1.height)
  end
end;

procedure TMainForm.plconScrollVScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
	case SBcode of
		SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN :     plcon.perform(WM_VSCROLL, SBcode, 0);
		SB_THUMBPOSITION : plcon.OffsetY := -Param
	end
end;

procedure TMainForm.PLCONlabelMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
	PopupMenu : TPopupMenu;
begin
	if Button = mbRight then
		treeplbarMouseDown(plConBar, Button, Shift, X, Y)
	else
	begin
		if (playlistbox.SelectedCount = 0) then exit;
		if PPlBoxData(PlayListBox.GetNodeData(playlistbox.getfirstselected))^.TopList then
			PopUpMenu := TopListPop
		else PopUpMenu := qlsongspop;

		PopupMenu.Popup(plConBar.clienttoscreen(point(0,plConBar.height)).x,plConBar.clienttoscreen(point(0,plConBar.height)).y)
	end
end;

procedure TMainForm.PLCONlabelMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
	if ssRight in Shift then
		plconbarMouseMove(plConBar, shift, x, y)
end;

procedure TMainForm.PLCONlabelMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	if Button = mbRight then
		plconbarMouseUp(plconbar, button, shift, x, y)
end;

procedure TMainForm.playlistboxDragOver(Sender: TBaseVirtualTree;
  Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint;
  Mode: TDropMode; var Effect: Integer; var Accept: Boolean);
var     aNode : PVirtualNode;
        i:integer;
begin
        aNode := playlistbox.GetNodeAt(pt.x,pt.y,true,i);
        accept := (not PPlBoxData(playlistbox.getnodedata(aNode))^.toplist) and (Mode = dmOnNode)
end;

procedure TMainForm.playlistboxDragDrop(Sender: TBaseVirtualTree;
  Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
  Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode);
var
        TargetNode : PVirtualNode;
        i:integer;
        recs:TList;
        QF:TExtfile;
        PW:PplstRec;
begin
        UpdateSearchBools;
        if (Mode <> dmOnNode) or (source = playlistbox) then exit;
        TargetNode := sender.DropTargetNode;
        if (TargetNode = nil) or PPlBoxData(playlistbox.getnodedata(TargetNode))^.toplist then exit;

        recs := nil;
        if source is TBaseVirtualTree then
        begin
             if (source = tabel) or (source = plcon) or (source = tree) or (source = winplaylist)  then
             begin
                  recs := TList.create;
                  getDragRecs(TBaseVirtualTree(source), recs)
             end
        end
        else //FILES
        begin
             recs := TList.create;
             GetDropFiles(Sender, Source, DataObject, Formats, Shift, Pt, Effect, Mode, recs)
        end;

        if assigned(recs) then
        begin
             assignfile(QF, settingsdir + '-quicklist\' + PPlBoxData(playlistbox.getnodedata(TargetNode))^.text + '.m3u');
             Filemode := 2;
             append(QF);
             if FileSize(QF) = 0 then writeln(QF, '#EXTM3U');

             for i:=0 to recs.count-1 do
             begin
                  pw := recs.items[i];
                  if assigned(pw.Rec) then
                  begin
                       writeln(qf, GetFtextP(pw.Rec, FextStr));
                       writeln(qf, GetFtextP(pw.Rec, Ffilename))
                  end
                  else
                  begin
                       writeln(QF ,'#EXTINF' + ':' + inttostr(pw.Seconds) + ',' + pw.text);
                       writeln(QF , pw.filename)
                  end;
                  dispose(pw)
             end;
             recs.free;
             closeFile(QF);
             if playlistbox.selected[TargetNode] then playlistboxChange(sender, targetnode)
        end
end;

Procedure TMainForm.CheckAllPositions;
{Checker at ingen barer er udenfor vinduet}
begin
        //TabelBar:
        if tabelbar.Left < 0 then tabelbar.left := 0;
				if tabelbar.boundsrect.right > tabelpanel.ClientWidth then tabelbar.Left := tabelpanel.ClientWidth - tabelbar.Width;

        //WPbar  (WinPlaylistBar)
        if WPbar.top < 100 then Wpbar.top := 100;
        if WPbar.BoundsRect.Bottom > tabelpanel.ClientHeight then wpbar.top := tabelpanel.clientHeight - wpbar.Height;

        //PLcon bar
        if plconbar.Top < treeplbar.boundsrect.Bottom then plconbar.top := treeplbar.boundsrect.Bottom;
        if plconbar.boundsrect.Bottom > treepanel.height then
                begin
                        plconbar.top := treepanel.height - plconbar.height;
                        MinimizeQ2.caption := arrowup
                end;

        //PlaylistBox Bar
        if treeplbar.Top < panel1.height then
                begin
                        treeplbar.top := panel1.height;
                        MinimizeQ1.caption := arrowdown
                end;
        if treeplbar.BoundsRect.Bottom >= plconbar.Top then
                if MinimizeQ2.caption = arrowup then
                        begin
                                treeplbar.top := treepanel.height - treeplbar.Height;
                                MinimizeQ1.caption := arrowup
                        end else  treeplbar.top := plconbar.top - treeplbar.Height;
end;

procedure TMainForm.TreeScrollHScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
        case SBcode of
                SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN :     tree.perform(WM_HSCROLL, SBcode, 0);
                SB_THUMBPOSITION : tree.OffsetX := -Param;
        end;
        tree.UpdateHorizontalScrollBar(false);
end;

procedure TMainForm.tabelDragOver(Sender: TBaseVirtualTree;
  Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint;
  Mode: TDropMode; var Effect: Integer; var Accept: Boolean);
begin
	Accept := FOnlyPL and not (PartyMode1.Checked and pref.DisableEditPlaylist.Checked)
end;

Procedure TMainForm.SavePLfromTabel;
var
  aNode, plNode : PVirtualNode;
  f:textfile;
  PL: PplRec;
  TR: PtreeRec;
  PC: PplCacheRec;
  index:integer;
  p:pointer;
  playlistPath: String;
  useRelativePaths: Boolean;
begin
	useRelativePaths := pref.RelativePaths.Checked;
  if tree.SelectedCount <> 1 then exit;
  plNode := tree.GetFirstSelected;
  TR := tree.getNodeData(plNode);
  if (TR.Kind <> TreeKind_playlist) or not assigned(TR.PlRecRef) then exit;
  PL := TR.PlRecRef;
  PC := PL.CacheRef;
  if getfileAccess(PL.filename, true, true, true) then
  begin
  	playlistPath := GetFilePath(PL.Filename);
    //cleaner cache
    if not assigned(PC) then
    begin
      new(PC);
      fillChar(PC^, sizeOf(PC^), #0);
      PL.CacheRef := PC
    end;
    TR.Count := 0;
    TR.TotalTime := 0;
    fPlaylist.clear;
    setLength(PC.cache, tabel.VisibleCount);
    PC.Complete := true;
    Assignfile(f, PL.Filename);
    Filemode := 1;
    rewrite(f);
    writeln(f,'#EXTM3U');
    index := 0;
    aNode := tabel.GetFirstVisible;
    while aNode <> nil do
    begin
      p := getRec(aNode);
      PC.Cache[index] := p;
      inc(index);
      fPlaylist.Add(p);
      writeln(f, getFtextP(p, FextStr));
      if useRelativePaths then
      	writeln(f, GetRelativePath(playlistPath, GetFTextP(p, FFilePath)) + GetFTextP(p, Ffname))
      else
	      writeln(f, getFtextP(p, FFilename));
      aNode := tabel.getnextvisible(aNode)
    end;
    closefile(f)
  end
  else
  	showmessagex(GetText(TXT_CouldNotOpenPLforWriting))
end;

procedure TMainForm.tabelDragDrop(Sender: TBaseVirtualTree;
  Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
  Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode);
var     Attachmode: TVTNodeAttachMode;
        TargetNode, aNode : PVirtualNode;
        recs : Tlist;
        PW : PplstRec;
        i:integer;
begin
		if PartyMode1.Checked and pref.DisableEditPlaylist.Checked then
		exit;
		
				if not FOnlyPL then exit;
				case Mode of
								dmAbove:
												AttachMode := amInsertBefore;
								dmOnNode:
                        AttachMode := amInsertAfter;
                dmBelow:
                        AttachMode := amInsertAfter;
                else
                        AttachMode := amNowhere;
        end;
        TargetNode := sender.DropTargetNode;
        recs := nil;

        if assigned(source) and (Source is TBaseVirtualTree) then
        begin
             if (source = winplaylist) or (source = plcon) or (source = playlistbox) then
             begin
                  recs := TList.create;
                  getDragRecs(TBaseVirtualTree(source), recs)
             end
             else
             if source = tabel then
             begin
                  Effect := DROPEFFECT_MOVE;
                  tabel.ProcessDrop(DataObject, TargetNode, Effect, AttachMode);
                  SavePLfromTabel
             end
        end
        else //FILES
        begin
             recs := TList.create;
             GetDropFiles(Sender, Source, DataObject, Formats, Shift, Pt, Effect, Mode, recs)
        end;

        if assigned(recs) then
        begin
             tabel.OnInitNode := nil;
             tabel.beginupdate;
             for i:=0 to recs.count-1 do
             begin
                  PW := recs.items[i];
                  if assigned(PW.Rec) then
                  begin
                       if Attachmode = amNowhere then aNode := tabel.AddChild(nil) else aNode := tabel.InsertNode(TargetNode, Attachmode);
                       if Attachmode =  amInsertAfter then TargetNode := aNode;
                       setRec(aNode, PW.Rec)
                  end;
                  dispose(PW)
             end;
             SavePLfromTabel;
             tabel.OnInitNode := tabelInitNode;
             tabel.endupdate;
             
             recs.free
				end;
				if pref.AutoResizeColumnHeaders.Checked then
					AutoResizeAllColumnsToFit
end;

procedure TMainForm.playlistboxCompareNodes(Sender: TBaseVirtualTree;
  Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
begin
        if PPlBoxData(PlayListBox.GetNodeData(Node1))^.TopList or PPlBoxData(PlayListBox.GetNodeData(Node2))^.TopList then
                begin
                        if PPlBoxData(PlayListBox.GetNodeData(Node2))^.TopList then result := 2 else result := -2
                end else
        result := Q_CompText(PPlBoxData(PlayListBox.GetNodeData(Node1))^.text, PPlBoxData(PlayListBox.GetNodeData(Node1))^.text);
end;

procedure TMainForm.plConCompareNodes(Sender: TBaseVirtualTree; Node1,
  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
var      s1, s2:string;
begin
     if Column = 0 then   //sorter
     begin
          if assigned(pPlconRec(plcon.getNodeData(node1))^.Rec) then
             s1 := getFtextP(pPlconRec(plcon.getNodeData(node1))^.Rec, fArtistTitle)
          else s1 := pPlconRec(plcon.getNodeData(node1))^.text;

          if assigned(pPlconRec(plcon.getNodeData(node2))^.Rec) then
             s2 := getFtextP(pPlconRec(plcon.getNodeData(node2))^.Rec, fArtistTitle)
          else s2 := pPlconRec(plcon.getNodeData(node2))^.text;
          result := GetOneOrZero(Q_CompText(s1, s2))
     end
     else   //random
            result := random(3)-1
end;

procedure TMainForm.FormKeyPress(Sender: TObject; var Key: Char);
begin
	if ord(key) = 127 then F0.text := '' else {Ctrl+BackSpave}
	begin
		if ord(key) >= 32 then  f0.text := f0.text + key;
		if (ord(key) = 8) and (length( f0.text) > 0) then
    	f0.text := copy(f0.text,1,length(f0.text)-1);
    f0.Repaint
	end
end;

procedure TMainForm.AfterTagChanged;
begin
	if pref.SaveDB.Checked then
		SaveAllNoRelease(true)
end;

procedure TMainForm.EditTagNewClick(Sender: TObject);
var
	aNode :PvirtualNode;
  selected: array of PVirtualNode;
  i: Integer;
begin
  if tabel.SelectedCount = 0 then
  	exit;

  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  Application.CreateForm(Teditor, Editor);
  //gemmer de valgte noder
  SetLength(selected, tabel.SelectedCount);

  aNode := tabel.GetFirstSelected;
  i := 0;
  while aNode <> nil do
  begin
   editor.Recs.add(GetRec(aNode));
   selected[i] := aNode;
   inc(i);
   aNode := tabel.GetNextSelected(aNode)
  end;

  disableAOT;
  CurrentActiveForm := Editor;
  if editor.Recs.count > 0 then
  begin
  	if Editor.init then
  		Editor.ShowModal
  end;
  CurrentActiveForm := nil;
  SetMainFormVisible(true);

  //exitter:
  if Editor.ReadMpegInfo.Runing then
  begin
    screen.cursor := crHourGlass;
    Editor.ReadMpegInfo.Thread.Terminate;
    Editor.ReadMpegInfo.Thread.waitFor;
    screen.cursor := crDefault
  end;

  if Editor.LyricsThread.Runing then
  begin
    screen.cursor := crHourGlass;
    Editor.LyricsThread.Thread.Terminate;
    try
    	Editor.IdHttp.Disconnect;
    except
    end;
    Editor.LyricsThread.Thread.WaitFor;
    screen.cursor := crDefault
  end;

  if Editor.AnythingChanged then
  begin
    if pref.AutoResizeColumnHeaders.Checked then
      AutoResizeAllColumnsToFit;
    tabel.repaint;
    winplaylist.repaint;

    AfterTagChanged;

    tabel.BeginUpdate;
    updateTree(true);
    tabel.ClearSelection;
    try
      for i:=0 to length(selected)-1 do
      	if NodeBelongsToTree(selected[i], tabel, true) and tabel.IsVisible[selected[i]] then
	        tabel.Selected[selected[i]] := true
    finally
      tabel.endupdate;
    end
	end;
  
  Editor.release;
  freeandnil(Editor);

  Dec(SafeToAutoScanCount)
end;

procedure TMainForm.StopCoverThread;
begin
 if Assigned(CoverLoadThread.Thread) then
  begin
    CoverLoadThread.Thread.terminate;
    SetEvent(WakeCoverThread);
    //Wait for the thread to finish
    while CoverLoadThread.Tag <> 1 do
    begin
      Sleep(5);
    end
  end;
end;

procedure TMainForm.FormDestroy(Sender: TObject);
var
	i:integer;
  PL:PplRec;
begin
	if quitting then
	begin
		MainFormInstance.OnPaint := nil;

		for i:=0 to groupList.Count-1 do
			dispose(PGroupRec(groupList.items[i]));
		for i:=0 to m3uList.Count-1 do
		begin
			PL := m3uList.items[i];
				if assigned(PL.CacheRef) then
				begin
					setLength(PplCacheRec(PL.CacheRef).Cache, 0);
					dispose(PplCacheRec(PL.CacheRef))
				end;
			dispose(PL)
		end;
		fileUndoList.free;
    fileUndoList := nil;
		groupList.free;
    groupList := nil;
		filters.free;
    filters := nil;
		reclist.free;
    reclist := nil;
		AddRecList.free;
    AddRecList := nil;

    for i:=0 to fCoverImgs.Count-1 do
    	DisposeCoverRec(fCoverImgs.List^[i], false);
    fCoverImgs.Free;

    ChangedDirsToAutoScanLock.Free;
    ChangedDirsToAutoScan.Free;

		fHashedRecList.free;

		for i:=0 to winplayUndoList.Count-1 do
			dispose(PplstUndoRec(winplayUndoList.List^[i]));

		WinplayUndoList.free;
		m3uList.free;
    FieldList.Free;
		GenreList.free;
		Fplaylist.free;
		FtreePath.free;
		Fnorm.free;
		Fadd.free;
		Fsubst.free;
		FwholeWord.free;

		FArtistFilter.Free;
 		FAlbumFilter.Free;
 		FFilePathFilter.Free;
    FGenreFilter.Free;

    FDeleteGroupsFromTagList.Free;
    FIgnoreGroupList.Free;
    FUseGroupInsteadList.Free;

		artistList.free;
		albumList.free;
		fPathList.free;
		TopImageBuffer.free;
		TempCanvas.free;
		for i:=1 to 12 do
			ScrollBarImgs[i].free;
		imgLowerLeft.free;
		imgLowerRight.free;
		imgLower.free;
		iUpLeft.free;
		iUpLeftShade.free;
		iUpRight.free;
		iUpRightShade.free;
		iUp.free;
		iUpShade.free;
		iUpBlank.Free; 

		iArc.free;
		iArcShade.free;
													
		imgLeft.free;
		imgRight.free;

		imgVolSliderBtn.free; 

		imgRepeat.free;
		imgShuffle.free;
		imgConfig.free;

		imgSlider.free;
		imgSliderBtn.free;

    FCurPlayBitmap.free;

		PositionSliderBuffer.free;
    //Must be in the lower section

    fCoverImgsRW.Free;
    fCoverRecRW.Free;

    CloseHandle(WakeCoverThread)
	end
end;

procedure TMainForm.AllRenderOLEData(Sender: TBaseVirtualTree;
  const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
  ForClipboard: Boolean; var Result: HRESULT);
var
	recs : Tlist;
	fileStrings:TStringlist;
	DropFiles : PDropFiles;
	c: PChar;
	s:String;
	strlength, i: integer;
	f:textfile;
	createPlayListFile:Boolean;
	PW:PplstRec;
	KeybState : TKeyboardState;
begin
		 createPlayListFile := not pref.dragfiles.checked;
		 GetKeyboardState(KeybState);
		 if (KeybState[VK_MENU] and 128) <> 0 then        //ALT-key
				createPlayListFile := not createPlayListFile;

		 result := E_FAIL;
     if FormatEtcIn.cfFormat = CF_HDROP then
     begin
          // standard dropfiles structure
          strlength := 0;
          recs := TList.create;
          getDragRecs(sender, recs);
          if recs.count = 0 then
          begin
               recs.free;
               exit
          end;
          fileStrings := TStringlist.create;
          if createPlayListFile then
          begin
               assignfile(f,plugindir + AppName + '\Dragged From ' + AppName + '.m3u');
               Filemode := 2;
               rewrite(f);
               writeln(f,'#EXTM3U');
               for i:=0 to recs.count-1 do
               begin
                    PW := recs.items[i];
                    if assigned(pw.Rec) then
                    begin
                         writeln(f,getFtextP(PW.Rec, Fextstr));
                         writeln(f,getFtextP(PW.Rec, Ffilename))
                    end else
                    begin
												 s := '#EXTINF' + ':' + inttostr(pw.Seconds) + ',' + pw.text;
                         writeln(f, s);
                         writeln(f, PW.filename)
                    end
               end;
               closefile(f);
               Inc(strlength, Length(plugindir + AppName + '\Dragged From ' + AppName + '.m3u')+1);
               fileStrings.add(plugindir + AppName + '\Dragged From ' + AppName + '.m3u')
          end
          else
          begin //don't create playlistfile
               for i:=0 to recs.count-1 do
               begin
                    PW := recs.items[i];
                    if assigned(PW.Rec) then
                       s := getFtextP(PW.Rec, fFilename)
                       else s := PW.filename;
                    Inc(strlength, Length(s)+1);
                    fileStrings.add(s)
               end
          end;
          for i:=0 to recs.count-1 do
              dispose(PplstRec(recs.items[i]));
          recs.free;

          // alloocate memory
          medium.hGlobal:=GlobalAlloc(GHND or GMEM_SHARE, SizeOf(TDropFiles)+strlength+1);
          if medium.hGlobal=0 then
          begin
               fileStrings.free;
               exit
          end;

          // lock memory handle
          dropfiles:=GlobalLock(medium.hGlobal);
          try
             DropFiles.pFiles:=sizeof(TDropFiles);
             DropFiles.pt:= Mouse.CursorPos;
						 DropFiles.fNC:=PtInRect(Sender.Clientrect, Mouse.CursorPos);
             DropFiles.fWide:=False;

             c:=PChar(DropFiles)+SizeOf(TDropFiles);

             for i:=0 to fileStrings.count-1 do
             begin
                  strCopy(c, pchar(fileStrings.strings[i]));
                  c := c + Length(fileStrings.strings[i])+1
             end;
             fileStrings.free;

             Medium.tymed := TYMED_HGLOBAL;
             Medium.unkForRelease := nil;
             result := S_OK
          finally
                 // unlock memory handle
                 GlobalUnlock(medium.hGlobal);
          end
     end
end;

procedure TMainForm.tabelRenderOLEData(Sender: TBaseVirtualTree;
  const FormatEtcIn: tagFORMATETC; out Medium: tagSTGMEDIUM;
  ForClipboard: Boolean; var Result: HRESULT);
begin
	AllRenderOLEData(sender, formatEtcIn, Medium, forClipboard, result)
end;

procedure TMainForm.tabelHeaderDraw(Sender: TVTHeader; Canvas: TCanvas; Column: TVirtualTreeColumn; R: TRect; Hover, Pressed: Boolean; DropMark: TVTDropMarkMode);
var
	i,x,textX,textY,emboss,c:integer;
  dm : TRect;
  Clr : TColor;
  sortColumn1, sortColumn2: integer;
begin
  //Set sortColumn1/2
  if sender.Treeview = tabel then
  begin
  	sortColumn1 := FMLSortedCol;
    sortColumn2 := FMLSortedCol1
  end
  else if sender.Treeview = winplaylist then
  begin
  	sortColumn1 := FWPSortedCol;
    sortColumn2 := FWPSortedCol1
  end
  else
  begin
  	sortColumn1 := sender.SortColumn;
    sortColumn2 := -1
  end;

  Clr := sender.Background;

  if Column.Alignment = taLeftJustify then
	  textX := R.left + 8
  else
	  if Column.Alignment = taRightJustify then
		  textX := R.Right - 8 - Canvas.TextWidth(Column.text)
	  else
		  if Column.Alignment = taCenter then
			  textX := R.Left + round(((R.Right - R.Left)/2) - (Canvas.TextWidth(Column.text)/2));

  textY := 2;
  if Pressed then
  begin
	  inc(textX);
	  inc(textY);
	  emboss := 1
  end
  else
  	emboss := 0;

  if (DropMark = dmmLeft) and (Column.Alignment = taLeftJustify) then
	  inc(textX, 10)
  else
	  if (DropMark = dmmRight) and (Column.Alignment <> taLeftJustify) then
		  dec(textX, 10);

  Canvas.brush.Color := Clr;
  Canvas.brush.Style := bsSolid;
  Canvas.FillRect(r);
  Canvas.Font := sender.font;

  if (Column.Tag = sortColumn1) or (Column.Tag = sortColumn2) then
  begin
  	//Draw sort triangle
	  if Column.Alignment = taRightJustify then
	    textX := R.Left + 4
	  else
	    dec(textX, 7);

    if Column.Tag = sortColumn1 then
    	x:=40
    else
    	x:= 10;

	  for i:=0 to 3 do
	  begin
	  	Canvas.pen.color := ChangeBrightness(Clr,x,false);
      if Column.Tag = sortColumn1 then
    		inc(x, 35)
      else
		    inc(x, 20);
	    if Sender.SortDirection = sdAscending then
	    	Canvas.Polygon([point(textX+4+i+emboss,r.Bottom-4-i+emboss), point(textX+12-i+emboss,r.bottom-4-i+emboss), point(textX+8+emboss,r.top+4+i+emboss)])
	    else
	    	Canvas.Polygon([point(textX+4+i+emboss,r.Top+4+i+emboss), point(textX+12-i+emboss,r.Top+4+i+emboss), point(textX+8+emboss,r.Bottom-4-i+emboss)])
	  end;
	  Canvas.brush.color := Clr;
	  if Column.Alignment = taRightJustify then
	    textX := R.Right - 8 - Canvas.TextWidth(Column.text)
	  else
		  inc(textX,18)
    //End of Draw sort triangle
  end;

  Canvas.TextOut(textX, textY,Column.Text);
  if DropMark <> dmmNone then
  begin
    x := r.bottom -  r.top;
    if DropMark = dmmLeft then
    begin
      dm := rect(r.left, r.top, r.left+x, r.top+x)
    end
    else
    begin
      dm := rect(r.right-x, r.top, r.right, r.top+x)
    end;
    c := 40;
    i:=1;
    while (dm.bottom-i) > (dm.top+i) do
    begin
      Canvas.pen.color := ChangeBrightness(Clr,c,false);
      inc(c,20);
      Canvas.Ellipse(dm.left+i,dm.top+i, dm.right-i, dm.bottom-i);
      inc(i)
    end;
    Canvas.Pen.color := Clr;
    Canvas.brush.color := Clr;
    if DropMark = dmmLeft then
    begin
      dm := rect(dm.left+5, dm.top+5, dm.Right-((dm.right-dm.Left)div 2), dm.bottom-5);
      Canvas.polygon([point(dm.Left, dm.Top + ((dm.bottom-dm.top) div 2)), point(dm.right, dm.top), point(dm.right, dm.bottom)])
    end
    else
    begin
      dm := rect(dm.left+((dm.right-dm.Left)div 2)-1, dm.top+5, dm.Right-6, dm.bottom-5);
      Canvas.polygon([point(dm.right, dm.Top + ((dm.bottom-dm.top) div 2)), point(dm.left, dm.top), point(dm.left, dm.bottom)])
    end
  end;
	PaintWA(canvas,rect(r.left,r.top,r.right-1,r.bottom-1),sender.Background ,not pressed,true,true,true,true)
end;

procedure TMainForm.WinplaylistFreeNode(Sender: TBaseVirtualTree;
  Node: PVirtualNode);
begin
	finalize(PplstRec(sender.GetNodeData(node))^)
end;

procedure TMainForm.playlistboxFreeNode(Sender: TBaseVirtualTree;
  Node: PVirtualNode);
begin
     finalize(pPlBoxData(Sender.GetNodeData(Node))^)
end;

procedure TMainForm.plConFreeNode(Sender: TBaseVirtualTree;
  Node: PVirtualNode);
begin
		 finalize(pPLconRec(Sender.GetNodeData(Node))^)
end;

procedure TMainForm.tabelGetUserClipboardFormats(
  Sender: TBaseVirtualTree; var Formats: TFormatEtcArray);
begin
	setlength(formats, length(formats)+1);
  formats[length(formats)-1].cfFormat := CF_HDROP;
  formats[length(formats)-1].ptd := nil;
  formats[length(formats)-1].dwAspect := DVASPECT_CONTENT;
  formats[length(formats)-1].lindex := -1;
  formats[length(formats)-1].tymed := TYMED_HGLOBAL
end;

procedure TMainForm.treeUpdating(Sender: TBaseVirtualTree;
	State: TVTUpdateState);
begin
	case state of
   	usBegin:
    	Application.CancelHint;
    usEnd:
    begin
    	if assigned(pref) then
      begin
      	{if sender = tree then
        begin
					aNode := tree.GetFirst;
          while aNode <> nil do
          begin
          	Exclude(aNode.States, vsHeightMeasured);
            aNode := tree.GetNext(aNode)
          end
        end; }

	      if (sender = tabel) and continuousPlay1.checked and fromMainList1.Checked and pref.updateContPlayOnFilter.checked and CheckConPlay then
        	winplaysave;

        if (sender = Winplaylist) then
        begin
          AdjustWinplaylistSongNoColumnWidth;
          AdjustWinplaylistEnqueueNoColumnWidth
        end;

        if (sender = tabel) and pref.cbShowTotalDurationLabel.checked then
        begin
					TimerUpdateLblMainlistCount.Enabled := false;
				  TimerUpdateLblMainlistCount.Enabled := true
        end;

        if sender = winplaylist then
        begin
          UpdateWinplaylistTimeLabel;
          ResizeWinplaylistColumns
        end;

        if (Pref.Scrollbars.itemindex = 2) then
	      	UpdateTreeBounds(Sender);
      end;
	  end;
  end;
end;

procedure TMainForm.UpdateLblMainListCount;
var
	aNode: PVirtualNode;
	totalTime, selTime, totalFilesize, selFilesize: int64;
  rec: PRec;
  oldLabelWidth: Integer;
begin
	if pref.cbShowTotalDurationLabel.Checked then
  begin
  	totalTime := 0;
    selTime := 0;
    totalFilesize := 0;
    selFilesize := 0;

		aNode := tabel.GetFirstVisible;
    while aNode <> nil do
    begin
      rec := GetRec(aNode);

      if vsSelected in aNode.States then
      begin
        inc(selFilesize, rec.FSize);
        inc(selTime, rec.Length)
      end
      else
      begin
        inc(totalFilesize, rec.FSize);
        inc(totalTime, rec.Length)
      end;

      aNode := tabel.GetNextVisible(aNode);
    end;
    inc(totalFilesize, selFilesize);
    inc(totalTime, selTime);
    oldLabelWidth := lblMainListCount.Width;
    lblMainListCount.Caption := inttostr(tabel.SelectedCount) + '/' + inttostr(tabel.VisibleCount) + ' | ' + IntTimeToStr(selTime, true, false) + '/' + IntTimeToStr(totalTime, true, false);
    lblMainListCount.Hint := floattoStrF(selFilesize div 1024, ffnumber, 15, 0) + ' kb / ' + floattoStrF(totalFilesize div 1024, ffnumber, 15, 0) + ' kb';
    if oldLabelWidth <> lblMainListCount.Width then
	    filterbarResize(nil)
  end;
end;

procedure TMainForm.UpdateWinplaylistTimeLabel;
var
	aNode: PVirtualNode;
	pl: PplstRec;
begin
	WinPlayListTimeTotal := 0;
	WinPlayListTimeUntilPlayingNode := 0;
	CurrentPlayingIndex := 0;
	aNode := winplaylist.GetFirst;
	while aNode <> nil do
	begin
		pl := winplaylist.GetNodeData(aNode);
		if pl.Playing then
		begin
			WinPlayListTimeUntilPlayingNode := WinPlayListTimeTotal;
			CurrentPlayingIndex := aNode.Index +1
		end;
		if assigned(pl.Rec) then
			inc(WinPlayListTimeTotal, pl.Rec.Length)
		else inc(WinPlayListTimeTotal, pl.Seconds * 1000);
			aNode := Winplaylist.GetNext(aNode)
	end;
	if playbackstatus(hwnd_winamp) in [0, 3] then
		PaintPlayingTimeLabel(0)
end;

procedure TMainForm.PaintPlayingTimeLabel(const extraTime: int64);
var
	s: String;
	x: Integer;
begin
	s := IntToStr(CurrentPlayingIndex) + '/' + IntToStr(winPlaylist.RootNodecount) + ' - ' + IntTimeToStr(WinPlayListTimeUntilPlayingNode + extraTime, true ,false) + ' / ' + IntTimeToStr(WinPlayListTimeTotal, true ,false);
	x := winplaylistTimeLabel.Canvas.TextWidth(s);
	winplaylistTimeLabel.SetBounds(Winplaylist.ClientWidth - x - 4, 0, x, winplaylistTimeLabel.Height);
	winplaylistTimeLabel.Caption := s
end;

procedure TMainForm.PaintFileInfoLabel;
var
	s, Channels: String;
	status, StatusWidth, ChannelsWidth, textWidth, AllowedWidth, CurrentTimeWidth, i: Integer;
begin
	status := playbackstatus(hwnd_winamp);

	if status = 0 then
		s := StatusText[1]
	else
	if status = 3 then
		s := StatusText[2]
	else
	if status = 1 then //playing
	begin
		case Sendmessage(hwnd_Winamp, wm_user, 2, 126) of
			1: Channels := ' ' + GetText(TXT_Mono);
			2: Channels := ' ' + GetText(TXT_Stereo);
		else Channels := '';
		end;
		s := ' ' + inttostr(Sendmessage(hwnd_Winamp, wm_user, 1, 126)) + ' kbps ' + inttostr(Sendmessage(hwnd_Winamp, wm_user, 0, 126)) + ' KHz';

		if WinplaylistCurrentTimeLabel.Visible then
			CurrentTimeWidth := WinplaylistCurrentTimeLabel.Canvas.TextWidth(WinplaylistCurrentTimeLabel.Caption)
		else
			CurrentTimeWidth := 0;
		textWidth := FileInfoLabel.Canvas.TextWidth(s);
		StatusWidth := FileInfoLabel.Canvas.TextWidth(StatusText[3]);
		ChannelsWidth := FileInfoLabel.Canvas.TextWidth(Channels);
		AllowedWidth := WinplaylistTimeLabel.Left - CurrentTimeWidth;

		if AllowedWidth - textWidth - StatusWidth - ChannelsWidth > 10 then
			s := StatusText[3] + s + Channels
		else
		if AllowedWidth - textWidth - ChannelsWidth > 10 then
			s := s + Channels
		else
		if AllowedWidth - textWidth <= 10 then
			s := ''
	end;
	FileInfoLabel.Caption := s;

	if WinplaylistCurrentTimeLabel.Visible and (status <> 3) then
	begin
		i := (FCurPlayRect.Left + ((FCurPlayRect.Right - FCurPlayRect.Left) div 2)) - (tabelPanel.Left + tabelPanelLow.Left);

		if FileInfoLabel.Left + FileInfoLabel.Width < i-(CurrentTimeWidth div 2)-10 then
			WinplaylistCurrentTimeLabel.SetBounds(i - (CurrentTimeWidth div 2), WinplaylistCurrentTimeLabel.Top, CurrentTimeWidth, WinplaylistCurrentTimeLabel.Height)
		else
			WinplaylistCurrentTimeLabel.SetBounds(FileInfoLabel.Left + FileInfoLabel.Width, WinplaylistCurrentTimeLabel.Top, WinplaylistTimeLabel.Left - FileInfoLabel.Left - FileInfoLabel.Width, WinplaylistCurrentTimeLabel.Height)
	end
end;

procedure TMainForm.AutoResizeAllColumnsToFit;
var
	aNode: PVirtualNode;
	i: Integer;
	AutoSizeColumns: Boolean;
	TextLengths, ColumnTags, ColumnIndexes: array of Integer;
	ShowColumns: array of Boolean; //artist (1), Album(3), Genre(4)
begin
	SetLength(ShowColumns, length(TabelColumnsVisible));
	for i:=0 to length(ShowColumns)-1 do
		ShowColumns[i] := TabelColumnsVisible[i];

	if Pref.HideInfoShownInTree.Checked and (Length(fTreeFilter) = 1) then
	begin
			for i:=1 to length(fTreeFilter[0])-1 do
			begin
				if fTreeFilter[0][i].Kind in [TreeKind_artist, TreeKind_artistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum] then
					ShowColumns[1] := false  //artist
        else
				if fTreeFilter[0][i].Kind in [TreeKind_FullAlbum, TreeKind_PartialAlbum, TreeKind_album, TreeKind_YearAlbum, TreeKind_FullYearAlbum, TreeKind_PartialYearAlbum, TreeKind_artistAlbum, TreeKind_FullArtistAlbum, TreeKind_PartialArtistAlbum, TreeKind_CompilationAlbum, TreeKind_FullCompilationAlbum, TreeKind_PartialCompilationAlbum] then
					ShowColumns[3] := false  //album
        else
				if fTreeFilter[0][i].Kind = TreeKind_genre then
					ShowColumns[4] := false   //genre
        else
        if fTreeFilter[0][i].Kind = TreeKind_Year then
        	Showcolumns[5] := false;	//year
			end
	end;

	AutoSizeColumns := pref.AutoResizeColumnHeaders.Checked;
	if AutoSizeColumns then
	begin
		TempCanvas.Canvas.Font := tabel.Font;

		ColumnTags := nil;
		for i:=1 to ColumnsToAutoResizeCount do
			if ShowColumns[ColumnsToAutoResize[i]] then
			begin
				SetLength(ColumnTags, Length(ColumnTags)+1);
				SetLength(ColumnIndexes, Length(ColumnIndexes)+1);
				ColumnTags[length(ColumnTags)-1] := tabel.Header.Columns[ColumnsToAutoResize[i]].Tag;
				ColumnIndexes[length(ColumnTags)-1] := ColumnsToAutoResize[i]
			end;

      //Custom fields
    	for i:=0 to tabel.Header.Columns.Count-1 do
      	if (tabel.Header.Columns[i].Tag >= FCustomField) and (ShowColumns[i]) then
	      begin

	      	SetLength(ColumnTags, Length(ColumnTags)+1);
					SetLength(ColumnIndexes, Length(ColumnIndexes)+1);
					ColumnTags[length(ColumnTags)-1] := tabel.Header.Columns[i].Tag;
					ColumnIndexes[length(ColumnTags)-1] := i
	      end;
		SetLength(TextLengths, Length(ColumnTags));

		aNode := Tabel.GetFirstVisible;
		while aNode <> nil do
		begin
			ProcessTextLength(TempCanvas.Canvas, GetRec(aNode), ColumnTags, TextLengths, length(ColumnTags), TempCanvas.Canvas.TextWidth('X '));
			aNode := tabel.GetNextVisible(aNode)
		end
	end;

	//resizer columns:
	if Pref.HideInfoShownInTree.Checked or AutoSizeColumns then
		tabel.BeginUpdate;

	if AutoSizeColumns then
	begin
		for i:=0 to length(ColumnIndexes)-1 do
		begin
			if TextLengths[i] = 0 then
				ShowColumns[ColumnIndexes[i]] := false
			else tabel.Header.Columns[ColumnIndexes[i]].Width := TextLengths[i]+16
		end
	end;

	if Pref.HideInfoShownInTree.Checked or AutoSizeColumns then
	begin
		for i:=0 to length(ShowColumns)-1 do
			if ShowColumns[i] then
				tabel.Header.Columns[i].Options := tabel.Header.Columns[i].Options + [coVisible]
			else tabel.Header.Columns[i].Options := tabel.Header.Columns[i].Options - [coVisible];
		tabel.EndUpdate
	end
end;

procedure TMainForm.ProcessTextLength(const canvas: TCanvas; const rec: PRec; const ColumnTags: array of Integer; var TextLengths: array of Integer; const ColumnTagsLength, CharWidth: Integer);
function GetTextWidth(const s: String; MaxWidth: Integer): Integer;
begin
	result := 0;
  if CharWidth * length(s) > MaxWidth then
  	result := Canvas.TextWidth(s)
end;
var
	k, ArrayIndex: Integer;
begin
	if rfplaying in rec.Flags then
		if not (fsBold in Canvas.Font.Style) then
			Canvas.Font.Style := Canvas.Font.Style + [fsBold]
		else
	else
		if (fsBold in Canvas.Font.Style) then
			Canvas.Font.Style := Canvas.Font.Style - [fsBold];

	if not dbs[rec.location].exists then
		if not (fsItalic in Canvas.Font.Style) then
			Canvas.Font.Style := Canvas.Font.Style + [fsItalic]
		else
	else
		if fsItalic in Canvas.Font.Style then
			Canvas.Font.Style := Canvas.Font.Style - [fsItalic];

	for ArrayIndex := 0 to ColumnTagsLength-1 do
	begin
    Case ColumnTags[arrayIndex] Of
    	FArtist:
	    	k := GetTextWidth(ArtistList.Strings[rec.artist], TextLengths[arrayIndex]);
			FTitle:
      	k := GetTextWidth(rec.Title, TextLengths[arrayIndex]);
      FAlbum:
      	k := GetTextWidth(AlbumList.Strings[rec.album], TextLengths[arrayIndex]);
      FComment:
      	k := GetTextWidth(rec.Comment, TextLengths[arrayIndex]);
      FFileName:
      	k := Canvas.TextWidth(FPathList.Strings[rec.Fpath]) + Canvas.TextWidth('\') + Canvas.TextWidth(rec.Fname);
      else
				k := GetTextWidth(GetFTextP(rec, ColumnTags[arrayIndex]), TextLengths[arrayIndex]); //Canvas.TextWidth(GetFTextP(rec, ColumnTags[arrayIndex]));
    end;
		if k > TextLengths[arrayIndex] then
			TextLengths[arrayIndex] := k
	end
end;

procedure TMainForm.playlistboxScroll(Sender: TBaseVirtualTree; DeltaX,
  DeltaY: Integer);
begin
        if Pref.Scrollbars.itemindex = 2 then
        begin
						 if DeltaY <> 0 then UpdateVScroll(PlaylistboxScrollV, PlaylistBox)
        end
end;

procedure TMainForm.plConScroll(Sender: TBaseVirtualTree; DeltaX,
  DeltaY: Integer);
begin
	if (Pref.Scrollbars.itemindex = 2) and (DeltaY <> 0) then
		UpdateVScroll(PlConScrollV, plCon);
//	if deltaX <> 0 then
//		plcon.perform(WM_VSCROLL, SB_TOP, 0);
end;

procedure TMainForm.treeAfterPaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas);
begin
  if TreeScrollbarsNeedsUpdate and assigned(Pref) and (Pref.Scrollbars.itemindex = 2) then
  begin
    //TreeScrollbarsNeedsUpdate bliver sat til true i OnCollapsed/Expanded
    UpdateTreeBounds(Sender);
    TreeScrollbarsNeedsUpdate := false
  end
end;

procedure TMainForm.treeCollapsed(Sender: TBaseVirtualTree;
  Node: PVirtualNode);
begin
     // TreeScrollbarsNeedsUpdate sttes til true, s bliver scollbarene updated i OnAfterPaint
	TreeScrollbarsNeedsUpdate := true
end;

procedure TMainForm.tabelHeaderClick(Sender: TVTHeader; Column: TColumnIndex;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
	OPL:boolean;
  Focused, aNode: PVirtualNode;
begin
  if button <> mbLeft then
  	exit;

  if fOnlyPL and (fPlayList.Count=0) then
  	exit;
  if FMLSortedCol = tabel.header.Columns[column].tag then
  	if tabel.Header.SortDirection = sdAscending then
    	tabel.Header.SortDirection := sdDescending else tabel.Header.SortDirection := sdAscending;
  tabel.Header.SortColumn := column;
  FMLSortedCol1 := FMLSortedCol;
  FMLSortedCol := tabel.header.Columns[column].tag;
  if fOnlyPL then
  begin
    fOnlyPL := false;
    OPL := true;
    RecListToTabel(true, true);
    tree.repaint
  end
  else
  	OPL := false;

  Focused := tabel.FocusedNode;

  tabel.BeginUpdate;
  tabel.SortTree(FMLSortedCol,tabel.header.sortdirection, false);
  TabelToRecList;
  if OPL then
  	showhidenodes;
  //selecter den gamle focused node
  aNode := tabel.GetFirstVisible;
  while aNode <> nil do
  begin
  	if aNode = Focused then
    begin
    	tabel.ScrollIntoView(aNode, true);
      break
    end;
    aNode := tabel.GetNextVisible(aNode)
  end;
  tabel.endupdate;
end;

procedure TMainForm.Addplaylist1Click(Sender: TObject);
var       Fstr : TStream;
          s:string;
          PL : pPLrec;
begin
  disableAOT;
  if savedialog1.Execute then
  begin
    try
       Fstr := TFileStream.create(savedialog1.filename, fmCreate or fmShareExclusive);
       s := '#EXTM3U';
       Fstr.WriteBuffer(pointer(s)^, length(s));
       Fstr.free;

       new(PL);
       fillChar(PL^, sizeOf(PL^), #0);
       s := getFileName(savedialog1.filename);
       s := Q_CopyLeft(s, Q_StrRScan(s, '.')-1);
       PL.Name := s;
       PL.Filename := savedialog1.filename;
       PL.UseToSuggest := useToSuggest_unDefined;
       PL.location := 0;
       PL.CacheRef := nil;
       m3uList.Add(PL);
       updateTree(true)
    except
      showmessagex(GetText(TXT_ErrorCreatingFile));
      SetMainFormVisible(true)
    end
  end;
  SetMainFormVisible(true)
end;

procedure TMainForm.Enqueueandplay1Click(Sender: TObject);
var     aNode :PvirtualNode;
        i:integer;
begin
	SaveWinplayUndo;
	aNode := tabel.getfirstselected;
	winplaylist.BeginUpdate;
	i:=-1;
	while aNode <> nil do
	begin
		i := winplayadd(getRec(aNode), GetKill).index;
		aNode := tabel.getnextselected(aNode)
	end;
	if continuousPlay1.checked then CheckConPlay;
	WinPlaySave(i);
	winplaylist.endupdate;
	if playbackstatus(hwnd_winamp) = 3 then //paused
		button4(hwnd_winamp);
	button2(hwnd_winamp)
end;

procedure TMainForm.Punchin3Click(Sender: TObject);
var       aNode, pNode, backUpNode : PvirtualNode;
          found:boolean;
begin
		 SaveWinplayUndo;
     winplaylist.beginupdate;
     pNode := Winplaylist.getfirst;
     found := false;
     while (pNode <> nil) and not found do
     begin
					if PplstRec(winplaylist.GetNodeData(pNode)).playing then
             found := true
          else pNode := winplaylist.GetNext(pNode)
     end;

     if not found then pNode := winplaylist.GetLast;

     aNode := tabel.GetFirstSelected;
     while aNode <> nil do
     begin
          backUpNode := pNode;
					pNode := winplayInsert(GetRec(aNode),pNode,amInsertAfter, GetKill);
          if assigned(pNode) then
             PplstRec(winplaylist.GetNodeData(pNode)).playing := false
          else pNode := backUpNode;
          aNode := tabel.GetNextSelected(aNode)
     end;

     if continuousPlay1.checked then CheckConPlay;
     winplaysave;
     winplaylist.endupdate
end;

procedure TMainForm.Punchinandplay2Click(Sender: TObject);
var       aNode, pNode, backUpNode : PvirtualNode;
          first, found:boolean;
begin
		 SaveWinplayUndo;
     winplaylist.beginupdate;
     pNode := Winplaylist.getfirst;
     found := false;
     while (pNode <> nil) and not found do
     begin
          if PplstRec(winplaylist.GetNodeData(pNode)).playing then
             found := true
          else pNode := winplaylist.GetNext(pNode)
     end;

     if not found then pNode := winplaylist.GetLast;

     if assigned(pNode) then PplstRec(winplaylist.GetNodeData(pNode)).playing := false;

     aNode := tabel.GetFirstSelected;
		 first := true;
     while aNode <> nil do
     begin
          backUpNode := pNode;
          pNode := winplayInsert(GetRec(aNode),pNode,amInsertAfter, GetKill);
          if assigned(pNode) then
          begin
               PplstRec(winplaylist.GetNodeData(pNode)).playing := first;
               first := false
          end
          else pNode := backUpNode;

          aNode := tabel.GetNextSelected(aNode)
     end;
     if continuousPlay1.checked then CheckConPlay;
     winplaysave;
     winplaylist.endupdate;
		 if playbackstatus(hwnd_winamp) = 3 then //paused
        button4(hwnd_winamp);
     button2(hwnd_winamp)
end;
procedure TMainForm.Findindatabase1Click(Sender: TObject);
var       vNode, aNode, foundNode:PvirtualNode;
          VR:PplstRec;
begin
     vNode := winplaylist.GetFirstSelected;
     if assigned(vNode) then
     begin
          VR := winplaylist.GetNodeData(vNode);
          if VR.Rec = nil then
          	VR.Rec := FindInReclist(VR.filename);
          if VR.Rec <> nil then
          begin
               aNode := tabel.GetFirstVisible;
               foundNode := nil;
               while aNode <> nil do
               begin
                    if VR.Rec = GetRec(aNode) then
                       foundNode := aNode;
                    aNode := tabel.GetNextVisible(aNode)
               end;
               if assigned(foundNode) then
               begin
                    tabel.clearSelection;
										tabel.selected[foundNode] := true;
                    tabel.FocusedNode := foundNode
               end
          end
     end
end;

procedure TMainForm.JvDeviceChanged1DeviceArrived(Sender: TObject;
  Drive: Char);
begin
	checkDrives(false)
end;

procedure TMainForm.JvDeviceChanged1DeviceRemoveCompleted(
  Sender: TObject; Drive: Char);
begin
	checkDrives(false)
end;

procedure TMainForm.Clearall1Click(Sender: TObject);
begin
  SaveWinplayUndo;
  button4(hwnd_winamp);
  winplaylist.BeginUpdate;
  winplaylist.clear;
  winplaySave;
  winplaylist.EndUpdate
end;

procedure TMainForm.Clearallbutplaying1Click(Sender: TObject);
var       aNode:PvirtualNode;
          WinplayRec: PplstRec;
begin
     SaveWinplayUndo;
     winplaylist.BeginUpdate;
     winplaylist.clearSelection;
     aNode := winplaylist.GetFirst;
     while aNode <> nil do
     begin
          WinplayRec := winplaylist.GetNodeData(aNode);
          Winplaylist.Selected[aNode] := not Winplayrec.Playing;
          aNode := winplaylist.getNext(aNode)
     end;
		 winplaylist.DeleteSelectedNodes;
     ValidateWinplayEnqueue;
     if continuousPlay1.checked then CheckConPlay;
     winplaysave;
     winplaylist.endupdate
end;

procedure TMainForm.ClearButtonMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	ClearPopup.popup(clearButton.clienttoscreen(point(0,clearButton.height)).x,clearButton.clienttoscreen(point(0,clearButton.height)).y)
end;

procedure TMainForm.ClearSelected1Click(Sender: TObject);
begin
     SaveWinplayUndo;
     winplaylist.Beginupdate;
     winplaylist.DeleteSelectedNodes;
     ValidateWinplayEnqueue;
     if continuousPlay1.checked then CheckConPlay;
     winplaysave;
     winplaylist.endupdate;
end;

procedure TMainForm.Cropselected1Click(Sender: TObject);
var       aNode:PvirtualNode;
begin
     SaveWinplayUndo;
     winplaylist.BeginUpdate;
     aNode := winplaylist.GetFirst;
     while aNode <> nil do
     begin
          Winplaylist.Selected[aNode] := not Winplaylist.Selected[aNode];
          aNode := winplaylist.getNext(aNode)
     end;
     winplaylist.DeleteSelectedNodes;
     ValidateWinplayEnqueue;
     if continuousPlay1.checked then CheckConPlay;
     winplaysave;
     winplaylist.endupdate;
end;

procedure TMainForm.Deletefromplaylist1Click(Sender: TObject);
begin
		 if FonlyPL then
     begin
					tabel.deleteSelectedNodes;
          SavePLfromTabel
		 end;
		 if pref.AutoResizeColumnHeaders.Checked then
					AutoResizeAllColumnsToFit;
end;

procedure TMainForm.Deleteplaylist2Click(Sender: TObject);
var       TR:PTreeRec;
          aNode, bNode:PvirtualNode;
          PL : PPlRec;
begin
     bNode := nil;
     aNode := tree.GetFirstSelected;
     while aNode <> nil do
     begin
          TR := tree.getNodeData(aNode);
          if TR.kind = TreeKind_Playlist then
          begin
               PL := TR.PlRecRef;
               if YesNoBoxx(GetText(TXT_DeletePlaylist), GetText(TXT_DeleteThePlaylist,  [#13 + PL.name + #13 + '(' + PL.Filename + ')']), GetText(TXT_Yes), GetText(TXT_No), 2) then
               begin
                    if not fileexists(PL.filename) or FileDeleteRB(PL.filename) then
                    begin
                         m3uList.delete(m3uList.IndexOf(PL));
                         if assigned(PL.CacheRef) then
                         begin
                              setLength(PplCacheRec(PL.CacheRef).Cache, 0);
                              dispose(PplCacheRec(PL.CacheRef))
                         end;
                         dispose(PL);
                         bNode := tree.GetNextSelected(aNode);
                         tree.DeleteNode(aNode);
                         aNode := nil
                    end else
                    showmessageX(GetText(TXT_CouldNotDeleteFile, [#13 + PL.filename]) + #13 + SysErrorMessage(GetLastError))
               end
          end;
          if assigned(bNode) then
          begin
               aNode := bNode;
               bNode := nil
          end else
							if assigned(aNode) then aNode := tree.GetNextSelected(aNode)
     end
end;

procedure TMainForm.Cleardupes1Click(Sender: TObject);
begin
     SaveWinplayUndo;
end;

procedure TMainForm.Undo1Click(Sender: TObject);
begin
     if WinplayCanUndo then
        WinplayUndo
end;

procedure TMainForm.AddToMIClicked(Sender: TObject);
var
	FStr: TStream;
	Rec: PRec;
	plRec: PplstRec; //til winplaylist
	aNode: PVirtualNode;
	Source: TVirtualStringTree;
	s, QLname: String;
	b: byte;
begin
	if Q_SameText(TMenuItem(Sender).GetParentMenu.name, FilesPopUp.name) then
		Source := tabel
	else
	if Q_SameText(TMenuItem(Sender).GetParentMenu.Name, WinplayPop.name) then
		Source := WinPlaylist;

	QLname := TMenuItem(Sender).Caption;
	QLname := Q_ReplaceStr(QLname, '&&', '|');
  Q_DeleteStr(QLName, '&');	//	QLname := Q_ReplaceStr(QLname, '&', '');
	QLname := Q_ReplaceStr(QLname, '|', '&');
	s := settingsdir + '-quicklist\' + QLname + '.m3u';
	if FileExists(s) then
	begin
		FStr := TFileStream.Create(s, fmOpenReadWrite or fmShareDenyNone);

		if FStr.Size = 0 then
		begin
			s := '#EXTM3U' + #13#10;
			Fstr.writeBuffer(pointer(s)^, length(s))
		end else
		begin
			FStr.Position := FStr.Size - 1;
			FStr.Read(b, SizeOf(b));
			if not (b in [13, 10]) then
			begin
				s := #13#10;
				Fstr.writeBuffer(pointer(s)^, length(s))
			end
		end;

		aNode := Source.GetFirstSelected;
		while aNode <> nil do
		begin
			if Source = tabel then
			begin
				rec := GetRec(aNode);
				s := getFtextP(rec, Fextstr) + #13#10 + getFtextP(rec, fFilename) + #13#10
			end
			else
			if Source = Winplaylist then
			begin
				plRec := WinplayList.GetNodeData(aNode);
				if assigned(plRec.Rec) then
					s := getFtextP(plRec.Rec, Fextstr) + #13#10 + getFtextP(plRec.Rec, fFilename) + #13#10
				else
					s:= '#EXTINF' + ':' + inttostr(plRec.Seconds) + ',' + plRec.text + #13#10 + plRec.Filename + #13#10;
			end;
			Fstr.writeBuffer(pointer(s)^, length(s));

			aNode := Source.GetNextSelected(aNode)
		end;
		FStr.Free
	end;

	//opdaterer plcon
	aNode := playlistBox.GetFirstSelected;
	if assigned(aNode) and not PPlBoxData(PlayListBox.GetNodeData(aNode))^.toplist and Q_SameText(PPlBoxData(PlayListBox.GetNodeData(aNode))^.Text, QLname) then
		playlistboxChange(PlaylistBox, aNode)
end;

procedure TMainForm.FillAddToSubMenu(parentMI: TMenuItem);
var
	aNode: PVirtualNode;
	plbRec: PPlBoxData;
begin
	parentMI.Clear;
	aNode := playlistbox.GetFirst;
	while aNode <> nil do
	begin
			plbRec := playlistBox.GetNodeData(aNode);
			if not plbRec.TopList then
				parentMI.Add(NewItem(plbrec.Text, 0, false, true, AddToMIClicked, 0, 'AddToMI'));
			aNode := playlistBox.GetNext(aNode)
	end;
	parentMI.Visible := parentMI.Count > 0
end;

procedure TMainForm.WinplaypopPopup(Sender: TObject);
var
	aNode:PVirtualNode;
begin
	play2.Visible := winplaylist.SelectedCount = 1;
	undo1.Visible := true;
	MoveUp2.Visible := true;
	MoveDown2.Visible := true;
	Delete2.Visible := true;
	ToggleKill1.Visible := true;
	Sort2.Visible := true;
	Shuffle2.Visible := true;
	EditTag2.Visible := true;
	SaveAsQuicklist1.Visible := true;
	WinplaylistAddToQuicklist.Visible := true;
  EnqueueDequeue1.Visible := pref.ControlPlaylist.Checked and (winplaylist.SelectedCount = 1);
  Punchin4.Visible := Winplaylist.SelectedCount > 0;
  Openinexplorer1.Visible := (Winplaylist.SelectedCount = 1) and not PartyMode1.Checked;
  Savelist1.Visible := not PartyMode1.Checked;
  AutosetKillafterplay1.Visible := not PartyMode1.Checked or not pref.AlwaysEnableKill.Checked;
  Shuffleselected1.Visible := (winplaylist.SelectedCount > 1) and (not PartyMode1.Checked or not pref.DisableDeleteMoveWinampPlaylist.checked);

	Refresh2.Visible := not pref.ControlPlaylist.Checked;


	FillAddToSubMenu(WinplaylistAddToQuicklist);

	aNode := winplaylist.GetFirstSelected;
	ToggleKill1.checked := aNode <> nil;
	while aNode <> nil do
	begin
		if PplstRec(Winplaylist.GetNodeData(aNode)).Kill = kill_none then
		begin
			ToggleKill1.checked := false;
			break
		end;
		aNode := winplaylist.GetNextSelected(aNode)
	end;

	if PartyMode1.Checked then
	begin
  	play2.Visible := play2.Visible and not pref.PartyDisablePlaybackControls.Checked;
		undo1.Visible := undo1.Visible and not pref.DisableDeleteMoveWinampPlaylist.Checked;
		MoveUp2.Visible := MoveUp2.Visible and not pref.DisableDeleteMoveWinampPlaylist.Checked;
		MoveDown2.Visible := MoveDown2.Visible and not pref.DisableDeleteMoveWinampPlaylist.Checked;
		Delete2.Visible := Delete2.Visible and not pref.DisableDeleteMoveWinampPlaylist.Checked;
		ToggleKill1.Visible := ToggleKill1.Visible and not pref.AlwaysEnableKill.Checked;
		Sort2.Visible := Sort2.Visible and not pref.DisableDeleteMoveWinampPlaylist.Checked;
		Shuffle2.Visible := Shuffle2.Visible and not pref.DisableDeleteMoveWinampPlaylist.Checked;
		EditTag2.Visible := EditTag2.Visible and not pref.DisableTagging.Checked;
		SaveAsQuicklist1.Visible := SaveAsQuicklist1.Visible and not pref.DisableEditQuicklist.Checked;
    WinplaylistAddToQuicklist.Visible := WinplaylistAddToQuicklist.Visible and not pref.DisableEditQuicklist.Checked;
    Punchin4.Visible := Punchin4.Visible and not (pref.DisableDeleteMoveWinampPlaylist.Checked or pref.PartyDisablePlaybackControls.Checked);
    EnqueueDequeue1.Visible := EnqueueDequeue1.Visible and not (pref.DisableDeleteMoveWinampPlaylist.Checked or pref.PartyDisablePlaybackControls.Checked);
	end
end;

procedure TMainForm.Edittag2Click(Sender: TObject);
var     aNode :PvirtualNode;
				PL : PplstRec;
				TempRecList : TList;
				rec : PRec;
				i : Integer;
begin
  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

				Application.CreateForm(Teditor, Editor);

				TempRecList := TList.Create;
        aNode := winplaylist.GetFirstSelected;
        while aNode <> nil do
				begin
					PL := Winplaylist.GetNodeData(aNode);
					if not assigned(PL.Rec) then
						PL.Rec := FindInReclist(PL.filename);
					if assigned(PL.Rec) then
						editor.Recs.add(PL.Rec)
					else
					begin
							new(rec);
              FillChar(rec^, SizeOf(rec^), #0);
							if ReadId3(nil, PL.Filename, '', 0, 0, rec, false) then
							begin
								TempRecList.Add(rec);
								editor.Recs.add(rec)
							end
							else dispose(rec)
						 end;
             aNode := winplaylist.GetNextSelected(aNode)
        end;
				disableAOT;
        CurrentActiveForm := Editor;
				if editor.Recs.count > 0 then
				begin
					if Editor.init then
  					Editor.ShowModal
				end;
        CurrentActiveForm := nil;
				SetMainFormVisible(true);

        //exitter:
        if Editor.ReadMpegInfo.Runing then
        begin
             screen.cursor := crHourGlass;
             Editor.ReadMpegInfo.Thread.waitFor;
             screen.cursor := crDefault
        end;

        if Editor.LyricsThread.Runing then
        begin
           screen.cursor := crHourGlass;
           Editor.LyricsThread.Thread.Terminate;
           try
  					Editor.IdHttp.Disconnect;
           except
           end;
           Editor.LyricsThread.Thread.WaitFor;
           screen.cursor := crDefault
        end;

  if Editor.AnythingChanged then
  begin
  	tabel.repaint;
    AfterTagChanged;
    if pref.AutoResizeColumnHeaders.Checked then
      AutoResizeAllColumnsToFit;
    winplaylist.repaint;
    updateTree(true)
  end;

  Editor.release;
  Editor := nil;
  for i:=0 to TempRecList.count-1 do
  	disposeRec(rec);
  TempRecList.free;
  Dec(SafeToAutoScanCount)
end;

procedure TMainForm.updateTopImageBuffer;
const
	aso:string='...';   //aso = "and so on"
var
	maxWidth, textWidth:integer;
	textX:integer;
	s:string;
begin
	if Quitting or TopImagePainting then
		exit;

	TopImagePainting := true;

	try
    with topImageBuffer.Canvas.Font do
    begin
      Name := 'Arial';
      Size := 7;
      Color := CaptionStatusTextColor
    end;

    topImageBuffer.Width := clientWidth;
    topImageBuffer.Height := iUp.Height;

    if length(TopImageText)=0 then //der tegnes alm. logo
    begin
      if appActivated then
      begin
        TileDraw(topImageBuffer.Canvas, iUp, rect(iUpLeft.Width, 0, topImageBuffer.Width - iUpRight.Width, topImageBuffer.Height));
        topImageBuffer.Canvas.Draw((clientWidth div 2)-(iarc.width div 2), 0, iarc)
      end else
      begin
        TileDraw(topImageBuffer.Canvas, iUpShade, rect(iUpLeft.Width, 0, topImageBuffer.Width - iUpRight.Width, topImageBuffer.Height));
        topImageBuffer.Canvas.Draw((Clientwidth div 2)-(iarcShade.width div 2), 0, iarcShade)
      end
    end else //tegner tekst
    begin
      TextX := iUpLeft.Width + 6;
      s := TopImageText;
      SetBkMode(topImageBuffer.Canvas.Handle, TRANSPARENT);
      maxWidth := clientWidth - TextX - iUpRight.Width - 6;
      textWidth := topImageBuffer.Canvas.TextWidth(s);
      if textWidth > maxWidth then
      begin //afkoter strengen : c:\mp3\mommo\ao...
        repeat
          Q_CutRight(s, 2);
          textWidth := topImageBuffer.Canvas.TextWidth(s + aso);
        until textWidth <= maxWidth;
        s := s+aso
      end;
      //tegner baren:
      //blank
      TileDraw(topImageBuffer.Canvas, iUpBlank, rect(iUpLeft.Width, 0, textX + textWidth + 6 + iUpLeft.Width, iUp.Height));

      if appActivated then
        TileDraw(topImageBuffer.Canvas, iUp, rect(textX + textWidth + 6 + iUpLeft.Width, 0, topImageBuffer.Width - iUpRight.Width, topImageBuffer.Height))
      else
        TileDraw(topImageBuffer.Canvas, iUpShade, rect(textX + textWidth + 6, 0, topImageBuffer.Width - iUpRight.Width, topImageBuffer.Height));

      topImageBuffer.Canvas.TextOut(textX, 3, s);
    end;

    if appActivated then
    begin
      TopImageBuffer.Canvas.Draw(0, 0, iUpLeft);
      TopImageBuffer.Canvas.Draw(clientWidth - iUpRight.Width, 0, iUpRight)
    end else
    begin
      TopImageBuffer.Canvas.Draw(0, 0, iUpLeftShade);
      TopImageBuffer.Canvas.Draw(clientWidth - iUpRightShade.Width, 0, iUpRightShade)
    end;
  except
  end;
  TopImagePainting := false
end;

procedure TMainForm.ToggleKill1Click(Sender: TObject);
var       aNode:PVirtualNode;
          kill:byte;
begin
		 ToggleKill1.checked := not ToggleKill1.checked;
     if not ToggleKill1.checked then
				kill := Kill_None
		 else kill := Kill_del;

     winplaylist.Beginupdate;
     aNode := winplaylist.GetFirstSelected;
     while aNode <> nil do
     begin
          PplstRec(Winplaylist.GetNodeData(aNode)).Kill := kill;
          aNode := winplaylist.GetNextSelected(aNode)
     end;
     winplaylist.Endupdate
end;

procedure TMainForm.WaitForAutoScan;
begin
	if autoScanThread.Runing then
  begin
  	autoScanThread.Thread.Terminate;
    autoScanThread.Thread.WaitFor
  end;
end;

procedure TMainForm.AutoscanThreadExecute(Sender: TObject; Thread: TBMDExecuteThread; var Data: Pointer);
var       filenames:TQ_Stringlist;
          i, x:integer;
          newFilename:String;
          rec, rec2:Prec;
          Pt3rec:PautoScan3ButRec;
          DirList: TStrings;
begin
  DirList := Data;
 	if SafeToAutoScanCount < 0 then
  	SafeToAutoScanCount := 0;
	if SafeToAutoScanCount = 0 then
	begin
     AutoScanInProcess := true;
		 filenames := TQ_Stringlist.create;

     SpyFF.fileparams.FileMasks.Clear;
     SpyFF.fileparams.FileMasks.add('*.m3u');
     for i:=0 to length(audioTypes)-1 do
     	for x:=0 to length(audioTypes[i].ext)-1 do
      	SpyFF.fileparams.FileMasks.add('*' + audioTypes[i].ext[x]);
     SpyFF.Files.Clear;

      if not Assigned(DirList) then
      begin   //spy
        TopImageText := GetText(TXT_SearchForFiles);
        thread.Synchronize(UpdateTopImage);

        DirList := TStrings.Create;

        // copy changed paths to local list
        ChangedDirsToAutoScanLock.Enter;
        try
          DirList.AddStrings(ChangedDirsToAutoScan);
          ChangedDirsToAutoScan.Clear;
        finally
          ChangedDirsToAutoScanLock.Leave;
        end
      end;

      sleep(2000);
      for i:=0 to DirList.count-1 do
        if directoryexists(DirList.Strings[i]) then
        begin
          if pref.AutoScanSub.checked then
            SpyFF.DirOption := doIncludeSubDirs
          else
            SpyFF.DirOption := doExcludeSubDirs;
            SpyFF.RootDirectory := DirList.Strings[i];
            SpyFF.Search;

            for x:=0 to SpyFF.Files.count-1 do
              filenames.add(SpyFF.Files.Strings[x]);
            SpyFF.Files.clear
        end;

     for i:=0 to filenames.count-1 do
     begin
         if Thread.Terminated or (SafeToAutoScanCount <> 0) then
         begin
							AutoScanInProcess := false;
              TopImageText := '';
							thread.Synchronize(UpdateTopImage);
              break
         end
         else
         if not Q_SameText('.m3u', GetFileExt(filenames.strings[i])) and OkToAutoScan(filenames.strings[i]) then
         begin
							TopImageText := GetText(TXT_ScanningEx,  [filenames.strings[i]]);
              thread.Synchronize(UpdateTopImage);
              new(rec);
              FillChar(rec^, SizeOf(rec^), #0);
              rec.DatabaseTime := DateTimeToFileDate(now);
              if readId3(Thread, filenames.strings[i], getFilePath(filenames.strings[i]), master_DirSpy, 0, rec, true, filenames) then
              begin
              	Include(rec.Flags, rfAutoScanned);
              	if pref.AutoScanMoveToPath.text <> '' then
                begin
                        newFilename := FilenameFromPattern(rec, trim(pref.AutoScanMoveToPath.text), '');
                        TopImageText := GetText(TXT_MovingFromTo, [filenames.strings[i], newFilename]);
                        thread.Synchronize(UpdateTopImage);

                        if not fileexists(newFilename) and forcedirectories(getFilePath(newFilename)) and moveFile(pchar(getFtextP(rec, fFilename)), pchar(newFilename)) then
                        begin
                        	fileUndoList.Add(createOpUndo(otMove, getFtextP(rec, fFilename), newFilename));
                          BeginSetArtistAlbumFilename;
                          try
                             setFilename(rec, newFilename, false);
                          finally
                          	EndSetArtistAlbumFilename
                          end;
                          rec.LastWriteTime := FileAge(newFilename);
                        end
                        else
                        begin
                             if fileexists(newFilename) then
                             begin
                                  new(Pt3rec);
                                  Pt3rec.fname := getFtextP(rec, fFilename);
                                  Pt3rec.newName := newFilename;
                                  Pt3rec.result := rrUndef;
																	thread.Synchronize(threadShowMoveOptions, Pt3rec);

                                  case Pt3rec.result of
                                  rrRename:   // rename Targetfilename (not targetFile)
                                  begin
                             				forceDirectories(getfilePath(Pt3rec.newName));
                                    if MoveFileX(getFtextP(rec, fFilename), Pt3rec.newName, false) then
                                    begin
                                    	fileUndoList.Add(createOpUndo(otMove, getFtextP(rec, fFilename), Pt3rec.newName));
                                      BeginSetArtistAlbumFilename;
                                      try
                                      	setFilename(rec, Pt3rec.newName, false)
                                      finally
                                       	EndSetArtistAlbumFilename
                                      end;
                                      rec.LastWriteTime := FileAge(pt3rec.newName);
                                    end
                                    else
                                    begin
                                    	thread.Synchronize(threadShowMoveError, Pt3rec);
                                      dispose(rec);
                                      rec := nil
                                    end
                                  end;
                                  rrOverwrite:   // Overwrite Target
                                  begin
                                       rec2 := findInReclist(newFilename);
                                       if assigned(rec2) then   //fjerner gammel instance
                                       begin
                                       	 Include(rec2.Flags, rfDeletePending)
                                       		//releaseRec(rec2, true);
                                        	//reclist.Delete(reclist.IndexOf(rec2))
                                       end;
																			 if MoveFileX(getFtextP(rec, fFilename), newFilename, true) then
                                       begin
                                       		fileUndoList.Add(createOpUndo(otMove, getFtextP(rec, fFilename), newFilename));
                                          BeginSetArtistAlbumFilename;
                                          try
                                          	setFilename(rec, newFilename, false)
                                          finally
                                          	EndSetArtistAlbumFilename
                                          end;
                                          rec.LastWriteTime := FileAge(newFilename);
                                       end
                                       else
                                       begin
                                            thread.Synchronize(threadShowMoveError, Pt3rec);
                                            dispose(rec);
                                            rec := nil
                                       end
                                  end;
                                  rrDelete:  // Delete Source
                                  begin
                                       if not FileDeleteRB(getFtextP(rec, fFilename)) then
                                       begin
                                            thread.Synchronize(threadShowMoveError, Pt3rec)
                                       end;
                                       dispose(rec);
                                       rec := nil
                                  end;
                                  rrCancel:  // Cancel
                                  begin
                                       dispose(rec);
                                       rec := nil
                                  end end;
                                  dispose(pt3rec)
                             end
                             else
                             begin
                                  dispose(rec);
                                  rec := nil
                             end
                        end
                   end;
                   if assigned(rec) then
                   	AddRecList.add(rec)
              end
              else dispose(rec)
         end
     end;
     thread.Synchronize(AfterAutoScanThread, nil);
     filenames.free;
     TopImageText := '';
     thread.Synchronize(UpdateTopImage);
     dirSpyTimer.Enabled := QueSpyScan;
     QueSpyScan := false;
  end;

  if Assigned(DirList) then
  	DirList.Free;

  AutoScanInProcess := false
end;

procedure TMainForm.Ignoreduplicates1Click(Sender: TObject);
var       aNode, bNode, cNode:PVirtualNode;
          p1, p2:pointer;
          needUpdate, b:boolean;
begin
  Ignoreduplicates1.checked := not Ignoreduplicates1.checked;

  if Ignoreduplicates1.checked and (winplaylist.RootNodeCount>1) then
  begin
    screen.cursor := crHourglass;
    needUpdate := false;
    winplaylist.BeginUpdate;
    aNode := winplaylist.GetFirst;
    while assigned(aNode) do
    begin
      bNode := winplaylist.GetNext(aNode);
      while assigned(bNode) do
      begin
        p1 := winplaylist.GetNodeData(aNode);
        p2 := winplaylist.GetNodeData(bNode);
        if (PplstRec(p1).Rec = PplstRec(p2).Rec) and assigned(PplstRec(p1).Rec) and (PplstRec(p1).kill <> kill_conPlay) and (PplstRec(p2).kill <> kill_conPlay) then
        begin
          if PplstRec(p2).playing then
          	PplstRec(p1).playing := true;
          cNode := winplaylist.GetNext(bNode);
          WinplayDequeue(bNode);
          Winplaylist.DeleteNode(bNode);
          bNode := cNode;
          needUpdate := true
        end else bNode := winplaylist.GetNext(bNode)
      end;
      aNode := Winplaylist.GetNext(aNode)
    end;

    b := continuousPlay1.checked and CheckConPlay;
    if needUpdate or b then
    	winplaysave;

    winplaylist.EndUpdate;
    screen.cursor := crDefault
  end
end;

procedure TMainForm.Closewinamp1Click(Sender: TObject);
begin
  ToggleSystrayicon(true);
  hWnd_PL := findWindow('Winamp PE',nil);
  if hWnd_PL = 0 then
  begin
    quit; //den er get dd.. force quit
    halt(1)   //den onde terminate...
  end
  else
   PostMessage(hwnd_Winamp, WM_CLOSE, 0, 0)
end;

procedure TMainForm.Editcolumn1Click(Sender: TObject);
var       aNode:PVirtualNode;
					rec:Prec;
begin
	SequelTabelEditting := false;
  if (tabelCurrentColumn<0) or (tabel.SelectedCount<>1) then
  	exit;

  if not ((tabel.Header.Columns[tabelCurrentColumn].Tag in [fArtist, fArtistSortOrder, fTitle, fAlbum, ftrack, FTrackInfo, fYear, fComment, FPartOfSetText]) or (tabel.Header.Columns[tabelCurrentColumn].Tag >= FCustomField)) then
  	exit;

  aNode := tabel.GetFirstSelected;
  if assigned(aNode) then
  begin
    rec:=GetRec(aNode);
    if fileexists(getFtextP(rec, fFilename)) and getFileAccess(getFtextP(rec, fFilename), true, true, true) then
    begin
         tabelEditting := true;
         tabel.EditNode(aNode, tabelCurrentColumn);
         tabelEditting := false
    end
  end
end;

procedure TMainForm.tabelNewText(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; NewText: WideString);
function validTrack(s:String):boolean;
begin
     if tabel.Header.Columns[Column].Tag = ftrack then
        result := (s='') or Q_IsInteger(s)
     else result := true
end;
var
	rec:Prec;
  values : TtagValues;
  s:string;
  btPos: byte;
  TrackNo, TotalTracks: Integer;
begin
  s := NewText;
  Q_TrimInPlace(s);
  rec:=GetRec(Node);
  values := nil;
  if fileexists(getFtextP(rec, fFilename)) and getFileAccess(getFtextP(rec, fFilename), true, true, true) then
  begin
    if (tabel.Header.Columns[Column].Tag = FTrackInfo) then
    begin
    	TrackNo := GetTrackNoInt(s);
      TotalTracks := GetTotalTracksInt(s);
      if TrackNo <> rec.Track then
      begin
      	setLength(values, length(values)+1);
        values[length(values)-1].field := FTrack;
      	values[length(values)-1].value := IntToStr(TrackNo)
      end;
      if TotalTracks <> rec.TotalTracks then
      begin
      	setLength(values, length(values)+1);
        values[length(values)-1].field := FTotalTracks;
      	values[length(values)-1].value := IntToStr(TotalTracks)
      end
    end
    else

    if (tabel.Header.Columns[Column].Tag = FPartOfSetText) then
    begin
    	if SetPartOfSetFromString(btPos, s) and (btPos <> rec.PartOfSet) then
      begin
      	setLength(values, length(values)+1);
        values[length(values)-1].field := FPartOfSetText;
      	values[length(values)-1].value := s
      end
    end
    else

    if (tabel.Header.Columns[Column].Tag >= FCustomField) then
    begin
    	setLength(values, 1);
      values[0].field := FCustomField;
      values[0].customFieldIndex := tabel.Header.Columns[Column].Tag - FCustomField;
      values[0].value := s
    end else

    if (tabel.Header.Columns[Column].Tag in [fArtist, fTitle, fAlbum, ftrack, fYear, fComment, FArtistSortOrder]) and validTrack(s) then
    begin
      setLength(values, 1);
      values[0].field := tabel.Header.Columns[Column].Tag;
      values[0].value := s
    end;

  	if length(values) > 0 then
    begin
    	UpdateRecValues(rec, values, GetDefaultUpdateTags);
      tabel.RepaintNode(Node);
      AfterTagChanged
    end
  end;

  if pref.AutoResizeColumnHeaders.Checked then
  	AutoResizeAllColumnsToFit;

  if SequelTabelEditting then
  begin
	  Node := tabel.GetNextVisible(Node);
	  if assigned(Node) then
	  begin
	    tabel.ClearSelection;
	    tabel.Selected[Node] := true;
	    EditColumnSequalTimer.Enabled := true
	  end
  end
end;

procedure TMainForm.tabelEditing(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
begin
	if PartyMode1.Checked and pref.DisableTagging.Checked then
		Allowed := false
	else
		allowed := tabelEditting or SequelTabelEditting //sttes i EditColumn1Click
end;

procedure TMainForm.threadShowMoveOptions(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
function FormatFilename(fname:String):String;
begin
     result := fname + #13 + '(' + floattoStrF(GetFileSize(fname),ffnumber,8,0) + ' bytes)'
end;
var  Pt3rec:PautoScan3ButRec;

begin
	Pt3rec := data;
  Pt3rec.result := RenameDialog(GetText(TXT_FileAlreadyExists), pt3rec.fname, pt3rec.newname)
end;

procedure TMainForm.threadShowMoveError(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
var       Pt3rec:PautoScan3ButRec;
begin
     Pt3rec := data;
     case Pt3rec.result of
          rrOverwrite, rrRename: showmessageX(GetText(TXT_ErrorMovingCouldNotOVR, [#13 + Pt3rec.fname + #13, #13 + Pt3rec.newname + #13]), taCenter);
          rrDelete: showmessageX(GetText(TXT_CouldNotDeleteFile, [#13 + Pt3rec.fname]), taCenter)
     end
end;

procedure TMainForm.treeFreeNode(Sender: TBaseVirtualTree;
  Node: PVirtualNode);
begin
	finalize(PtreeRec(sender.GetNodeData(node))^)
end;

function TMainForm.LoadString(Fstr:TStream; length:integer):String;
var      s : array[0..MaxSavedChars] of char;
begin
   Fstr.Read(s, length);
   result := Q_CopyLeft(s, length)
end;

procedure TMainForm.Undo2Click(Sender: TObject);
{         format:
                 undoFileIdent    kun i starten af filen!
                 ---
                 total size:word = total size of the "record", excluding this word
                 opType:TopType
                 dateTime:TDateTime
                 stringLength:word
                 oldName:string
                 stringLength:word
                 newName:string}
function cloneUndoRec(UR:PfileUndoRec):PfileUndoRec;
begin
     new(result);
		 fillChar(result^, sizeOf(result^), #0);
		 result.canUndo := UR.canUndo;
     result.opType := UR.opType;
     result.dt := UR.dt;
     result.oldName := UR.oldName;
     result.newName := UR.newName
end;
var
   ULF:TundoListForm;
   Fstr:TStream;
   fn, s, oldName, newName:string;
   opType:TOpType;
   dt:TDateTime;
   w:word;
   count:integer;
   aNode:PVirtualNode;
   UR:PfileUndoRec;
   undoList:Tlist;
begin
     disableAOT;
     SaveOpUndos(fileUndoList, undoDir + autoScanFilename);
     if showOpenDialog(GetText(TXT_SelectUndoFile), '', undoDir, 'Undo files|*.undo', fn) and getFileAccess(fn, true, true) then
     begin
					Fstr := TFileStream.Create(fn, fmOpenReadWrite or fmShareDenyWrite);
					Fstr.Position := 0;
          if Fstr.Size>=length(undoFileIdent) then
             s := LoadString(Fstr, length(undoFileIdent))
             else s := '';
          if Q_SameText(s, undoFileIdent) then
          begin
               application.CreateForm(TundoListForm, ULF);
               ULF.tree.BeginUpdate;
               while Fstr.Position < Fstr.Size do
               begin
										Fstr.Read(w, sizeOf(w)); //hele tagget
										Fstr.Read(opType, sizeOf(opType));
                    if opType = otMove then
                    begin
                         //opTypen er supporteret
                         Fstr.Read(dt, SizeOf(dt));
                         Fstr.Read(w, sizeOf(w));
                         oldName := LoadString(Fstr, w);
                         Fstr.Read(w, sizeOf(w));
                         newName := LoadString(Fstr, w);

                         aNode := ULF.tree.AddChild(nil);
                         UR := ULF.tree.GetNodeData(aNode);

                         UR.canUndo := fileExists(newName);
                         UR.opType := opType;
                         UR.dt := dt;
                         UR.oldName := oldName;
                         UR.newName := newName;
                         ULF.tree.IsVisible[aNode] := UR.canUndo
                    end
                    else Fstr.Position := Fstr.Position + w - sizeOf(opType) //sger hen over taggen
               end;
               ULF.tree.SortTree(0, sdAscending);
               ULF.tree.EndUpdate;
               CurrentActiveForm := ULF;
               count := ULF.tree.RootNodeCount;
               if count > 0 then
                  ULF.ShowModal;
               CurrentActiveForm := nil;

               if count <> ULF.tree.RootNodeCount then
               begin
                    Fstr.Size := 0; //"sletter filen"
                    Fstr.free;
                    undoList := Tlist.Create;
                    aNode := ULF.tree.GetFirst;
                    while aNode <> nil do
                    begin
                         undoList.add(cloneUndoRec(ULF.tree.GetNodeData(aNode)));
                         aNode := ULF.tree.GetNext(aNode)
                    end;
                    saveOpUndos(undoList, fn);
                    undoList.free
               end else Fstr.free;
               ULF.Release;
               freeAndNil(ULF)
          end else Fstr.free
     end;
		 SetMainFormVisible(true)
end;

procedure TMainForm.Addentirelistandplayselected1Click(Sender: TObject);
begin
	pref.QuickListClick.itemindex := (sender as Tmenuitem).parent.IndexOf((sender as Tmenuitem))
end;

procedure TMainForm.qlsongspopPopup(Sender: TObject);
var       i:integer;
begin
	MoveUp1.Visible := true;
	MoveDown1.Visible := true;
	Delete1.Visible := true;
	Sort1.Visible := true;
	Shuffle1.Visible := true;

	for i:=0 to pref.quicklistClick.items.count-1 do
		Doubleclickoptions1.items[i].checked := i = pref.quicklistClick.ItemIndex;

	MoveUp1.Visible := MoveUp1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);
	MoveDown1.Visible := MoveDown1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);
	Delete1.Visible := Delete1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);
	Sort1.Visible := Sort1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked);
	Shuffle1.Visible := Shuffle1.Visible and not (PartyMode1.Checked and pref.DisableEditQuicklist.Checked)
end;

function CompareStringAndInt(Item1, Item2: Pointer): integer;
begin
	result := PStringAndInt(Item1).i - PStringAndInt(Item2).i
end;

{$ifdef MEXPBuilding}
procedure TMainForm.N17Click(Sender: TObject);
function isInArray(k:integer; list: TList):boolean;
var
	i:integer;
begin
	result := false;
  for i:=0 to list.Count-1 do
  	result := result or (PStringAndInt(list.items[i]).i = k)
end;
procedure AddMenuItem(mi:TMenuItem; list: TList);
var
	i:integer;
  si: PStringAndInt;
begin
  if (mi.tag<>0) then
  begin
    if isInArray(abs(mi.tag), list) then
    	showmessagex('Double: ' + inttostr(mi.tag) + ' - ' + mi.caption);
    new(si);
    si.s := mi.Caption;
    si.i := abs(mi.tag);
    list.Add(si);
    //s := inttostr(abs(mi.tag)) + '="' + mi.Caption + '"' + CRLF;
    //Fstr.Write(s[1], length(s));
    for i:=0 to mi.count-1 do
      AddMenuItem(mi.items[i], list)
  end
end;
var
	menu:TPopupMenu;
  i, k:integer;
  Fstr:TStream;
  s:string;
  arrPos:integer;                
  list: TList;
  si: PStringAndInt;
begin
  Fstr := TFileStream.Create('c:\english.mnu', fmCreate);
  list := TList.Create;
  s := Lan_MenuFileIdent + CRLF;
  Fstr.Write(s[1], length(s));
  for i:=0 to componentCount-1 do
    if components[i] is TPopupmenu then
    begin
      menu := TPopupMenu(components[i]);
      if menu.Tag = 0 then
      	continue;
      arrPos := 0;
      s := CRLF + '// Menu: ' + menu.Name + CRLF + '!BeginMenuID: ' + inttostr(menu.tag) + CRLF;
      Fstr.Write(s[1], length(s));

      for k:=0 to menu.items.count-1 do
      	AddMenuItem(menu.items[k], list);

      list.Sort(CompareStringAndInt);

      for k:=0 to list.Count-1 do
      begin
      	si := list.Items[k];
      	s := inttostr(si.i) + '="' + si.s + '"' + CRLF;
        FStr.Write(s[1], length(s));
        dispose(si)
      end;

      s := '!EndMenu' + CRLF;
      Fstr.Write(s[1], length(s));
      list.Clear
    end;
  list.free;
  Fstr.free
end;
{$endif MEXPBuilding}

procedure TMainForm.ArtistTitle1Click(Sender: TObject);
var
	aNode:PVirtualNode;
  recs, valuesList, rollbackValues: TList;
  values : PTagValues;
  rec:Prec;
begin
	//Swap title and artist
  recs := TList.Create;
  valuesList := TList.Create;
  rollBackValues := TList.Create;

	aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
    rec := GetRec(aNode);
    recs.Add(rec);

    New(values);
    setLength(values^, 2);
    values^[0].field := fArtist;
    values^[0].value := getFtextP(rec, fTitle);
    values^[1].field := fTitle;
    values^[1].value := getFtextP(rec, fArtist);
    valuesList.Add(values);

    //Rollback
    New(values);
    setLength(values^, 2);
    values^[0].field := fArtist;
    values^[0].value := getFtextP(rec, fArtist);
    values^[1].field := fTitle;
    values^[1].value := getFtextP(rec, fTitle);
    rollBackValues.Add(values);

    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecValues(recs, valuesList, rollBackValues, 'Tagging...', true, GetDefaultUpdateTags);

  AfterTagChanged;
  if pref.AutoResizeColumnHeaders.Checked then
	  AutoResizeAllColumnsToFit;
end;

procedure TMainForm.ArtistAlbum1Click(Sender: TObject);
var
	aNode:PVirtualNode;
  recs, valuesList, rollbackValues: TList;
  values : PTagValues;
  rec:Prec;
begin
	//Swap artist with album
  recs := TList.Create;
  valuesList := TList.Create;
  rollBackValues := TList.Create;


  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
    rec := GetRec(aNode);
    recs.Add(rec);

    New(values);
    setLength(values^, 2);
    values^[0].field := fArtist;
    values^[0].value := getFtextP(rec, fAlbum);
    values^[1].field := fAlbum;
    values^[1].value := getFtextP(rec, fArtist);
    valuesList.Add(values);

    //Rollback
    New(values);
    setLength(values^, 2);
    values^[0].field := fArtist;
    values^[0].value := getFtextP(rec, fArtist);
    values^[1].field := fAlbum;
    values^[1].value := getFtextP(rec, fAlbum);
    rollBackValues.Add(values);

    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecValues(recs, valuesList, rollBackValues, 'Tagging...', true, GetDefaultUpdateTags);

	AfterTagChanged;
	if pref.AutoResizeColumnHeaders.Checked then
		AutoResizeAllColumnsToFit
end;
procedure TMainForm.AlbumTitle1Click(Sender: TObject);
var
	aNode:PVirtualNode;
  recs, valuesList, rollbackValues: TList;
  values : PTagValues;
  rec:Prec;
begin
	//Swap title and Album
  recs := TList.Create;
  valuesList := TList.Create;
  rollBackValues := TList.Create;

	aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
    rec := GetRec(aNode);
    recs.Add(rec);

    New(values);
    setLength(values^, 2);
    values^[0].field := fAlbum;
    values^[0].value := getFtextP(rec, fTitle);
    values^[1].field := fTitle;
    values^[1].value := getFtextP(rec, fAlbum);
    valuesList.Add(values);

    //Rollback
    New(values);
    setLength(values^, 2);
    values^[0].field := fAlbum;
    values^[0].value := getFtextP(rec, fAlbum);
    values^[1].field := fTitle;
    values^[1].value := getFtextP(rec, fTitle);
    rollBackValues.Add(values);

    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecValues(recs, valuesList, rollBackValues, 'Tagging...', true, GetDefaultUpdateTags);

  AfterTagChanged;
  if pref.AutoResizeColumnHeaders.Checked then
	  AutoResizeAllColumnsToFit;
end;

procedure TMainForm.WriteId3v11Click(Sender: TObject);
begin
	WriteSelectedTagsToFiles(UpdateRecTagOption_UpdateElseCreate, UpdateRecTagOption_DontUpdate, UpdateRecTagOption_DontUpdate, UpdateRecTagOption_DontUpdate, UpdateRecTagOption_DontUpdate)
end;

procedure TMainForm.WriteId3v21Click(Sender: TObject);
begin
	WriteSelectedTagsToFiles(UpdateRecTagOption_DontUpdate, UpdateRecTagOption_UpdateElseCreate, UpdateRecTagOption_DontUpdate, UpdateRecTagOption_DontUpdate, UpdateRecTagOption_DontUpdate)
end;

procedure TMainForm.Onlyshowaviablefiles1Click(Sender: TObject);
begin
	Onlyshowaviablefiles1.Checked := not Onlyshowaviablefiles1.Checked;
  showHideNodes
end;

procedure TMainForm.f0KeyPress(Sender: TObject; var Key: Char);
begin
     if ord(key) = 127 then
        key := char(VK_RETURN)
end;

procedure TMainForm.Organizefiles2Click(Sender: TObject);
var       aNode:PVirtualNode;
begin
		 disableAOT;
     Application.CreateForm(TOrgFiles, OrgFiles);

     aNode := tabel.GetFirstSelected;
     while aNode <> nil do
     begin
          OrgFiles.list.Add(getRec(aNode));
          aNode := tabel.GetNextSelected(aNode)
     end;

     CurrentActiveForm := Orgfiles;
     if OrgFiles.init then
				OrgFiles.showmodal;
		 CurrentActiveForm := nil;
		 OrgFiles.release;
		 FreeAndNil(OrgFiles);
     UpdateHashedReclist;
		 updateTree(true);
     SaveAllNoRelease(true);
		 SetMainFormVisible(true)
end;

procedure TMainForm.Cuttag1Click(Sender: TObject);
var
	tagCutter : TTagCutter;
  aNode : PVirtualNode;
  selected: array of PVirtualNode;
  i:integer;
begin
  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  Application.CreateForm(TTagCutter, tagCutter);

  tabel.BeginUpdate;

  SetLength(selected, tabel.SelectedCount);  //gemmer de valgte noder
	i := 0;
  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
    tagCutter.list.Add(GetRec(aNode));
    selected[i] := aNode;
   	inc(i);
    aNode := tabel.GetNextSelected(aNode)
  end;
  CurrentActiveForm := TagCutter;
  if tagCutter.list.count > 0 then
  tagCutter.ShowModal;
  CurrentActiveForm := nil;
  tagCutter.Release;
  FreeAndNil(tagCutter);
  
  AfterTagChanged;

  if pref.AutoResizeColumnHeaders.Checked then
    AutoResizeAllColumnsToFit;

  updateTree(true);

  tabel.ClearSelection;
  for i:=0 to length(selected)-1 do
    if NodeBelongsToTree(selected[i], tabel,true) and tabel.IsVisible[selected[i]] then
      tabel.Selected[selected[i]] := true;
  tabel.EndUpdate;

  Dec(SafeToAutoScanCount);
end;

procedure TMainForm.WriteSelectedTagsToFiles(id3v1Opt:UpdateRecTagOption; id3v2opt:UpdateRecTagOption; ApeOpt:UpdateRecTagOption; WmaOpt:UpdateRecTagOption; OggOpt:UpdateRecTagOption);
var
	aNode:PVirtualNode;
  values : PTagValues;
  rec:Prec;
  recs, valuesList: TList;
begin
  recs := TList.Create;		//These are free'd in updateRecvaluesMethod
  valuesList := TList.Create;			//These are free'd in updateRecvaluesMethod

  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
    rec := GetRec(aNode);
    recs.Add(rec);

    New(values);
    setLength(values^, 11);
    values^[0].field := fArtist;
    values^[0].value := getFtextP(rec, fArtist);

    values^[1].field := fTitle;
    values^[1].value := getFtextP(rec, fTitle);

    values^[2].field := fAlbum;
    values^[2].value := getFtextP(rec, fAlbum);

    values^[3].field := fTrack;
    values^[3].value := getFtextP(rec, fTrack);

    values^[4].field := fComment;
    values^[4].value := getFtextP(rec, fComment);

    values^[5].field := fYear;
    values^[5].value := getFtextP(rec, fYear);

    values^[6].field := fGenre;
    values^[6].value := getFTextP(rec, fGenre);

    values^[7].field := fCompilation;
    if rfCompilation in rec.Flags then
    	values^[7].value := '1' else values^[7].value := '0';

    values^[8].field := FTotalTracks;
    values^[8].value := GetFTextP(rec, FTotalTracks);

    values^[9].field := FPartOfSetText;
    values^[9].value := GetFTextP(rec, FPartOfSetText);

    values^[10].field := FRating;
    values^[10].value := inttostr(rec.rating);
    //TODO: Add custom fields
    valuesList.Add(values);

    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecvalues(recs, valuesList, nil, 'Tagging...', true, id3v1Opt, id3v2Opt, ApeOpt, WmaOpt, OggOpt);
end;

procedure TMainForm.CDDB1Click(Sender: TObject);
var
  cddbForm : TCddbForm;
  aNode : PVirtualNode;
	selected: array of PVirtualNode;
  i:integer;
begin
  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  application.CreateForm(TCddbForm, cddbForm);

  tabel.BeginUpdate;

  SetLength(selected, tabel.SelectedCount);  //gemmer de valgte noder

	i := 0;
  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
    cddbForm.list.Add(GetRec(aNode));
    selected[i] := aNode;
   	inc(i);
    aNode := tabel.GetNextSelected(aNode)
  end;
  if cddbForm.list.Count > 0 then
  begin
    cddbForm.Init;
    CurrentActiveForm := cddbForm;
    cddbForm.ShowModal;
    CurrentActiveForm := nil;
  end;
  cddbForm.Release;
  freeAndNil(cddbForm);
  AfterTagChanged;
  if pref.AutoResizeColumnHeaders.Checked then
	  AutoResizeAllColumnsToFit;
  updateTree(true);

  tabel.ClearSelection;
  for i:=0 to length(selected)-1 do
    if NodeBelongsToTree(selected[i], tabel,true) and tabel.IsVisible[selected[i]] then
      tabel.Selected[selected[i]] := true;
  tabel.EndUpdate;

  Dec(SafeToAutoScanCount);
end;


procedure TMainForm.FormShortCut(var Msg: TWMKey; var Handled: Boolean);
begin
     handled := true
end;

{procedure TMainForm.ApplicationEvents1Message(var Msg: tagMSG;
	var Handled: Boolean);
begin                   //denner er fjernet, da jeg mistnker den for at lave Access Violation nr jeg id3editor starter!!!
	handled := msg.message = WM_SYSCHAR  //forhindrer beep nr alt+2/3 trykkes
end;  }

procedure TMainForm.DuplicateWizard1Click(Sender: TObject);
var
   aNode : PVirtualNode;
begin
  screen.cursor := crhourglass;
  disableAOT;
  Application.CreateForm(TDubWizForm, DubWizForm);

  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
  	DubWizForm.list.Add(GetRec(aNode));
   	aNode := tabel.GetNextSelected(aNode)
  end;

  dubWizForm.ScanDubs(SLcrc);
  CurrentActiveForm := dubWizForm;
  dubwizform.showmodal;
  CurrentActiveForm := nil;
  RecListToTabel(true, true);
  ApplyFilter;
  dubwizForm.tree.clear;
  DubWizForm.release;
  FreeAndNil(DubWizForm);
  SaveAllNoRelease(true);
  screen.cursor := crdefault;
  SetMainFormVisible(true)
end;


procedure TMainForm.Compilation1Click(Sender: TObject);
var
   aNode:pVirtualNode;
   values : TtagValues;
   recs: TList;
begin
  screen.cursor := crHourglass;
  setLength(values, 1);
  values[0].field := fCompilation;
  if Compilation1.Checked then
  	values[0].value := '0'
  else
  	values[0].value := '1';

  recs := TList.Create;
  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
  	recs.Add(GetRec(aNode));
    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecValues(recs, values, 'Tagging...', true, GetDefaultUpdateTags);

  setLength(values, 0);
  AfterTagChanged;
  screen.cursor := crDefault
end;

procedure TMainForm.ToggleWinamp1Click(Sender: TObject);
begin
	if IsWinampMinimized then
		ShowWindow(hwnd_winamp, SW_RESTORE)
	else
	 SendMessage(hwnd_winamp, WM_COMMAND, 40258, 0)
end;

procedure TMainForm.TogglePlaylist1Click(Sender: TObject);
begin
	SendMessage(hwnd_winamp, WM_COMMAND, 40040, 0);
end;

procedure TMainForm.ToggleEqulizer1Click(Sender: TObject);
begin
	SendMessage(hwnd_winamp, WM_COMMAND, 40036, 0);
end;

procedure TMainForm.ShowWinampPreferences1Click(Sender: TObject);
begin
	SendMessage(hwnd_winamp, WM_COMMAND, 40012, 0);
end;

procedure TMainForm.StartVISplugin1Click(Sender: TObject);
begin
	SendMessage(hwnd_winamp, WM_COMMAND, 40192, 0);
end;

procedure TMainForm.ToggleVideo1Click(Sender: TObject);
begin
//	SendMessage(hwnd_winamp, WM_COMMAND, 40036, 0)
end;

procedure TMainForm.WPbarLowResize(Sender: TObject);
var
	x: Integer;
begin
	x := winplaylistTimeLabel.Canvas.TextWidth(winplaylistTimeLabel.Caption);
	winplaylistTimeLabel.SetBounds(Winplaylist.ClientWidth - x - 4, 0, x, winplaylistTimeLabel.Height);
	PaintFileInfoLabel
end;

procedure TMainForm.RepaintTopImage;
begin
  if Quitting then
  	exit;
	try
		updateTopImageBuffer;
		Canvas.Draw(0, 0, TopImageBuffer)
  except
  end
end;

procedure TMainForm.Scanforchanges1Click(Sender: TObject);
Function GetDatabaseRec(aNode: PVirtualNode): PTreeRec;
begin
	while aNode <> tree.RootNode do
  begin
		result := tree.GetNodeData(aNode);
    if result.kind in [TreeKind_Harddisk, TreeKind_CDROM, TreeKind_Network, TreeKind_Zip] then
    begin
    	if not result.Exists then
      	result := nil;
      exit
    end;
    aNode := aNode.Parent
  end;

  result := nil
end;

var
	aNode: PVirtualNode;
	TR : PtreeRec;
	ScanParams: PScanParameters;
  i, j: Integer;
  exists: boolean;
begin
	new(ScanParams);
	aNode := tree.GetFirstSelected;
  while aNode <> nil do
  begin
    TR := GetDatabaseRec(aNode);
    if assigned(TR) then
    begin
    	//Check if exists already
      exists := false;
      for j := 0 to length(ScanParams.arr)-1 do
      	exists := exists or Q_SameStr(ScanParams.arr[j].name, dbs[TR.Location].Name);
      if not exists then
      begin
        SetLength(ScanParams.arr, length(ScanParams.arr)+1);
        i := length(ScanParams.arr)-1;
        ScanParams.arr[i].master := master_ScanForChanges;
        ScanParams.arr[i].name := dbs[TR.location].Name;
        ScanParams.arr[i].CalculateCRC :=dbs[TR.location].CalculateCRC;
        ScanParams.arr[i].repairVBR := dbs[TR.Location].repairVBR;
        ScanParams.arr[i].onlyNew := true;
        ScanParams.arr[i].UpdateTreeAndTabel := true;
        ScanParams.arr[i].RunAfterScan := nil
      end
    end;
    aNode := tree.GetNextSelected(aNode)
  end;

  if length(ScanParams.arr) > 0 then
  begin
    TopImageText := GetText(TXT_PleaseWait);
    RepaintTopImage;
  	ScanParams.arr[i].RunAfterScan := RunAfterScanForChanges;
    {$ifdef ScanInMainThread}
    ScanThreadExecute(nil, nil, Pointer(ScanParams));
    {$else}
    ScanThread.Start(ScanParams);
    {$endif}

  end else
  	Dispose(ScanParams)
end;

procedure TMainForm.RunAfterScanForChanges(Sender: TObject);
begin
	TopImageText := '';
	RepaintTopImage
end;

procedure TMainForm.Editcolumnsequal1Click(Sender: TObject);
var       aNode:PVirtualNode;
					rec:Prec;
begin
	if (tabelCurrentColumn<0) or (tabel.SelectedCount<>1) then exit;
	if (tabel.Header.Columns[tabelCurrentColumn].Tag in [fArtist, fartistSortOrder, fTitle, fAlbum, ftrack, FTrackInfo, fYear, fComment]) or (tabel.Header.Columns[tabelCurrentColumn].Tag >= FCustomField) then
  begin
    aNode := tabel.GetFirstSelected;
    if assigned(aNode) then
    begin
      rec:=GetRec(aNode);
      if fileexists(getFtextP(rec, fFilename)) and getFileAccess(getFtextP(rec, fFilename), true, true, true) then
      begin
        SequelTabelEditting := true;
        tabel.EditNode(aNode, tabelCurrentColumn);
        //tabelEditting := false
      end
    end
  end
end;

procedure TMainForm.EditColumnSequalTimerTimer(Sender: TObject);
begin
  EditColumnSequalTimer.Enabled := false;
	Editcolumnsequal1Click(nil)
end;

procedure TMainForm.playlistboxPaintText(Sender: TBaseVirtualTree;
	const TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  TextType: TVSTTextType);
begin
	if vsSelected in node.states then
	begin
		if TargetCanvas.font.color <> PlaylistboxSelTextColor then
			TargetCanvas.font.color := PlaylistboxSelTextColor
	end
end;

procedure TMainForm.plConPaintText(Sender: TBaseVirtualTree;
  const TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
	TextType: TVSTTextType);
begin
	if vsSelected in node.states then
	begin
		if TargetCanvas.font.color <> plconSelTextColor then
			TargetCanvas.font.color := plconSelTextColor
	end   
end;

procedure TMainForm.ScanThreadExecute(Sender: TObject;
	Thread: TBMDExecuteThread; var Data: Pointer);
var
	ScanParams: PScanParameters;
  i: integer;
begin
	ScanParams := data;
  for i:=0 to length(ScanParams.arr)-1 do
		Scan(ScanParams.arr[i].master, ScanParams.arr[i].name, Thread, ScanParams.arr[i].onlyNew, ScanParams.arr[i].CalculateCRC, ScanParams.arr[i].repairVBR, ScanParams.arr[i].UpdateTreeAndTabel);

  for i:=0 to length(ScanParams.arr)-1 do
		if assigned(ScanParams.arr[i].RunAfterScan) then
			ScanParams.arr[i].RunAfterScan(nil);
      
  SetLength(ScanParams.arr, 0);
  Dispose(ScanParams)
end;

procedure TMainForm.ScanThreadShowUsePlaylistDialog(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
var
	askPlaylist : TAskUsePlaylistform;
	CurrentFormBackup : TForm;
	i, x: Integer;
begin
	Application.CreateForm(TaskUsePlaylistform, askPlaylist);
	for i:=0 to m3uList.Count-1 do
		if PplRec(m3uList.items[i]).UseToSuggest = useToSuggest_Undefined then
			askPlaylist.list.Items.Add(PplRec(m3uList.items[i]).Filename);

	if askPlaylist.list.items.Count > 0 then
	begin
		CurrentFormBackup := CurrentActiveForm;
		CurrentActiveForm := askPlaylist;
		askPlaylist.ShowModal;
		x := 0;
		for i:=0 to m3uList.Count-1 do
			if PplRec(m3uList.items[i]).UseToSuggest = useToSuggest_Undefined then
			begin
				if askPlaylist.list.Checked[x] then
					PplRec(m3uList.items[i]).UseToSuggest := useToSuggest_use
				else PplRec(m3uList.items[i]).UseToSuggest := useToSuggest_notUse;
				inc(x)
			end
	end;
	CurrentActiveForm := CurrentFormBackup;
	askPlaylist.Release;
	FreeAndNil(askPlaylist)
end;

procedure TMainForm.ThreadShowMessage(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
var
	p: PShowMessageParameters;
begin
	p := data;
	ShowmessageX(p.text, p.alignment)
end;

procedure TMainForm.DoBeforeScanSynced(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
begin
	if (pref.paths.Items.Count = 0) and (Integer(Data^) = master_MyMusic) then
	begin
		Integer(Data^) := 1;
		exit
	end
  	else
  		Integer(Data^) := 2;

	pref.loadinglabel.visible:=true;
	if dbpref <> nil then dbpref.loadinglabel.visible:=true;

	pref.pbar.position:=0;
	if dbpref <> nil then dbpref.pbar.position:=0;

	dirspyTimer.enabled := false;
	if autoScanThread.Runing then
		autoScanThread.Thread.WaitFor;

	MoveAddRecListToReclist;
end;

procedure TMainForm.DoAfterScanSynced(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
begin
  if boolean(data) then
  	updateTree(false);
	sliderr.visible:=true;
	WinplaylistCurrentTimeLabel.Visible := true;
	tabelpanel.visible:=true;
	screen.Cursor:=crdefault
end;

procedure TMainForm.TreeScrollHGetImage(Sender: TObject;
	Horizontal: Boolean; index: Integer; out bitmap: TBitmap);
begin
	if index > 3 then	//bitmapped scrollbar
		inc(index, 3);
		
	if not Horizontal then
		inc(index, 3);
	bitmap := ScrollBarImgs[index]
end;

procedure TMainForm.imglowerleftMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	tabel.setFocus
end;

procedure TMainForm.FormMouseDown(Sender: TObject; Button: TMouseButton;
	Shift: TShiftState; X, Y: Integer);
function VolumeBarClicked(x: Integer):Boolean;
var
	percent: single;
begin
	percent := ((x-(imgVolSliderBtn.Width div 2)) / max(1,(VolbarWidth - imgVolSliderBtn.Width)));
	result := setVolume(percent)
end;

var
	i: Integer;
	r2:Trect;
	b: Boolean;
	LowRightPoint, LowLeftPoint: TPoint;
begin
	if not PartyMode1.Checked and (x > clientWidth - iUpRight.Width -2) and (y < 10) then      //normalize/close
	begin
		systemParametersInfo(SPI_GETWORKAREA, 0, @r2, 1);
		MainFormInstance.Constraints.maxheight := 0;//r2.Bottom-r2.Top;
		MainFormInstance.Constraints.MaxWidth := 0;//r2.Right - r2.left;

		i := x - clientWidth + iUpRight.Width;
		//maximize/normalize?
		if i in [6..14] then
		begin
			SwitchMaximized;
			exit
		end else
		//"close"
		if i in[15..27] then
			SetMainFormVisible(false)
	end
	else
  if clientHeight = WindowShadeHeight then
  	Image1MouseDown(Sender, Button, Shift, x, y) //"Caption" drag
  else
	begin
		//test shuffle/repeat /config etc
		LowRightPoint := Point(x - (clientWidth - imgLowerRight.Width), y - (clientHeight - imgLowerRight.Height));
		LowLeftPoint := Point(x, y - (clientHeight - imgLowerLeft.Height));

		b := false; //repaint-flag

		//Test volume bar
		if PtInRect(Rect(VolbarImgPos.x, VolbarImgPos.y, VolbarImgPos.x + VolbarWidth, VolbarImgPos.y + ImgVolSliderBtn.Height), LowRightPoint) then
    	if not (partymode1.Checked and pref.PartyDisableVolumeControl.Checked) then
      begin
        if VolumeBarClicked(x - clientWidth + imgLowerRight.Width - VolbarImgPos.x) then
        	VolBarPaint(sender, Canvas);
        SetCapture(Canvas.Handle);
        Capturing := true
      end else
    else

		//Shuffle
		if PtInRect(Rect(ShuffleImgPos.x, ShuffleImgPos.y, ShuffleImgPos.x + imgShuffle.Width, ShuffleImgPos.y + imgShuffle.Height), LowRightPoint) then
		begin
    	ShuffleEnabled := not ShuffleEnabled;
      if pref.ControlPlaylist.Checked then
      	ValidateWinplaylist(-1)
      else
				SendMessage(hwnd_winamp,WM_COMMAND,40023,0);
			b := true
		end else

		//Repeat
		if PtInRect(Rect(RepeatImgPos.x, RepeatImgPos.y, RepeatImgPos.x + imgRepeat.Width, RepeatImgPos.y + imgRepeat.Height), LowRightPoint) then
		begin
			SendMessage(hwnd_winamp,WM_COMMAND,40022,0);
			RepeatEnabled := not RepeatEnabled;
			b := true
		end else

		//Config
		if PtInRect(Rect(ConfigImgPos.x, ConfigImgPos.y, ConfigImgPos.x + imgConfig.Width, ConfigImgPos.y + imgConfig.Height), LowRightPoint) then
		begin
			ConfigImageShown := true;
			VolBarPaint(nil, Canvas);
			ConfigMenu.Popup(Mouse.CursorPos.x, Mouse.CursorPos.Y)
		end

		else

		//test p playlist controls
    if not (partyMode1.Checked and pref.PartyDisablePlaybackControls.Checked) then
      if PtInRect(PrevRect, LowLeftPoint) then //Previous
        prevMouseDown(Sender, Button, Shift, x, y)
      else
      if PtInRect(PlayRect, LowLeftPoint) then //play
        playMouseDown(Sender, Button, Shift, x, y)
      else
      if PtInRect(PauseRect, LowLeftPoint) then //Pause
        button3(hwnd_winamp)
      else
      if PtInRect(StopRect, LowLeftPoint) then //Stop
        StopMouseDown(Sender, Button, Shift, x, y)
      else
      if PtInRect(NextRect, LowLeftPoint) then   //Next
        nxtMouseDown(Sender, Button, Shift, x, y)

		else
			Image1MouseDown(Sender, Button, Shift, x, y); //"Caption" drag

		if b then
			VolBarPaint(nil, Canvas)
	end
end;

procedure TMainForm.FormMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
procedure VolumeBarPulled(x: Integer);
var
	percent: single;
begin
	percent := ((x-(imgVolSliderBtn.Width div 2)) / max(1,(VolbarWidth - imgVolSliderBtn.Width)));
	if SetVolume(percent) then
  	VolBarPaint(sender, Canvas)
end;

begin
	if clientHeight <> WindowShadeHeight then
  begin
  	FixRatingPainting(winplaylist);
    FixRatingPainting(tabel);

    //Volume bar
    if (ssleft in Shift) and (Capturing or (PtInRect(Rect(VolbarImgPos.x, VolbarImgPos.y, VolbarImgPos.x + VolbarWidth, VolbarImgPos.y + ImgVolSliderBtn.Height), Point(x - (clientWidth - imgLowerRight.Width), y - (clientHeight - imgLowerRight.Height))))) and not (partymode1.Checked and pref.PartyDisableVolumeControl.Checked) then
      VolumeBarPulled(x - clientWidth + imgLowerRight.Width -  VolbarImgPos.x);

    Hint := '';
    if pref.showhnt.Checked then
    begin
      y := y - clientHeight + imgLowerRight.Height;
      if y in [9..25] then
        begin
        if x in [11..30] then //Rewind
          Hint := GetText(TXT_PreviousHint)
        else
        if x in [33..48] then //play
          Hint := GetText(TXT_PlayHint)
        else
        if x in [97..116] then
          Hint := GetText(TXT_NextHint)
      end
    end
  end
end;

procedure TMainForm.FormDblClick(Sender: TObject);
var
	pt: Tpoint;
begin
	if PartyMode1.Checked then
		exit;
		
	pt := MainFormInstance.ScreenToClient(mouse.Cursorpos);
	if (pt.y in [0..12]) and (pt.x > 10) and (pt.x < clientWidth - iUpRight.Width) then
		WindowShadeClicked
end;

procedure TMainForm.volbarPaint(Sender: TObject; Canvas: TCanvas);
// Draws volume slider and shuffle/repeat
var
	temp: TBitmap;
	percent:single;
	x, vx, y: Integer;
begin
	if not assigned(imgLowerRight) or (MainFormInstance.clientheight = WindowShadeHeight) then
  	exit;
	x := ClientWidth - imgLowerRight.Width;
	y := ClientHeight - imgLowerRight.Height;
	try
		percent := 1;
		try
			percent := GetVolume;
			if percent > 1 then
				percent := 1;
			if percent < 0 then
				percent := 0;
		except end; //do nothing

		temp := TBitmap.Create;
		temp.Width := imgLowerRight.Width;
		temp.Height := imgLowerRight.Height;

		//tegner baggrunden
		temp.canvas.Draw(0, 0, imgLowerRight);

		//shufle
		if ShuffleEnabled then
			temp.canvas.Draw(ShuffleImgPos.x, ShuffleImgPos.y, imgShuffle);

		//repeat
		if repeatEnabled then
			temp.canvas.Draw(RepeatImgPos.x, RepeatImgPos.y, imgRepeat);

		//configbutton
		if ConfigImageShown then
			temp.canvas.Draw(ConfigImgPos.x, ConfigImgPos.y, imgconfig);

		//tegner volumesliderbaren
		vx := Trunc((VolbarWidth - imgVolSliderBtn.Width) * percent);
		temp.canvas.Draw(VolbarImgPos.x + vx, VolbarImgPos.y, imgVolSliderBtn);

		canvas.Draw(x, y, temp);

		temp.free;

    FPaintedVolume := percent;
	except //do nothing
	end
end;

procedure TMainForm.prepareCurPlayText(paint, update: boolean);
var
  img: TBitmap;
  h, w, i: integer;
  x: Int64;
begin
	if FCurPlayScrolling or update then
  begin
    w := FCurPlayBitmap.Canvas.TextWidth(FCurPlayText);
    h := FCurPlayBitmap.Canvas.TextHeight(FCurPlayText);
    FCurPlayRect.Bottom := FCurPlayRect.Top + h;

    //fylder FCurPlayBitmap
    FCurPlayBitmap.Width := FCurPlayRect.Right - FCurPlayRect.Left;
    FCurPlayBitmap.Height := h;
    if MainFormInstance.ClientWidth > SmallWindowLimit then
    begin
      img := TBitmap.Create;
      img.Width := imgLower.Width;
      img.Height := h;
      i := (clientheight - 36) - (clientHeight - imgLower.Height);
      img.Canvas.Draw(0, -i, imgLower);
      TileDraw(FCurPlayBitmap.Canvas, img, rect(0, 0, FCurPlayBitmap.Width, FCurPlayBitmap.Height));
      img.free
    end
    else
    begin
      FCurPlayBitmap.Canvas.brush.Color := LowerSmallPanel.Color;
      FCurPlayBitmap.Canvas.FillRect(rect(0, 0, FCurPlayBitmap.Width, FCurPlayBitmap.Height))
    end;

    FCurPlayBitmap.Canvas.brush.Style := bsClear;

    if FCurPlayBitmap.Width < w then
    begin	//der skal scrolles
      FCurPlayScrolling := true;
      x := -((int64(GetTickCount)-int64(FCurPlayXPos)) div 50);
      if x <= -(w) then
      begin
        x := 0;
        FCurPlayXPos := GetTickCount
      end;
      while x < FCurPlayBitmap.Width do
      begin
        FCurPlayBitmap.Canvas.TextRect(rect(0, 0, FCurPlayBitmap.Width, FCurPlayBitmap.Height), x, 0, FCurPlayText);
        inc(x, w +10)
      end
    end
    else
    begin
      FCurPlayXPos := GetTickCount;
      FCurPlayScrolling := false;
      FCurPlayBitmap.Canvas.TextOut(FCurPlayBitmap.Width div 2 - w div 2 ,0, FCurPlayText)
    end
  end;

  if (paint and FCurPlayScrolling) or update then
  	if MainFormInstance.ClientWidth > SmallWindowLimit then
    	MainFormInstance.Canvas.Draw(FCurPlayRect.Left, FCurPlayRect.Top, FCurPlayBitmap)
		else
    	LowerSmallPanel.Repaint
end;

procedure TMainForm.sliderrPaint(Sender: TObject; Canvas: TCanvas);
begin
	Canvas.Draw(0, 0, PositionSliderBuffer)
end;

procedure TMainForm.FormMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	if capturing then
	begin
		releaseCapture;
		capturing := false
	end
end;

procedure TMainForm.DisableTaskSwitch(enabled: Boolean);
var
	Reg: TRegistry;
	value: Integer;
begin
	if enabled then
		value := 1
	else value := 0;

	Reg := TRegistry.Create;
	try
		Reg.RootKey := HKEY_CURRENT_USER;
		if Reg.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Policies\System', True)
			then
			begin
				Reg.WriteInteger('DisableTaskMgr',value);
				Reg.WriteInteger('DisableLockWorkstation',value)
			end
  finally
    Reg.CloseKey; 
    Reg.Free; 
  end; 
end;

function LLKeyHookFunc (hookcode:integer; keycode:wParam; kstrokeinfo:lParam): LResult; stdcall;
var
	struct: PKBDLLHOOKSTRUCT;
begin
	struct:=Ptr(kstrokeinfo);
	Result:=0;
	IF (hookcode >= 0) then
	begin
  	IF ((struct.vkCode = VK_SPACE) AND (GetAsyncKeyState(VK_MENU) < -32766)) then	//Alt + SPACE
			Result:=1 else
		IF ((struct.vkCode = VK_ESCAPE) AND (GetAsyncKeyState(VK_MENU) < -32766)) then	//Alt + ESC
			Result:=1 else
    IF ((struct.vkCode = VK_F6) AND (GetAsyncKeyState(VK_MENU) < -32766)) then	//Alt + F6  	(Alt+F6 and then Alt+F4 quits party mode)
			Result:=1 else
		IF ((struct.vkCode = VK_ESCAPE) AND (GetAsyncKeyState(VK_CONTROL) < -32766)) then
			Result:=1 else
		IF ((struct.vkCode = VK_LWIN) OR (struct.vkCode = VK_RWIN)) then
			Result:=1 else
		IF pref.LockAltTab.Checked and ((struct.vkCode = VK_TAB) AND (GetAsyncKeyState(VK_MENU) < -32766)) then
			Result:=1;
	END;
	IF (Result = 0) then
		Result:=CallNextHookEx (PartyHookId, hookcode, keycode, kstrokeinfo);
end;

procedure TMainForm.DisablePartyMode;
var
	dummy: Integer;
	hTaskBar, oldHwnd: HWND;
  FsnapWin: TSnapWin;
begin
	hTaskBar := FindWindow('Shell_TrayWnd', nil);
	ShowWindow(hTaskBar, SW_RESTORE);

  FSnapWin := TSnapWin(FSnap.GetSnapWin(MainFormInstance.handle));
  fSnapWin.Uninitialize;
  oldHwnd := MainFormInstance.Handle;
  MainFormInstance.BorderIcons := [biSystemMenu];	//giver MainFormInstance ny handle
  FSnap.ChangeHwnd(oldHwnd, MainFormInstance.Handle);
  fSnapWin.Initialize;

  if pref.IconInSystray.Checked then
	  DisplaySystrayIcon(false);

	aot.Checked := AotBeforeParty;

	if (Win32platform = VER_PLATFORM_WIN32_NT) then
	begin
		DisableTaskSwitch(false);
		if PartyHookSet then
		begin
			PartyHookSet := false;
			if not UnHookWindowsHookEx(PartyHookID) then
			begin
				Application.ProcessMessages;
				UnHookWindowsHookEx(PartyHookID);
			 end
			end
		end
	else
	begin
		SystemParametersInfo (SPI_SCREENSAVERRUNNING , Word(FALSE), @Dummy, 0);
		SystemParametersInfo(SPI_SETFASTTASKSWITCH, 1, @Dummy, 0)
	end;
	aot.Checked := AotBeforeParty;

	//SwitchMaximized;
 setwindowpos(MainFormInstance.handle, HWND_TOP, beforemaximizepos.left, beforemaximizepos.top, beforemaximizepos.right - beforemaximizepos.left , beforemaximizepos.bottom - beforemaximizepos.top, SWP_NOZORDER);
  winmaximizedBeforeParty := winmaximized;

	SetMainFormVisible(false);
	showMainFormTimer.enabled := true;

  if PartyModeHasHiddenWinamp then
  	SendMessage(hwnd_winamp, WM_COMMAND, 40258, 0);

  tree.IncrementalSearch := isVisibleOnly;
  tabel.Header.PopupMenu := columnpopup;
  tabel.Header.Options := tabel.Header.Options + [hoColumnResize];
  tabel.Header.Options := tabel.Header.Options + [hoDblClickResize];
  tabel.Header.Options := tabel.Header.Options + [hoDrag];

  Winplaylist.Header.PopupMenu := WPColumnpopup;
  Winplaylist.Header.Options := Winplaylist.Header.Options + [hoColumnResize];
  Winplaylist.Header.Options := Winplaylist.Header.Options + [hoDblClickResize];
  Winplaylist.Header.Options := Winplaylist.Header.Options + [hoDrag];

  ClearButton.Visible := true;

  if pref.PartyLimitMouse.Checked then
  	ClipCursor(0)
end;

procedure TMainForm.Partymode1Click(Sender: TObject);
var
	S, u: String;
begin
	s := '';
	if PartyMode1.Checked then
	// UNLOCK  - DISABLE
	begin
		if InputboxX(GetText(TXT_UnlockPartymode), GetText(TXT_Enterpassword), s, true) then
			if Q_SameText(trim(s), trim(PartyModePassword)) then
			begin
			 PartyMode1.Checked := false;
			 DisablePartyMode;
			end
	end
	else
	// LOCK  -  ENABLE
	begin
		if not InputboxX(GetText(TXT_EnablePartymode), GetText(TXT_Enterpassword), S, true) then
			exit
		else
		begin
			if not InputboxX(GetText(TXT_EnablePartymode), GetText(TXT_RetypePassword), u, true) then
				exit;
			if not Q_SameText(s, u) then
			begin
				showmessageX(GetText(TXT_PasswordDoesntMatch));
				exit
			end;
			ShowmessageX(GetText(TXT_PartyOn));
			EnablePartyMode(s)
		end
	end   
end;

procedure TMainForm.EnablePartyMode(pass: String);
var
	hTaskBar, oldHwnd: HWND;
	r: TRect;
	dummy: integer;
  FsnapWin: TSnapWin;
begin
	PartyMode1.Checked := true;
	PartyModePassword := trim(pass);

  if IconShowingInSystray then
  begin
    IconShowingInSystray := false;
		Shell_NotifyIcon(NIM_DELETE, @IconData)
  end;

  FSnapWin := TSnapWin(FSnap.GetSnapWin(MainFormInstance.handle));
  fSnapWin.Uninitialize;	//We need to "unitialize" the snapwin, as MEXP gets a new handle when BorderIcon is changed
  oldHwnd := MainFormInstance.Handle;
  MainFormInstance.BorderIcons := [];	//giver MainFormInstance ny handle
  FSnap.ChangeHwnd(oldHwnd, MainFormInstance.Handle);
  fSnapWin.Initialize;	//Re-initialize with the new handle

	SetMainFormVisible(true);

  if dbInitiated then
  begin
    if isWinampVisible then
    begin
      SendMessage(hwnd_winamp, WM_COMMAND, 40258, 0);
      PartyModeHasHiddenWinamp := true
    end
    else
      PartyModeHasHiddenWinamp := false;

    hTaskBar := FindWindow('Shell_TrayWnd', nil);
    ShowWindow(hTaskBar, SW_HIDE);

    //"maksimerer"
    r := GetMonitorRect(MainFormInstance);
    winmaximizedBeforeParty := winmaximized;
    winmaximized := true;
    getwindowrect(MainFormInstance.handle, beforemaximizepos);
    setwindowpos(MainFormInstance.handle, HWND_TOP, r.left, r.top, r.right - r.left , r.bottom - r.top, SWP_NOZORDER);
    //eo maksimerer

    //Always on top'er
    AotBeforeParty := aot.Checked;
    aot.checked := true;
    //eo AOT

    if (Win32platform = VER_PLATFORM_WIN32_NT) then
    begin
      PartyHookId := SetWindowsHookEx (WH_KEYBOARD_LL, @LLKeyHookFunc, hInstance, 0);
      PartyHookSet := true;
      DisableTaskSwitch(true)
    end
    else
    begin
      if pref.LockAltTab.Checked then
        SystemParametersInfo( SPI_SETFASTTASKSWITCH, 0, @Dummy, 0);

     if pref.LockCtrlAltDel.Checked then
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, 1, @Dummy, 0)
    end;

    if pref.PartyAllKeySearches.Checked then
      tree.IncrementalSearch := isNone;

    //columns - PartyLockColumns
    if pref.PartyLockColumns.Checked then
    begin
      tabel.Header.PopupMenu := nil;
      tabel.Header.Options := tabel.Header.Options - [hoColumnResize];
      tabel.Header.Options := tabel.Header.Options - [hoDblClickResize];
      tabel.Header.Options := tabel.Header.Options - [hoDrag];


      Winplaylist.Header.PopupMenu := nil;
      Winplaylist.Header.Options := Winplaylist.Header.Options - [hoColumnResize];
      Winplaylist.Header.Options := Winplaylist.Header.Options - [hoDblClickResize];
      Winplaylist.Header.Options := Winplaylist.Header.Options - [hoDrag]
    end
  end;

  if pref.PartyLimitMouse.Checked then
  begin
  	r := MainFormInstance.BoundsRect;
  	ClipCursor(@r)
  end;

  if pref.KeepPlaylistAtMaximum.Checked and (winplaylist.RootNodeCount > pref.KeepPlaylistAtNumber.value) then
  begin
		winplaylist.RootNodeCount := pref.KeepPlaylistAtNumber.value;
    winplaysave
  end;

	ClearButton.Visible := not pref.DisableDeleteMoveWinampPlaylist.Checked;
end;

procedure TMainForm.AutosetKillafterplay1Click(Sender: TObject);
begin
	AutosetKillafterplay1.Checked := not AutosetKillafterplay1.Checked
end;

procedure TMainForm.Previous1Click(Sender: TObject);
begin
	prevMouseDown(Sender, mbLeft, [], 0, 0)
end;

procedure TMainForm.Play3Click(Sender: TObject);
begin
	playMouseDown(Sender, mbLeft, [], 0, 0)
end;

procedure TMainForm.Pause1Click(Sender: TObject);
begin
	Button3(hwnd_Winamp)
end;

procedure TMainForm.Next1Click(Sender: TObject);
begin
	nxtMouseDown(Sender, mbLeft, [], 0, 0)
end;

procedure TMainForm.Stop1Click(Sender: TObject);
begin
	Button4(hwnd_winamp)
end;

procedure TMainForm.WinplaylistCurrentTimeLabelMouseDown(
  Sender: TObject; Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer);
var
	start, len: Integer;
begin
	len := WinplaylistCurrentTimeLabel.Canvas.TextWidth(WinplaylistCurrentTimeLabel.Caption);
	start := Trunc((WinplaylistCurrentTimeLabel.Width /2) - (len /2));

	if (x >= start) and (x <= start + len +2) then
	begin
		if TimeViewMode = 2 then
			TimeViewMode := 0
		else
			inc(TimeViewMode);
		UpdateCurrentTimeLabel(false);
		PaintFileInfoLabel
	end
end;

procedure TMainForm.treeFocusChanging(Sender: TBaseVirtualTree; OldNode,
  NewNode: PVirtualNode; OldColumn, NewColumn: TColumnIndex;
  var Allowed: Boolean);
begin
{	Allowed := PTreeRec(tree.GetNodeData(NewNode)).Kind <> TreeKind_Group;
	if not Allowed and assigned(oldNode) then
	begin
		tree.Selected[oldNode] := true
	end    }
end;

procedure TMainForm.treeChecked(Sender: TBaseVirtualTree;
	Node: PVirtualNode);
var
	TS: TCheckState;
	TR: PTreeRec;
begin
	TS := Tree.CheckState[Node];
	TR := tree.GetNodeData(Node);

	if (TS in [csCheckedNormal, csUncheckedNormal, csMixedNormal]) and (TR.Kind in [TreeKind_Group, TreeKind_GroupSetting]) then
	begin
		if TR.Kind = TreeKind_Group then
    begin

      case TS of
        csCheckedNormal: PGroupRec(TR.PlRecRef).Checkstate := GroupCheckState_Checked;

        csUnCheckedNormal: PGroupRec(TR.PlRecRef).Checkstate := GroupCheckState_Unchecked;

        csMixedNormal: PGroupRec(TR.PlRecRef).Checkstate := GroupCheckState_Exclude;
      end
    end
		else
		if (TR.Kind = TreeKind_GroupSetting) and (TR.Tag = 1) then
			FInvertGroupsChecked := TS = csCheckedNormal
		else
		if (TR.Kind = TreeKind_GroupSetting) and (TR.Tag = 2) then
			fAndGroups := TS = csCheckedNormal;

    PostMessage(Self.Handle, WM_UPDATE_TREE, 1, 0);
	end
end;

procedure TMainForm.treeDblClick(Sender: TObject);
begin
	if (tree.SelectedCount = 1) and (PtreeRec(tree.GetNodeData(tree.GetFirstSelected)).Kind = TreeKind_GroupSetting) then
		Configgroups1Click(sender)
  else
  if assigned(tree.FocusedNode) then
  begin
		if pref.DblClkTree.ItemIndex = 0 then
    begin
    	if tree.FocusedNode = tree.HotNode then
	    	tree.ToggleNode(tree.FocusedNode)
    end
    else
    begin
    	treepopPopup(nil);
      if (pref.DblClkTree.ItemIndex = 1) and Playallsongsinthisfolder1.Visible then
      	Playallsongsinthisfolder1Click(nil)
      else
      if (pref.DblClkTree.ItemIndex = 2) and Enqueallsongsinthisfolder1.Visible then
      	Enqueallsongsinthisfolder1Click(nil)
    end
  end
end;

procedure TMainForm.showMainFormTimerTimer(Sender: TObject);
begin
	showMainFormTimer.Enabled := false;
	SetMainFormVisible(true)
end;

function TMainForm.IsWinampVisible:Boolean;
var
	sm: HMENU;
  i : longint;
begin
	sm := GetSystemMenu(hwnd_Winamp, false);
  i := GetMenuState(sm, 40258, MF_BYCOMMAND);
  result := (MF_CHECKED and i) = MF_CHECKED
end;

Function TMainForm.GetDatabaseColor(dbindex: integer): TColor;
begin
	if dbs[dbindex].UseCustomColor then
  	result := dbs[dbindex].color
  else
  	result := FSkinDbColors[Min(dbIndex, length(FSkinDbColors))]
end;

procedure TMainForm.WinplaylistFocusPlayingNode;
var
	i: Integer;
	aNode: PVirtualNode;
begin
	aNode := Winplaylist.GetFirst;
	while aNode <> nil do
		if PplstRec(Winplaylist.GetNodeData(aNode)).playing then
		begin
			i := aNode.Index * Winplaylist.DefaultNodeHeight;
			dec(i, (Winplaylist.ClientHeight div 2) - (aNode.nodeHeight div 2));
			i := min(i, winplaylist.getVirtualTreeRect.Bottom);
			i := max(i, 0);
			Winplaylist.OffsetY := -i;
			TimeAtAutoFocusPlayingNodeInWinplaylist := GetTickCount;
			break
		end
		else
			aNode := Winplaylist.GetNext(aNode)
end;

procedure TMainForm.WinplaylistResize(Sender: TObject);
begin
	if assigned(pref) and pref.FollowPlayingWA.Checked and (GetTickCount - TimeAtAutoFocusPlayingNodeInWinplaylist < 1500) then
		WinplaylistFocusPlayingNode
end;

procedure TMainForm.Playallsongs1Click(Sender: TObject);
var
	i: Integer;
	kill: byte;
begin
	Screen.Cursor := crHourglass;
	SaveWinplayUndo;

	winplaylist.BeginUpdate;
	winplaylist.Clear;

	kill := GetKill;

	for i:=0 to reclist.Count-1 do
		WinPlayAdd(reclist.List^[i], kill, false);

	winplaylist.EndUpdate;

	if shuffleEnabled then //shuffle
		WinplaySave(random(winplaylist.RootNodeCount))
	else
		Winplaysave;

	button4(hwnd_winamp);
	button2(hwnd_winamp);

	Screen.Cursor := crDefault
end;

procedure TMainForm.Playallsongsinselecteddatabase1Click(
	Sender: TObject);
var
	i, dbIndex: Integer;
	tr: PTreeRec;
	kill: byte;
	aNode: PVirtualNode;
begin
	//finder DB-index
	dbIndex := -1;
	aNode := tree.GetFirstSelected;
	while (aNode <> tree.RootNode) and (aNode <> nil) do
	begin
		tr := tree.GetNodeData(aNode);
		if tr.Kind in [TreeKind_Harddisk, TreeKind_CDROM, TreeKind_Network, TreeKind_Zip] then
		begin
			dbIndex := tr.Location;
			break
		end;
		aNode := aNode.Parent
	end;

	if dbIndex = -1 then
		exit;	//database ikke fundet...

	Screen.Cursor := crHourglass;
	SaveWinplayUndo;

	winplaylist.BeginUpdate;
	winplaylist.Clear;

	kill := GetKill;

	for i:=0 to reclist.Count-1 do
		if Prec(reclist.List^[i]).location = dbIndex then
			WinPlayAdd(reclist.List^[i], kill, false);

	winplaylist.EndUpdate;

	if shuffleEnabled then //shuffle
		WinplaySave(random(winplaylist.RootNodeCount))
	else
		Winplaysave;

	button4(hwnd_winamp);
	button2(hwnd_winamp);

	Screen.Cursor := crDefault
end;

procedure TMainForm.plabel1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	if ssRight in Shift then
		treeplbarMouseMove(treePlBar, Shift, X, Y)
end;

procedure TMainForm.plabel1MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	if Button = mbRight then
		WPbarMouseUp(TreePlBar, Button, Shift, X, Y)
end;


procedure TMainForm.treeKeyPress(Sender: TObject; var Key: Char);
begin
	if partyMode1.Checked and pref.PartyAllKeySearches.Checked then
  begin
  	tabel.SetFocus;
  	FormKeyPress(sender, Key)
  end
end;

procedure TMainForm.WinplaylistHeaderDragged(Sender: TVTHeader;
  Column: TColumnIndex; OldPosition: Integer);
begin
	CalculateWinplayTextColumn
end;

procedure TMainForm.WPcolumnPopupPopup(Sender: TObject);
var
	i:integer;
	mi: TMenuItem;
begin
	WPcolumnpopup.items.clear;
//	columnpopup.Items.add(newitem(pref.AutoResizeColumnHeaders.Caption, texttoshortcut(''), pref.AutoResizeColumnHeaders.Checked, true, ToggleAutoResizeColumnToFit,0, 'columnPopXtra1'));
//	columnpopup.Items.add(newitem(pref.HideInfoShownInTree.Caption, texttoshortcut(''), pref.HideInfoShownInTree.Checked, true, ToggleHideInfoShownInTree,0, 'columnPopXtra2'));
//	columnpopup.Items.add(newitem('-', texttoshortcut(''), false, true, nil,0, 'columnPopXtra3'));
	for i:=1 to Winplaylist.header.columns.count -1 do
	begin
		mi := newitem(Winplaylist.header.columns[Winplaylist.Header.Columns.ColumnFromPosition(i)].text,texttoshortcut(''), coVisible in winplaylist.Header.Columns[Winplaylist.Header.Columns.ColumnFromPosition(i)].Options ,true , WPcolumnpopupmenuClick,0,'WPmenuitemcolpop' + inttostr(i));
		mi.tag := Winplaylist.Header.Columns.ColumnFromPosition(i);
		WPcolumnpopup.Items.add(mi)
	end
end;

procedure TMainForm.WPcolumnpopupmenuClick(Sender: TObject);
var     i:integer;
begin
	Winplaylist.BeginUpdate;

	(sender as Tmenuitem).checked := not (sender as Tmenuitem).checked;
	for i:=0 to WPcolumnpopup.Items.Count-1 do
  	if WPcolumnpopup.Items[i].Checked then
      Winplaylist.Header.Columns[WPcolumnPopUp.Items[i].Tag].Options := Winplaylist.Header.Columns[WPcolumnPopUp.Items[i].Tag].Options + [coVisible]
    else
    	Winplaylist.Header.Columns[WPcolumnPopUp.Items[i].Tag].Options := Winplaylist.Header.Columns[WPcolumnPopUp.Items[i].Tag].Options - [coVisible];

  Winplaylist.Endupdate;
	UpdateTreeBounds(Winplaylist);
	UpdateHScroll(WinplayScrollH, Winplaylist)
end;

procedure TMainForm.WinPlayScrollHScroll(Sender: TObject; SBcode,
  Param: Integer);
begin
	case SBcode of
    SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN : Winplaylist.perform(WM_HSCROLL, SBcode, 0);
    SB_THUMBPOSITION : Winplaylist.OffsetX := -Param;
  end;
  // moved to OnScroll
  // Winplaylist.UpdateHorizontalScrollBar(false);
end;

procedure TMainForm.WinplaylistHeaderMouseUp(Sender: TVTHeader;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
	if Pref.Scrollbars.itemindex = 2 then
  	UpdateTreeBounds(winplaylist)
end;

procedure TMainForm.WinplayEnqueue(Node: PVirtualNode);
var
	aNode: PVirtualNode;
  pl: PplstRec;
  maxNo: Integer;
begin
  MaxNo := 0;
  aNode := winplaylist.GetFirst;
  while aNode <> nil do
  begin
  	pl := Winplaylist.GetNodeData(aNode);
    if pl.EnqueueNo > MaxNo then
    	MaxNo := pl.EnqueueNo;
    aNode := winplaylist.GetNext(aNode)
  end;
  if MaxNo < 255 then
  begin
  	pl := winplaylist.GetNodeData(Node);
    pl.EnqueueNo := MaxNo+1;
    Winplaylist.InvalidateNode(Node);
    AdjustWinplaylistEnqueueNoColumnWidth
    //updplaylist
  end
end;

procedure TMainForm.WinplayDequeue(Node: PVirtualNode);
var
	aNode: PVirtualNode;
  pl: PplstRec;
  ThisNo: Integer;
begin
  pl := winplaylist.GetNodeData(Node);
  ThisNo := pl.EnqueueNo;

  if ThisNo = 0 then
  	exit;

  pl.EnqueueNo := 0;
  winplaylist.InvalidateNode(Node);

  aNode := winplaylist.GetFirst;
  while aNode <> nil do
  begin
  	pl := Winplaylist.GetNodeData(aNode);
    if pl.EnqueueNo > ThisNo then
    begin
    	dec(pl.EnqueueNo);
      winplaylist.InvalidateNode(aNode)
    end;
    aNode := winplaylist.GetNext(aNode)
  end;
	AdjustWinplaylistEnqueueNoColumnWidth
end;

procedure TMainForm.EnqueueDequeue1Click(Sender: TObject);
var
	aNode: PVirtualNode;
  pl: PplstRec;
begin
	aNode := winplaylist.GetFirstSelected;
  if assigned(aNode) then
  begin
  	pl := Winplaylist.GetNodeData(aNode);
    if pl.EnqueueNo = 0 then
    	WinplayEnqueue(aNode)
    else
    	WinplayDequeue(aNode);
    ValidateWinplaylist(-1)
  end
end;

function CompareEnqueueNoValue(Item1, Item2: Pointer): integer;
begin
	result := PplstRec(Item1).EnqueueNo - PplstRec(Item2).EnqueueNo;
end;

procedure TMainForm.ValidateWinplayEnqueue;
var
	list: TList;
  aNode: PVirtualNode;
  i: Integer;
  pl: PplstRec;
begin
	list := TList.Create;

  aNode := winplaylist.GetFirst;
  while aNode <> nil do
  begin
  	pl := winplaylist.GetNodeData(aNode);
    if pl.EnqueueNo > 0 then
    	list.Add(pl);
    aNode := Winplaylist.GetNext(aNode)
  end;

  if list.Count > 0 then
  begin
  	list.Sort(CompareEnqueueNoValue);
  	for i:=0 to list.Count-1 do
    	PplstRec(list.Items[i]).EnqueueNo := i+1;
    AdjustWinplaylistEnqueueNoColumnWidth;
    winplaylist.update
  end;

  list.Free
end;

procedure TMainForm.AdjustWinplaylistSongNoColumnWidth;
const
	SongNoColumn = 1;
var
	i, w: Integer;
  s: String;
begin
	if pref.WinplayShowColumns.Checked and (Winplaylist.Header.Columns.Count > SongNoColumn) and (coVisible in Winplaylist.Header.Columns[SongNoColumn].Options) then
  begin
		TempCanvas.Canvas.Font := Winplaylist.Font;
    TempCanvas.Canvas.Font.Style := TempCanvas.Canvas.Font.Style + [fsBold];
    s := IntToStr(Winplaylist.RootNodeCount);
    for i:=1 to length(s) do
    	s[i] := '8';

    w := TempCanvas.Canvas.TextWidth(s+'.') + 10;

    if winplaylist.Header.Columns[SongNoColumn].Width <> w then
	  	winplaylist.Header.Columns[SongNoColumn].Width := w
  end
end;

procedure TMainForm.AdjustWinplaylistEnqueueNoColumnWidth(callAdjustWinplaySongNoColumnWidth: boolean = true);
const
	EnqueueNoColumn = 0;
var
	i, w, maxNo: Integer;
  s: String;
  aNode: PVirtualNode;
  pl: PplstRec;
begin
	if pref.ControlPlaylist.Checked and (Winplaylist.Header.Columns.Count > EnqueueNoColumn) then
  begin
  	maxNo := 0;

    aNode := winplaylist.GetFirst;
    while aNode <> nil do
    begin
    	pl := winplaylist.GetNodeData(aNode);
      if pl.EnqueueNo > maxNo then
      	maxNo := pl.EnqueueNo;
      aNode := Winplaylist.GetNext(aNode)
    end;

    if maxNo = 0 then
    	Winplaylist.Header.Columns[EnqueueNoColumn].Options := Winplaylist.Header.Columns[EnqueueNoColumn].Options - [coVisible]
    else
    begin
			TempCanvas.Canvas.Font := Winplaylist.Font;
	    TempCanvas.Canvas.Font.Style := TempCanvas.Canvas.Font.Style + [fsBold];
	    s := IntToStr(maxNo);
	    for i:=1 to length(s) do
	    	s[i] := '8';

	    w := TempCanvas.Canvas.TextWidth(s) + 10;
      if winplaylist.Header.Columns[EnqueueNoColumn].Width <> w then
	  		winplaylist.Header.Columns[EnqueueNoColumn].Width := w;
      Winplaylist.Header.Columns[EnqueueNoColumn].Options := Winplaylist.Header.Columns[EnqueueNoColumn].Options + [coVisible]
    end;
    if callAdjustWinplaySongNoColumnWidth and not pref.WinplayShowColumns.Checked then
	    ResizeWinplaylistColumns(false)
  end
  else
 		if (Winplaylist.Header.Columns.Count > EnqueueNoColumn) and (coVisible in Winplaylist.Header.Columns[EnqueueNoColumn].Options) then
    	Winplaylist.Header.Columns[EnqueueNoColumn].Options := Winplaylist.Header.Columns[EnqueueNoColumn].Options - [coVisible]
end;


procedure TMainForm.LowerSmallPanelPaint(Sender: TObject;
  Canvas: TCanvas);
begin
	if MainFormInstance.ClientWidth <= SmallWindowLimit then
  begin
  	prepareCurPlayText(false, false);
    Canvas.Draw(FCurPlayRect.Left, FCurPlayRect.Top, FCurPlayBitmap)
  end;
end;

procedure TMainForm.SaveAllNoRelease(onlySaveDB: Boolean);
begin
	screen.Cursor := crHourglass;
  if onlySaveDB then
  	savedatabase(false)
  else
  begin
		SaveSettings(false);
	  if assigned(BasicSettings) then
			BasicSettings.WriteToFile;
		if assigned(Settings) then
			Settings.WriteToFile
  end;
  screen.Cursor := crDefault
end;

procedure TMainForm.SaveDatabase1Click(Sender: TObject);
begin
	SaveAllNoRelease(false)
end;

procedure TMainForm.FileFind1Abort(Sender: TObject);
begin
	Filefind1.Tag := -1;
end;

procedure TMainForm.FileFind1FindFile(Sender: TObject; const AName: String);
var
  i: integer;
  LocalFileTime: TFileTime;
begin
	FileTimeToLocalFileTime(FileFind1.FindData.ftLastWriteTime, LocalFileTime);
  FileTimeToDosDateTime(LocalFileTime, LongRec(i).Hi, LongRec(i).Lo);
	FileFind1.Files.AddObject(AName, TObject(i))
end;

function CompareShowCover(Item1, Item2: Pointer): integer;
begin
	result := Q_CompText(PFileAndText(Item1).text, PFileAndText(Item2).text)
end;

procedure TMainForm.coverThreadExecute(Sender: TObject;
  Thread: TBMDExecuteThread; var Data: Pointer);
const
	order: Array[0..3] of String = ('Front', 'Back', 'Inside', 'CD');
var
  FT: PFileAndText;
  tf: Textfile;
  list: TList;
  i, x, minLen, cutFrom, insertPos: Integer;
  b: Boolean;
  c: Char;
  url: String;
  tmp: PChar;
begin
	//Sger efter filer
  coverFF.Files.Clear;
	coverFF.RootDirectory := GetFilePath(FCurPlay);
  coverFF.Search;

  if coverFF.Files.Count > 0 then
  begin
    list := TList.Create;

    minLen := high(integer);
    for i:=0 to coverFF.Files.Count-1 do
    begin
    	new(FT);
			FT.text := GetFilename(coverFF.Files.Strings[i], false);
      if length(FT.text) < minLen then
      	minLen := length(FT.text);
     FT.filename := 'file://' + Q_ReplaceStr(coverFF.Files.Strings[i], '\', '/');
     list.Add(FT)
    end;

    //cropper navne
    if List.Count > 1 then
    begin
	    cutFrom := 1;
	    for x:=1 to minLen do
	    begin
	      FT := list.Items[0];
	    	b := true;
	      c := FT.text[x];
	      for i:=1 to list.Count-1 do
	      begin
	      	FT := list.Items[i];
	      	b := b and (FT.text[x] = c);
	      end;
	      if b then
	      	cutFrom := x
	      else
	      	break
	    end
    end
    else
    	CutFrom := 1;

    for i:=0 to list.Count-1 do
    begin
    	FT := list.Items[i];
    	FT.text := Q_CopyFrom(FT.text, cutFrom);
      if Q_SameText(FT.text, 'f') then
      	FT.text := 'Front';
      if Q_SameText(FT.text, 'b') then
      	FT.text := 'Back';
      FT.text := CleanString(FT.text, true)
    end;

    //Sorterer
    list.Sort(CompareShowCover);
    insertPos := 0;
    for x:=0 to length(order)-1 do
    	for i:=insertPos to list.Count-1 do
      	if Q_SameText(order[x], PFileAndText(list.Items[i]).text) then
        begin
        	list.move(i, insertPos);
          inc(insertPos);
          break
        end;

    //eo Sorterer

    try
      url := showCoverDir + 'img.js';
	    assignfile(tf, url);
	    Filemode := 1;
	    rewrite(tf);
      writeln(tf, 'var imgCount = ' + inttostr(list.count) + ';');
      writeln(tf, 'var imgText = new Array(imgCount);');
			writeln(tf, 'var imgFile = new Array(imgCount);');
      for i:=0 to list.Count-1 do
      begin
      	FT := list.Items[i];
      	writeln(tf, 'imgText[' + inttostr(i+1) + '] = "' + FT.text + '";');
        writeln(tf, 'imgFile[' + inttostr(i+1) + '] = "' + FT.filename + '";');
        Dispose(FT)
      end;
      list.Free;
      closeFile(tf);

      if thread.Terminated then
      	exit;

      //Load in Minibrowser
      Sendmessage(hWnd_Winamp,WM_WA_IPC,1,248);

      url := showCoverDir + 'cover.html';
      tmp := StrAlloc(Length(url)+1);
      tmp := StrPCopy(tmp, url);
      Sendmessage(hWnd_Winamp,WM_WA_IPC,integer(tmp),249);
      StrDispose(tmp);

      if pref.CoverShowHideMB.Checked then
      begin
				if not IsWindowVisible(hwnd_MB) then
        	Sendmessage(hWnd_Winamp,WM_WA_IPC,0,249);
        ShowWindow(hwnd_MB, SW_ShowNormal)
      end
    except
    end
  end
  else
  	try
    	if pref.CoverShowHideMB.Checked and IsWindowVisible(hwnd_MB) then
        SendMessage(hwnd_winamp, WM_COMMAND, 40298, 0);
    except
    end;
  coverFF.Files.Clear
end;

procedure TMainForm.ToggleMinibrowser1Click(Sender: TObject);
begin
	SendMessage(hwnd_winamp, WM_COMMAND, 40298, 0)
end;

procedure TMainForm.Removefromdatabase1Click(Sender: TObject);
var
	aNode: PVirtualNode;
  list: TList;
begin
	list := TList.Create;
  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
  	list.Add(GetRec(aNode));
    aNode := tabel.GetNextSelected(aNode)
  end;
  RemoveRecsFromDB(list);
  list.free
end;

procedure TMainForm.Removeselectedfromdatabase1Click(Sender: TObject);
var
	i: Integer;
  list: TList;
begin
  SetFilterFlags;

  if fonlyPL then
  	exit;

	list := TList.Create;

  for i:=0 to reclist.count-1 do
  	if filterrec(reclist.List^[i], true) then
    	list.add(reclist.List^[i]);

  RemoveRecsFromDB(list);
  list.free
end;

procedure TMainForm.UpdateTopImage(Sender: TBMDThread;
  Thread: TBMDExecuteThread);
begin
	RepaintTopimage
end;

procedure TMainForm.RemoveFromTabel(Sender: TBMDThread; Thread: TBMDExecuteThread; var Data: Pointer);
procedure DeleteNodes(Nodes: TNodeArray);
var
  I: Integer;
  LevelChange: Boolean;
  
begin
	for I := High(Nodes) downto 1 do
  begin
  	LevelChange := Nodes[I].Parent <> Nodes[I - 1].Parent;
    Tabel.DeleteNode(Nodes[I], LevelChange);
  end;
  Tabel.DeleteNode(Nodes[0], true);
end;

var
	aNode: PVirtualNode;
  nodes: TNodeArray;
	rec: PRec;
  i: integer;
begin
  BeginUseReclist;

	tabel.BeginUpdate;
  SetLength(nodes, tabel.RootNodeCount);
  i:=0;

  aNode := tabel.GetFirst;
  while aNode <> nil do
  begin
  	rec := GetRec(aNode);
  	if rfDeletePending in rec.Flags then
    begin
    	nodes[i] := aNode;
      inc(i)
    end;
  	aNode := tabel.GetNext(aNode)
  end;
  SetLength(nodes, i);
  if i > 0 then
  	DeleteNodes(nodes);

  ReleaseRecs(false, true);
  reclist.Pack;
  reclist.Capacity := reclist.Count;

  EndUseReclist;
  tabel.EndUpdate;
end;

procedure TMainForm.Addtonewplaylist2Click(Sender: TObject);
var
  f:textfile;
  aNode:pVirtualNode;
  pl: PplstRec;
begin
  disableAOT;
  if savedialog1.Execute then
  begin
    assignfile(f, savedialog1.filename);
    Filemode := 2;
    rewrite(F);
    writeln(f,'#EXTM3U');
    aNode := Winplaylist.GetFirstSelected;
    while aNode <> nil do
    begin
    	pl := WinPlayList.GetNodeData(aNode);
      if assigned(pl.Rec) then
        writeln(f, getFtextP(pl.Rec, Fextstr) + CRLF + getFtextP(pl.Rec, fFilename))
      else
      	writeln(f, '#EXTINF' + ':' + inttostr(pl.Seconds) + ',' + pl.text + #13#10 + pl.Filename);
      aNode := WinPlaylist.GetNext(aNode)
    end;
    closefile(f)
  end;
  SetMainFormVisible(true)
end;

procedure TMainForm.Addtoexistingplaylist2Click(Sender: TObject);
var
   f:textfile;
   exists:boolean;
   aNode : PVirtualNode;
   fn:string;
   pl: PplstRec;
begin
  disableAOT;
  if showOpenDialog(GetText(TXT_SelectFileToSaveAppend), '', '', 'Playlist files (m3u, pls)|*.M3U;*.PLS', fn) then
  begin
    assignfile(f, fn);
    Filemode := 2;
    exists := fileexists(fn);
    if exists then
    	append(F)
    else
    	rewrite(f);

    if not exists then
    	writeln(f,'#EXTM3U');

    aNode := Winplaylist.GetFirstSelected;
    while aNode <> nil do
    begin
    	pl := WinPlayList.GetNodeData(aNode);
      if assigned(pl.Rec) then
        writeln(f, getFtextP(pl.Rec, Fextstr) + CRLF + getFtextP(pl.Rec, fFilename))
      else
      	writeln(f, '#EXTINF' + ':' + inttostr(pl.Seconds) + ',' + pl.text + #13#10 + pl.Filename);
      aNode := WinPlaylist.GetNext(aNode)
    end;
    closefile(f)
  end;
  SetMainFormVisible(true)
end;

procedure TMainForm.Addtonewplaylist1Click(Sender: TObject);
begin
  disableAOT;
  if savedialog1.Execute then
    winplaySaveToFile(savedialog1.filename);
  SetMainFormVisible(true)
end;


procedure TMainForm.Addtoexistingplaylist1Click(Sender: TObject);
var
   f:textfile;
   exists:boolean;
   aNode : PVirtualNode;
   fn:string;
   pl: PplstRec;
begin
  disableAOT;
  if showOpenDialog(GetText(TXT_SelectFileToSaveAppend), '', '', 'Playlist files (m3u, pls)|*.M3U;*.PLS', fn) then
  begin
    assignfile(f, fn);
    Filemode := 2;
    exists := fileexists(fn);
    if exists then
    	append(F)
    else
    	rewrite(f);

    if not exists then
    	writeln(f,'#EXTM3U');

    aNode := Winplaylist.GetFirstVisible;
    while aNode <> nil do
    begin
    	pl := WinPlayList.GetNodeData(aNode);
      if assigned(pl.Rec) then
        writeln(f, getFtextP(pl.Rec, Fextstr) + CRLF + getFtextP(pl.Rec, fFilename))
      else
      	writeln(f, '#EXTINF' + ':' + inttostr(pl.Seconds) + ',' + pl.text + #13#10 + pl.Filename);
      aNode := WinPlaylist.GetNextVisible(aNode)
    end;
    closefile(f)
  end;
  SetMainFormVisible(true)
end;

procedure TMainForm.SavetoHTMLimportablebyExcel1Click(Sender: TObject);
var
	f:TStream;
  s:string;
begin
  disableAOT;
  if savedialog2.Execute then
    if savedialog2.FilterIndex = 1 then
    begin
      screen.cursor := crhourglass;
      application.processmessages;
      s := Winplaylist.ContentToHTML(tstVisible);
      s := #239 + #187 + #191 + s;    //Ellers vises visse filer ikke rigtigt i explorer
      f := TFileStream.create(savedialog2.filename, fmCreate);
      f.write(s[1], length(s));
      //MySaveToTree(tabel, f);
      f.free;
      screen.cursor := crDefault
    end;
  SetMainFormVisible(true)
end;

procedure TMainForm.Punchin4Click(Sender: TObject);
var
	target, aNode: PVirtualNode;
  arr: array of PVirtualNode;
  i: Integer;
begin
  screen.cursor := crAppStart;
	//finder target node
  target := nil;
  arr := nil;
	aNode := winplaylist.GetFirst;
  while aNode <> nil do
  begin
  	if PplstRec(winplaylist.GetNodeData(aNode)).playing then
    	target := aNode
    else
    	if winplaylist.Selected[aNode] then
      begin
      	SetLength(arr, length(arr)+1);
        arr[length(arr)-1] := aNode
      end;
    aNode := winplaylist.GetNext(aNode)
  end;

  if assigned(target) then
  begin
  	winplaylist.Beginupdate;
  	for i:=length(arr)-1 downto 0 do
    	winplaylist.MoveTo(arr[i], target, amInsertAfter, false);
    winplaysave;
    winplaylist.Endupdate
  end;
  screen.cursor := crDefault
end;

procedure TMainForm.tabelDragAllowed(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
begin
	allowed := true
end;

procedure TMainForm.Explorer1Click(Sender: TObject);
var
	rec: PRec;
begin
	if tabel.SelectedCount = 1 then
  begin
		rec := GetRec(tabel.GetFirstSelected);
    ShellExecute(0, 'explore', PChar(getFtextP(rec, FFilepath)), '', '', SW_SHOWNORMAL)
  end
end;

procedure TMainForm.Openinexplorer1Click(Sender: TObject);
begin
	if Winplaylist.SelectedCount = 1 then
    ShellExecute(0, 'explore', PChar(GetFilePath(GetWinplayFilename(winplaylist.GetNodeData(Winplaylist.GetFirstSelected)))), '', '', SW_SHOWNORMAL)
end;

procedure TMainForm.tabelGetImageIndex(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
  var Ghosted: Boolean; var ImageIndex: Integer);
begin
	if (Kind = ikState) and (column in [22, 26]) then
  begin
  	if ((Column = 22) and (rfHasLyrics in GetRec(Node).Flags)) or ((Column = 26) and (rfAutoScanned in GetRec(Node).Flags)) then
    	imageIndex := 1
    else
    	imageIndex := 0
  end
end;

procedure TMainForm.PreviousClick1Click(Sender: TObject);
begin
	button1(hwnd_winamp);
  DoSliderTimerTimer(nil)
end;

procedure TMainForm.Revind5seconds1Click(Sender: TObject);
begin
	Button1_Shift(hwnd_Winamp);
  DoSliderTimerTimer(nil)
end;

procedure TMainForm.Startoflist1Click(Sender: TObject);
begin
	WinplaySave(0);
  if playbackstatus(hwnd_winamp) = 3 then //paused
		button4(hwnd_winamp);
	button2(hwnd_winamp) //play)
end;

procedure TMainForm.PreviousinMainlistAltClick1Click(Sender: TObject);
var
	anode:pVirtualNode;
  rec:Prec;
begin
  anode := tabel.GetLastVisible;
  while  anode <> nil do
  begin
    rec := GetRec(aNode);
    if rfplaying in rec.Flags then
    begin
      anode := tabel.GetPreviousVisible(aNode);
      if anode = nil then
      	anode := tabel.GetLastVisible;
      break
    end;
    anode := tabel.GetPreviousVisible(aNode)
  end;
  if aNode = nil then
    aNode := tabel.GetLastVisible;
  if anode = nil then
    exit;
  winplaylist.BeginUpdate;
  winplaylist.clear;
  winplayAdd(GetRec(aNode), GetKill);
  if continuousPlay1.checked then
    CheckConPlay;
  WinPlaySave;
  winplaylist.endupdate;
  if playbackstatus(hwnd_winamp) = 3 then //paused
    button4(hwnd_winamp);
  button2(hwnd_winamp)
end;

procedure TMainForm.Playrestaart1Click(Sender: TObject);
begin
	button2(hwnd_Winamp);
  doSliderTimerTimer(nil);
end;

procedure TMainForm.OpenlocationShiftClick1Click(Sender: TObject);
begin
	Button2_CTRL(hwnd_Winamp)
end;

procedure TMainForm.OpenfileCtrlClick1Click(Sender: TObject);
begin
	button2_Shift(hwnd_Winamp)
end;

procedure TMainForm.StopClick1Click(Sender: TObject);
begin
	Button4(hwnd_Winamp);
  doSliderTimerTimer(nil)
end;

procedure TMainForm.StopwithFadeout1Click(Sender: TObject);
begin
	Button4_Shift(hwnd_Winamp)
end;

procedure TMainForm.Stopaftercurrent1Click(Sender: TObject);
begin
	Button4_CTRL(hwnd_Winamp)
end;

procedure TMainForm.Next2Click(Sender: TObject);
begin
	button5(hwnd_winamp);
  DoSliderTimerTimer(nil)
end;

procedure TMainForm.Fastforward5seconds1Click(Sender: TObject);
begin
	button5_Shift(hwnd_Winamp);
  DoSliderTimerTimer(nil)
end;

procedure TMainForm.Endoflist1Click(Sender: TObject);
begin
	WinplaySave(Winplaylist.RootnodeCount-1);
  if playbackstatus(hwnd_winamp) = 3 then //paused
		button4(hwnd_winamp);
	button2(hwnd_winamp) //play)
end;

procedure TMainForm.NextinMainlistAltClick1Click(Sender: TObject);
var
	aNode:pVirtualNode;
	rec:Prec;
begin
  anode := tabel.GetFirstVisible;
  while anode <> nil do
  begin
    rec := GetRec(aNode);
    if rfPlaying in rec.Flags then
    begin
      anode := tabel.GetNextVisible(aNode);
      if anode = nil then
      	anode := tabel.GetFirstVisible;
      break
    end;
    anode := tabel.GetNextVisible(aNode)
  end;
  if anode = nil then
  	anode := tabel.GetFirstVisible;
  if anode = nil then
  	exit;
  winplaylist.BeginUpdate;
  winplaylist.clear;
  winplayAdd(GetRec(aNode), GetKill);
  if continuousPlay1.checked then
  	CheckConPlay;
  WinPlaySave;
  winplaylist.endupdate;
  if playbackstatus(hwnd_winamp) = 3 then //paused
  	button4(hwnd_winamp);
  button2(hwnd_winamp)
end;

procedure TMainForm.tabelGetPopupMenu(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex; const P: TPoint;
  var AskParent: Boolean; var PopupMenu: TPopupMenu);
var
	state: TKeyboardState;
begin
	GetKeyboardState(State);
	if (State[vk_Control] and 128) <> 0 then
  	PopupMenu := nil
  else
  	PopupMenu := filesPopup
end;

procedure TMainForm.tabelMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	if Button = mbRight then
  	tabelMouseRightMouseButtonDown := false;
end;

procedure TMainForm.tabelFocusChanging(Sender: TBaseVirtualTree;
  OldNode, NewNode: PVirtualNode; OldColumn, NewColumn: TColumnIndex;
  var Allowed: Boolean);
var
	state: TKeyboardState;
begin
	if tabelMouseRightMouseButtonDown then
  begin
  	GetKeyboardState(State);
		allowed := (State[vk_Control] and 128) = 0
  end
end;

procedure TMainForm.globalPopup(Sender: TObject);
begin
	DeleteWinampPlaylist1.Visible := not (partymode1.Checked and pref.DisableDeleteMoveWinampPlaylist.Checked);
  Preferences1.Visible := not partymode1.Checked;
  Previous1.Visible := not (partymode1.Checked and pref.PartydisablePlaybackControls.Checked);
  Play3.Visible := not (partymode1.Checked and pref.PartydisablePlaybackControls.Checked);
  Pause1.Visible := not (partymode1.Checked and pref.PartydisablePlaybackControls.Checked);
  Stop1.Visible := not (partymode1.Checked and pref.PartydisablePlaybackControls.Checked);
  Next1.Visible := not (partymode1.Checked and pref.PartydisablePlaybackControls.Checked);
end;

function TMainForm.FindRightFile(fn: String):pointer;
var
	i, k, fnLength: Integer;
  s: String;
begin
	result := nil;
  repeat
    Q_CutLeft(fn, Q_StrScan(fn, '\'));
    fnLength := Length(fn);
  	for i:=0 to reclist.Count-1 do
    begin
    	s := GetFTextP(reclist.List^[i], FFilename);
    	k := Length(s) - fnLength;
    	if (k > 0) and Q_MatchText(fn, s, k+1) then
      begin
      	result := reclist.List^[i];
        break
      end
    end
  until (result <> nil) or (Q_StrScan(fn, '\') = 0)
end;

procedure TMainForm.Repairquicklist1Click(Sender: TObject);
var
	aNode, bNode: PVirtualNode;
  pc: PplConRec;
begin
	if playlistbox.selectedcount > 0 then
	begin
		aNode := plCon.GetFirst;
		while aNode <> nil do
		begin
			pc := plCon.GetNodeData(aNode);
      if not assigned(pc.Rec) and not fileexists(pc.filename) then
      begin
        pc.Rec := FindInReclist(pc.filename);
        if not assigned(pc.Rec) then
        begin
	      	pc.Rec := findRightFile(pc.filename);
          if assigned(pc.Rec) then
          	pc.Filename := ''
        end
        else
        	pc.Filename := ''
      end;
      if not assigned(pc.Rec) and not fileexists(pc.filename) then
      	if YesNoBoxx(GetText(TXT_RepairPlaylist), GetText(TXT_RepairPlaylistAsk, [pc.filename]), GetText(TXT_Yes), GetText(TXT_No), 1) then
        begin
        	bNode := plcon.GetNext(aNode);
          plCon.DeleteNode(aNode);
          aNode := bNode
        end;
			aNode := plCon.GetNext(aNode)
		end;
    updateplaylist
	end
end;

procedure TMainForm.Shuffleselected1Click(Sender: TObject);
begin
	ShuffleWinplay(true);
  winplaysave
end;

procedure TMainForm.WinplaylistHeaderClick(Sender: TVTHeader;
  Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer);
var
	Focused, aNode: PVirtualNode;
begin
	if ssCtrl in Shift then
  begin
    SaveWinplayUndo;
		if FWPSortedCol = Winplaylist.header.Columns[column].tag then
  	if Winplaylist.Header.SortDirection = sdAscending then
    	Winplaylist.Header.SortDirection := sdDescending else Winplaylist.Header.SortDirection := sdAscending;
	  Winplaylist.Header.SortColumn := column;
	  FWPSortedCol1 := FWPSortedCol;
	  FWPSortedCol := Winplaylist.header.Columns[column].tag;

    Focused := Winplaylist.FocusedNode;

	  Winplaylist.BeginUpdate;
    if continuousPlay1.checked then
  		removeConPlay;
	  Winplaylist.SortTree(FWPSortedCol, Winplaylist.header.sortdirection, false);
    if continuousPlay1.checked then
  		CheckConPlay;

    //selecter den gamle focused node
    aNode := Winplaylist.GetFirstVisible;
    while aNode <> nil do
    begin
      if aNode = Focused then
      begin
        Winplaylist.ScrollIntoView(aNode, true);
        break
      end;
      aNode := Winplaylist.GetNextVisible(aNode)
    end;

	  Winplaylist.EndUpdate;
    Winplaysave
  end
end;

procedure TMainForm.frommainlist1Click(Sender: TObject);
begin
	fromMainList1.Checked := true;
  if continuousPlay1.Checked and CheckConplay(true) then
  	winplaySave
end;

procedure TMainForm.randomfromcurrentdatabase1Click(Sender: TObject);
begin
	randomfromcurrentdatabase1.Checked := true;
  if continuousPlay1.Checked and CheckConplay(true) then
  	winplaySave
end;

procedure TMainForm.randomfromallavailabledatabases1Click(
  Sender: TObject);
begin
	randomfromallavailabledatabases1.Checked := true;
  if continuousPlay1.Checked and CheckConplay(true) then
  	winplaySave
end;

procedure TMainForm.randomfrommainlist1Click(Sender: TObject);
begin
	randomfrommainlist1.Checked := true;
  if continuousPlay1.Checked and CheckConplay(true) then
  	winplaySave
end;

procedure TMainForm.PlayWinamp;
begin
	if playbackstatus(hwnd_winamp) = 3 then //paused
  	button4(hwnd_winamp);
  PostMessage(hwnd_winamp, WM_COMMAND, WINAMP_BUTTON2, 0);
		//button2(hwnd_winamp) //play
//	StartWinampTimer.Enabled := false;
//  StartWinampTimer.Enabled := true
end;

procedure TMainForm.tabelBeforeItemErase(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
  var ItemColor: TColor; var EraseAction: TItemEraseAction);
begin
	if not (toShowBackground in TVirtualStringTree(Sender).TreeOptions.PaintOptions) and boolean(Node.Dummy) then
  begin
  	EraseAction := eaColor;
	  ItemColor := TabelOddRowColor
  end  
end;

procedure TMainForm.treeBeforeItemErase(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
  var ItemColor: TColor; var EraseAction: TItemEraseAction);
begin
	if not (toShowBackground in TVirtualStringTree(Sender).TreeOptions.PaintOptions) and
  	boolean(Node.Dummy) then
  begin
  	EraseAction := eaColor;
	  ItemColor := TreeOddRowColor
  end
end;

procedure TMainForm.playlistboxBeforeItemErase(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
  var ItemColor: TColor; var EraseAction: TItemEraseAction);
begin
	if  not (toShowBackground in TVirtualStringTree(Sender).TreeOptions.PaintOptions) and
  	boolean(Node.Dummy) then
  begin
  	EraseAction := eaColor;
	  ItemColor := QuicklistOddRowColor
  end
end;

procedure TMainForm.plConBeforeItemErase(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
  var ItemColor: TColor; var EraseAction: TItemEraseAction);
begin
	if  not (toShowBackground in TVirtualStringTree(Sender).TreeOptions.PaintOptions) and
  	boolean(Node.Dummy) then
  begin
  	EraseAction := eaColor;
	  ItemColor := QuicklistcontentOddRowColor
  end
end;

procedure TMainForm.WinplaylistBeforeItemErase(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
  var ItemColor: TColor; var EraseAction: TItemEraseAction);
begin
	if  not (toShowBackground in TVirtualStringTree(Sender).TreeOptions.PaintOptions) and
  	boolean(Node.Dummy) then
  begin
  	EraseAction := eaColor;
	  ItemColor := WinplaylistOddRowColor
  end    
end;

procedure TMainForm.CheckBackgroundImage;
var
	jp: TJPEGImage;
	bm: TBitmap;
begin
	if not Q_SameText(Trim(pref.txtBackgroundImageFilename.Text), FCurrentBackgroundImage) then
  	if (length(Trim(pref.txtBackgroundImageFilename.Text)) > 0) and FileExists(Trim(pref.txtBackgroundImageFilename.Text)) then
    begin
      FCurrentBackgroundImage := Trim(pref.txtBackgroundImageFilename.Text);
      jp := TJPEGImage.Create;
      jp.LoadFromFile(FCurrentBackgroundImage);

      bm := Tbitmap.Create;
      bm.Width := MainFormInstance.Width;
      bm.Height := height;
      bm.Canvas.brush.Color := winplaylist.Color;

  //    bm.Canvas.FillRect(rect(0, 0, bm.width, bm.height));
      bm.Canvas.StretchDraw(rect(0, 0, bm.Width, bm.Height), jp);

      tabel.background.Bitmap.Assign(bm);
      tabel.TreeOptions.PaintOptions := tabel.TreeOptions.PaintOptions + [toShowBackground];
      Winplaylist.background := tabel.Background;
      Winplaylist.TreeOptions.PaintOptions := Winplaylist.TreeOptions.PaintOptions + [toShowBackground];

      Tree.background := tabel.Background;
      Tree.TreeOptions.PaintOptions := Tree.TreeOptions.PaintOptions + [toShowBackground];

      plcon.background := tabel.Background;
      plcon.TreeOptions.PaintOptions := plcon.TreeOptions.PaintOptions + [toShowBackground];

      playlistbox.background := tabel.Background;
      playlistbox.TreeOptions.PaintOptions := playlistbox.TreeOptions.PaintOptions + [toShowBackground];

      bm.Free;
      jp.Free
    end else
    begin
    	tabel.TreeOptions.PaintOptions := tabel.TreeOptions.PaintOptions - [toShowBackground];
      Winplaylist.TreeOptions.PaintOptions := Winplaylist.TreeOptions.PaintOptions - [toShowBackground];
      Tree.TreeOptions.PaintOptions := Tree.TreeOptions.PaintOptions - [toShowBackground];
      plcon.TreeOptions.PaintOptions := plcon.TreeOptions.PaintOptions - [toShowBackground];
      playlistbox.TreeOptions.PaintOptions := playlistbox.TreeOptions.PaintOptions - [toShowBackground];

			tabel.Background.Bitmap.FreeImage;
    	tabel.Background := nil;

      Winplaylist.Background.Bitmap.FreeImage;
    	Winplaylist.Background := nil;

      Tree.Background.Bitmap.FreeImage;
    	Tree.Background := nil;

      plcon.Background.Bitmap.FreeImage;
    	plcon.Background := nil;

      playlistbox.Background.Bitmap.FreeImage;
    	playlistbox.Background := nil;
  	end
end;

procedure TMainForm.test1Click(Sender: TObject);
begin
  if (tabel.ScrollBarOptions.ScrollBars = ssBoth) then
    tabel.ScrollBarOptions.ScrollBars := ssNone
  else
      tabel.ScrollBarOptions.ScrollBars := ssBoth;
end;

procedure TMainForm.WinplaylistBeforePaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas);
begin
	Winplaylist.BackgroundOffSetX := TabelPanelLow.Left;

  ToggleDummies(Sender)
end;

procedure TMainForm.ToggleDummies(Tree: TBaseVirtualTree);
var
	toggler: Boolean;
  aNode: PVirtualNode;
begin
  toggler := true;
  aNode := Tree.GetFirstVisible;
  while aNode <> nil do
  begin
  	toggler := not toggler;
    aNode.Dummy := byte(toggler);
    aNode := Tree.GetNextVisible(aNode)
  end
end;

procedure TMainForm.tabelBeforePaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas);
begin
	Tabel.BackgroundOffSetX := TabelPanelLow.Left;
  Tabel.BackgroundOffsetY := Tabel.Header.Height + 1;

  ToggleDummies(Sender)
end;

procedure TMainForm.tabelAfterCellPaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  CellRect: TRect);
begin
	if Column = 24 then	//Rating
  	DrawStars(TVirtualStringTreeEx(sender), TargetCanvas, Node, CellRect, GetRec(Node));
end;

procedure PaintStars(canvas: TCanvas; tree: TVirtualStringTree; node: PVirtualNode; CellRect: TRect; fontSize: integer; starColor, starColorDatk: TColor; nrOfStars: integer; hot, center: Boolean);
const starChar = '';
var
	starWidth, starPos, i: Integer;
begin
	canvas.brush.Style := bsClear;
  canvas.font.name := 'Wingdings';
  canvas.font.size := fontSize;
  canvas.Font.Color := starColor;

  if hot then
  	Canvas.Font.Style := [fsbold]
  else
  	Canvas.Font.Style := [];


	starWidth := Canvas.TextWidth(starChar);

  starPos := CellRect.Left + tree.Indent * (1+tree.GetNodeLevel(Node)) + tree.Margin;
  if center then
  	inc(starPos, CellRect.Left + Round((CellRect.Right - CellRect.Left)/2 - (starWidth*2.35)));


  for i:=0 to nrOfStars-1 do
  begin
  	canvas.TextRect(CellRect, starPos, CellRect.Top+1, starChar);
    inc(starPos, starWidth)
  end;

  if hot then
  begin
  	Canvas.Font.Color := starColorDatk;
    for i:=nrOfStars to 4 do
    begin
      Canvas.TextRect(CellRect, starPos, CellRect.Top+1, starChar);
      inc(starPos, starWidth)
    end
  end
end;


procedure TMainForm.DrawStars(sender: TVirtualStringTreeEx; TargetCanvas: TCanvas; Node: PVirtualNode; CellRect: TRect; rec: PRec);
const starChar = '';
var
	starWidth, starCount, starPos, i, treeIndex: Integer;
  mousePos: TPoint;
  hot: Boolean;
begin
	mousePos := Sender.ScreenToClient(mouse.CursorPos);

  TreeIndex := GetTreeIndex(Sender);

	TargetCanvas.brush.Style := bsClear;
  TargetCanvas.font.name := 'Wingdings';
  TargetCanvas.font.size := FStarFontSize[treeIndex];

  if not (PartyMode1.Checked and pref.DisableTagging.Checked) and (mousePos.x < Sender.ClientWidth) and (Node = Sender.HotNode) and ptinrect(sender.getdisplayrect(node, 24 + 2*TreeIndex, false), mousePos) then
  begin
  	hot := true;
  	//Hot-node
    TargetCanvas.Font.Style := [fsbold];
    FHotNodeBoldRating[TreeIndex] := true;
    FHotRatingNode[TreeIndex] := Node;
    starWidth := TargetCanvas.TextWidth(starChar);

    //Calculate starCount
    starPos := CellRect.Left + Round((CellRect.Right - CellRect.Left)/2 - (starWidth*2.35));
    starCount := ((mousePos.x - starPos - sender.OffsetX) div starWidth)+1;
    if starCount > 5 then
    	starCount := 5
    else
    if starCount < 0 then
    	starcount := 0;

    FHotNoteRatingValue[TreeIndex] := Round(starCount/5 * 255)
  end
  else
  begin
  	hot := false;
  	if FHotNodeBoldRating[treeIndex] and (FHotRatingNode[treeIndex] <> Node) then
    	if NodeBelongsToTree(FHotRatingNode[treeIndex], sender, true) then
	    	sender.InvalidateCell(FHotRatingNode[treeIndex], 24+ 2*TreeIndex)
      else
      	FHotNodeBoldRating[treeIndex] := false;

    if Node = sender.HotNode then
    	FHotNodeBoldRating[TreeIndex] := false;
    if Node = FHotRatingNode[TreeIndex] then
    	FHotRatingNode[TreeIndex] := nil;

    TargetCanvas.Font.Style := [];

    //Calculate Starcount
		starCount := Round(rec.Rating*StarNrFactor);
    if (starCount = 0) and (rec.Rating > 0) then
    	starCount := 1;
    starWidth := TargetCanvas.TextWidth(starChar);
    starPos := CellRect.Left + Round((CellRect.Right - CellRect.Left)/2 - (starWidth*2.35))
  end;

  if sender = tabel then
  	TargetCanvas.Font.Color := FSkinMainlistColorStarBright
  else
  	TargetCanvas.Font.Color := FSkinWinplaylistColorStarBright;

  for i:=0 to starCount-1 do
  begin
  	TargetCanvas.TextRect(CellRect, starPos, CellRect.Top+1, starChar);
    inc(starPos, starWidth)
  end;

  if hot then
  begin
    if sender = tabel then
	  	TargetCanvas.Font.Color := FSkinMainlistColorStarDark
	  else
	  	TargetCanvas.Font.Color := FSkinWinplaylistColorStarDark;
    for i:=starCount to 4 do
    begin
      TargetCanvas.TextRect(CellRect, starPos, CellRect.Top+1, starChar);
      inc(starPos, starWidth)
    end
  end
end;

procedure TMainForm.tabelHotChange(Sender: TBaseVirtualTree; OldNode,
  NewNode: PVirtualNode);
begin
	if tabel.Header.Columns.ColumnFromPosition(Point(tabel.ScreenToClient(Mouse.CursorPos).x, 0)) = 24 then   //Rating
  begin
		if assigned(OldNode) then tabel.invalidateCell(OldNode, 24);
	  if assigned(newNode) then	tabel.invalidateCell(NewNode, 24)
  end
end;

procedure TMainForm.tabelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if Assigned(tabel.Hotnode) and (FHotNodeBoldRating[0] or (tabel.Header.Columns.ColumnFromPosition(Point(x, 0)) = 24)) then   //Rating
    tabel.InvalidateCell(tabel.Hotnode, 24);

  FixRatingPainting(winplaylist);
end;

procedure TMainForm.tabelHeaderMouseMove(Sender: TVTHeader;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(tabel);
end;

procedure TMainForm.WinplaylistAfterCellPaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  CellRect: TRect);
begin
	if (Winplaylist.Header.Columns[Column].Tag = FRating) and assigned(PplstRec(Winplaylist.GetNodeData(Node)).Rec) then	//Rating
  	DrawStars(TVirtualStringTreeEx(sender), TargetCanvas, Node, CellRect, PplstRec(Winplaylist.GetNodeData(Node)).Rec);
end;

procedure TMainForm.WinplaylistHotChange(Sender: TBaseVirtualTree;
  OldNode, NewNode: PVirtualNode);
begin
	if winplaylist.Header.Columns.ColumnFromPosition(Point(winplaylist.ScreenToClient(Mouse.CursorPos).x, 0)) = 26 then   //Rating
  begin
		if assigned(OldNode) then winplaylist.invalidateCell(OldNode, 26);
	  if assigned(newNode) then winplaylist.invalidateCell(NewNode, 26);
  end
end;

procedure TMainForm.WinplaylistMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  FixRatingPainting(tabel);

  if Assigned(winplaylist.Hotnode) and (FHotNodeBoldRating[1] or (winplaylist.Header.Columns.ColumnFromPosition(Point(x, 0)) = 26)) then   //Rating
    winplaylist.InvalidateCell(winplaylist.Hotnode, 26)
end;

procedure TMainForm.WinplaylistMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
	tagValues: TtagValues;
begin
	if not (PartyMode1.Checked and pref.DisableTagging.Checked) and (Winplaylist.Header.Columns.ColumnFromPosition(point(x,1)) = 26) and assigned(Winplaylist.HotNode) and assigned(PplstRec(Winplaylist.GetNodeData(Winplaylist.Hotnode)).Rec) then   //Rating
  begin
  	SetLength(tagValues, 1);
    tagValues[0].field := FRating;
    tagValues[0].value := inttostr(FHotNoteRatingValue[1]);
   	UpdateRecValues(PplstRec(Winplaylist.GetNodeData(Winplaylist.Hotnode)).Rec, tagValues, GetDefaultUpdateTags);
    SetLength(tagValues, 0);
		tabel.Invalidate;
  end
end;

procedure TMainForm.WinplaylistHeaderMouseMove(Sender: TVTHeader;
  Shift: TShiftState; X, Y: Integer);
begin
  FixRatingPainting(winplaylist);
end;

procedure TMainForm.TabelScrollHMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(tabel);
end;

procedure TMainForm.Notrated1Click(Sender: TObject);
var
	values: PTagValues;
  aNode: PVirtualNode;
  recs, valuesList, rollBackList: TList;
  newRating: integer;
  rec: PRec;
begin
	recs := TList.Create;
  valuesList := TList.Create;
  rollBackList := TList.Create;

  newRating := integer(round(TMenuItem(sender).MenuIndex / 5 * 255));

  aNode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
  	rec := GetRec(aNode);
    if rec.Rating <> newRating then
    begin
    	recs.Add(rec);

      New(values);
      SetLength(values^, 1);
      values^[0].field := FRating;
      values^[0].value := inttostr(newRating);
      valuesList.Add(values);

      //Rollback
      New(values);
      SetLength(values^, 1);
      values^[0].field := FRating;
      values^[0].value := inttostr(rec.Rating);
      rollBackList.Add(values)
    end;

    aNode := tabel.GetNextSelected(aNode)
  end;

  UpdateRecValues(recs, valuesList, rollBackList, 'Tagging...', true, GetDefaultUpdateTags);
  tabel.invalidate
end;

procedure TMainForm.tabelChange(Sender: TBaseVirtualTree; Node: PVirtualNode);
var
	aNode: PVirtualNode;
  i: Integer;
  selectedGroupsChanged: boolean;
  groupSelected: TBits;
  rec: PRec;
begin
 	selectedGroupsChanged := false;
  groupSelected := TBits.Create;
  groupSelected.Size := GroupList.Count;

  aNode := Sender.GetFirstSelected;
  while assigned(aNode) do
  begin
  	rec := GetRec(aNode);
    for i:=0 to length(rec.Groups)-1 do
    	groupSelected.Bits[rec.Groups[i]] := true;

    aNode := Sender.GetNextSelected(aNode)
  end;

  for i:=0 to GroupList.Count-1 do
  begin
  	if groupSelected.Bits[i] <> PGroupRec(GroupList.List^[i]).SelectedFilesInGroup then
    begin
    	selectedGroupsChanged := true;
      PGroupRec(GroupList.List^[i]).SelectedFilesInGroup := groupSelected.Bits[i]
    end
  end;
  groupSelected.Free;
  if selectedGroupsChanged then
  	tree.invalidate;

	TimerUpdateLblMainlistCount.Enabled := false;
  TimerUpdateLblMainlistCount.Enabled := true
end;

procedure TMainForm.TimerUpdateLblMainlistCountTimer(Sender: TObject);
begin
	TimerUpdateLblMainlistCount.Enabled := false;
  if pref.cbShowTotalDurationLabel.Checked then
		UpdateLblMainListCount
end;

procedure TMainForm.RemoveAutoScannedflag1Click(Sender: TObject);
var
	aNode: PVirtualNode;
begin
	anode := tabel.GetFirstSelected;
  while aNode <> nil do
  begin
  	Exclude(GetRec(aNode).Flags, rfAutoScanned);
    tabel.InvalidateNode(aNode);
    aNode := tabel.GetNextSelected(aNode)
  end
end;

procedure TMainForm.mniWriteAllSupportedTagsClick(Sender: TObject);
begin
	WriteSelectedTagsToFiles(UpdateRecTagOption_UpdateElseCreate, UpdateRecTagOption_UpdateElseCreate, UpdateRecTagOption_UpdateElseCreate, UpdateRecTagOption_UpdateElseCreate, UpdateRecTagOption_UpdateElseCreate)
end;

procedure TMainForm.TabelScrollVMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(tabel);
end;

procedure TMainForm.Trimtag1Click(Sender: TObject);
var
	tagCutter : TTagCutter;
  i: integer;
begin
  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  SetFilterFlags;

  Application.CreateForm(TTagCutter, tagCutter);

  if fonlyPL then
  for i:=0 to Fplaylist.count-1 do
  	tagCutter.list.Add(FPlaylist.items[i])
  else
  for i:=0 to reclist.count-1 do
    if filterRec(reclist.List^[i], true) then
    	tagCutter.list.Add(reclist.List^[i]);

  CurrentActiveForm := TagCutter;
  if tagCutter.list.count > 0 then
	  tagCutter.ShowModal;
  CurrentActiveForm := nil;
  tagCutter.Release;
  FreeAndNil(tagCutter);
  
  AfterTagChanged;

  if pref.AutoResizeColumnHeaders.Checked then
    AutoResizeAllColumnsToFit;

  updateTree(true);

  tabel.invalidate;

  Dec(SafeToAutoScanCount);
end;

procedure TMainForm.CDDBlookup1Click(Sender: TObject);
var
   cddbForm : TCddbForm;
   i: integer;
begin
  Inc(SafeToAutoScanCount);
  WaitForAutoScan;

  SetFilterFlags;

  application.CreateForm(TCddbForm, cddbForm);

  if fonlyPL then
  for i:=0 to Fplaylist.count-1 do
  	cddbForm.list.Add(FPlaylist.items[i])
  else
  for i:=0 to reclist.count-1 do
    if filterRec(reclist.List^[i], true) then
    	cddbForm.list.Add(reclist.List^[i]);

  if cddbForm.list.Count > 0 then
  begin
    cddbForm.Init;
    CurrentActiveForm := cddbForm;
    cddbForm.ShowModal;
    CurrentActiveForm := nil;
  end;
  cddbForm.Release;
  freeAndNil(cddbForm);
  AfterTagChanged;
  if pref.AutoResizeColumnHeaders.Checked then
	  AutoResizeAllColumnsToFit;
  updateTree(true);

  tabel.invalidate;

  Dec(SafeToAutoScanCount);
end;

procedure TMainForm.treeBeforePaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas);
begin
	ToggleDummies(Sender)
end;

procedure TMainForm.playlistboxBeforePaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas);
begin
	ToggleDummies(Sender)
end;

procedure TMainForm.plConBeforePaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas);
begin
	ToggleDummies(Sender)
end;

procedure TMainForm.ClearPopupPopup(Sender: TObject);
begin
	ClearAll1.shortcut := DeleteWinampPlaylist1.shortcut;
end;

procedure TMainForm.WinPlayScrollHMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(winplaylist);
end;

procedure TMainForm.WPbarLowMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(winplaylist);
end;

procedure TMainForm.FixRatingPainting(tree: TVirtualStringTree);
begin
	if tree = tabel then
  begin
  	//Fix rating i tabel
	  if FHotNodeBoldRating[0] and Assigned(tabel.Hotnode) then
	  	if NodeBelongsToTree(FHotRatingNode[0], tabel, true) then   //Rating
		  	tabel.InvalidateCell(FHotRatingNode[0], 24)
	    else
	    	FHotNodeBoldRating[0] := false;
  end
  else if tree = winplaylist then
	begin
		//Fix rating i winplaylist
	  if FHotNodeBoldRating[1] and Assigned(winplaylist.Hotnode) then   //Rating
	    if NodeBelongsToTree(FHotRatingNode[1], winplaylist, true) then
	      winplaylist.InvalidateCell(FHotRatingNode[1], 26)
	    else
	      FHotNodeBoldRating[1] := false
  end;
end;

procedure TMainForm.winplaylistTimeLabelMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(winplaylist)
end;

procedure TMainForm.WinplaylistCurrentTimeLabelMouseMove(
  Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(winplaylist);
end;

procedure TMainForm.FileInfoLabelMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(winplaylist);
end;

procedure TMainForm.Label1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
	FixRatingPainting(tabel);
end;

procedure TMainForm.ClearButtonMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(tabel);
end;

procedure TMainForm.MinimizeWinplayMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(tabel);
end;

procedure TMainForm.WinPlayScrollVMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
	FixRatingPainting(winplaylist);
end;

procedure TMainForm.treeMeasureItem(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; var NodeHeight: Integer);
var
	tr: PTreeRec;
begin
	if not quitting then
  	if pref.cbShowCoverInTree.Checked then
    begin
      fCoverRecRw.BeginRead;
      try
        tr := pTReeRec(tree.GetNodeData(Node));
        if assigned(tr.CoverRec) and (tr.CoverRec.State <> ErrorLoading) then
        begin
          if (tr.CoverRec.ThumbnailHeight > 0) and not (crfInvalidateThumb in tr.CoverRec.Flags) then
            NodeHeight := tr.CoverRec.ThumbnailHeight + (2*fTreeCoverBorder) + 4	//De 4 er margin for oven og neden
          else
            NodeHeight := fTreeCoverHeight + (2*fTreeCoverBorder) + 4;	//De 4 er margin for oven og neden
          if pref.cbTreeCoverIncludeAlbumName.Checked then
            Inc(NodeHeight, tree.DefaultNodeHeight)
        end
        else
          NodeHeight := tree.DefaultNodeHeight
      finally
        fCoverRecRw.EndRead;
      end
    end
    else
    	NodeHeight := tree.DefaultNodeHeight
end;

procedure TMainForm.treeAfterCellPaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  CellRect: TRect);
function GetLoadPriority: cardinal;
begin
	Inc(fCoverLoadPriority);
  result := fCoverLoadPriority
end;
var
	tr: PTreeRec;
  b: boolean;
  bm, img: TBitmap;
  x, textOffsetX: integer;
  text: WideString;
  doRepaint: boolean;
begin
	//Paint cover or rating
  tr := tree.GetNodeData(Node);
  if assigned(tr.CoverRec) then
  begin
  	if pref.cbShowCoverInTree.Checked and not (tree.IsEditing and (Node = Tree.FocusedNode)) then
	  begin
    	doRepaint := false;
      fCoverRecRW.BeginRead;
      b := ((tr.CoverRec.State = NotLoaded) or (crfInvalidateThumb in tr.CoverRec.Flags)) and (tr.CoverRec.State <> ErrorLoading) ;
      fCoverRecRW.EndRead;

      if b then
      //if ((tr.CoverRec.State = NotLoaded) or (crfInvalidateThumb in tr.CoverRec.Flags)) and (tr.CoverRec.State <> ErrorLoading) then
      begin
        if not pref.chkLoadThumbsInBackground.Checked and LoadCoverThumbnail(tr.CoverRec) then
        begin
          tree.InvalidateNode(Node);
          doRepaint := true
        end
        else
        begin
          fCoverRecRW.BeginWrite;
          try
            tr.CoverRec.State := RequestLoad;
            tr.CoverRec.LoadPriority := GetLoadPriority
          finally
            fCoverRecRW.EndWrite;
            SetEvent(WakeCoverThread)
          end
        end
      end;

      fCoverRecRW.BeginRead;
      try
        if (tr.CoverRec.State = ImageLoaded) and not (crfInvalidateThumb in tr.CoverRec.Flags) and assigned(tr.CoverRec.Image) then
        begin
          Include(tr.CoverRec.Flags, crfThumbnailVisible);
          img := TBitmap.Create;
          img.Assign(tr.CoverRec.Image);

          bm := TBitmap.Create;
          //bm.Assign(tr.CoverRec.Image);	This fails sometimes (the image isn't drawn) - don't know why. Use BitBlt instead
          bm.Canvas.brush.Color := clGray;	//Todo: Border color in skin
          bm.Width := tr.CoverRec.Image.Width + (2 * fTreeCoverBorder);
          bm.Height := tr.CoverRec.Image.Height + (2 * fTreeCoverBorder);
          BitBlt(bm.Canvas.Handle, fTreeCoverBorder, fTreeCoverBorder, img.Width, img.Height, img.Canvas.Handle, 0, 0, SRCCOPY);

          x := CellRect.Left + tree.Indent * (1+tree.GetNodeLevel(Node)) + tree.Margin;
          BitBlt(targetCanvas.Handle, x, CellRect.Top + 2, bm.Width, bm.Height, bm.Canvas.Handle, 0, 0, SRCCOPY);

          if pref.cbTreeCoverIncludeAlbumName.Checked then
          begin
            text := '';
            TreeGetText(sender, node, 500, ttStatic, text);
            textOffsetX := x + (Min(bm.Width, tree.ClientWidth - x) div 2) - (TargetCanvas.TextWidth(text) div 2);
            if textOffsetX < x then
              textOffsetX := x;
            TargetCanvas.TextOut(textOffsetX, Max(0, Node.NodeHeight - tree.DefaultNodeHeight) + 2, text);
          end;
          bm.Free;
          img.Free
        end
        else
          Exclude(tr.CoverRec.Flags, crfThumbnailVisible);
      finally
        fCoverRecRW.EndRead
      end;
      if doRepaint then
      	tree.ValidateNode(tree.rootNode, true)
    end
    else
    	Exclude(tr.CoverRec.Flags, crfThumbnailVisible)
  end
  else
  if TR.Kind = TreeKind_Rating then
  	PaintStars(TargetCanvas, tree, node, cellRect, FStarFontSize[2], FSkinTreeColorStarBright, FSkinTreeColorStarDark, TR.Tag, true, false)	//dark color is not used
end;

procedure TMainForm.UnloadCoverRec(cr: PCoverRec; deleteThumbnail: boolean);
begin
	fCoverRecRw.BeginWrite;
  try
    cr.State := NotLoaded;
    Exclude(cr.Flags, crfThumbnailVisible);

  	if assigned(cr.Image) then
    begin
    	try
      	cr.image.Free;
      except
      end;
      	cr.image := nil
    end;

    if deleteThumbnail and (length(cr.ThumbCacheFilename) > 0) then
    begin
    	try
      	if FileExists(CoverThumbsDir + cr.ThumbCacheFilename) then
        	DeleteFile(CoverThumbsDir + cr.ThumbCacheFilename)
      except
      end
    end;

  finally
    fCoverRecRw.EndWrite
  end
end;

procedure TMainForm.ReleaseAndDisposeCoverRecs(deleteThumbnail, removeFromTree: boolean);
var
	aNode: PVirtualNode;
  tr: PTreeRec;
  i: integer;
  cr: PCoverRec;
begin
  fCoverImgsRw.BeginWrite;
  fCoverRecRw.BeginWrite;
  try
  	if removeFromTree then
	  begin
	  	aNode := Tree.GetFirst;
	    while aNode <> nil do
	    begin
	    	tr := Tree.GetNodeData(aNode);
	      if Assigned(tr.CoverRec) and (crfDeletePending in tr.CoverRec.Flags) then
	      	tr.CoverRec := nil;
	      aNode := tree.GetNext(aNode)
	    end
	  end;

    for i:=0 to fCoverImgs.Count -1 do
	  begin
	  	cr := fCoverImgs.List^[i];
      if crfDeletePending in cr.Flags then
      begin
      	DisposeCoverRec(cr, deleteThumbnail);
        fCoverImgs.Items[i] := nil
      end
	  end;
    fCoverImgs.Pack
  finally
	  fCoverImgsRw.EndWrite;
    fCoverRecRw.EndWrite
  end
end;

procedure TMainForm.DisposeCoverRec(cr: PCoverRec; deleteThumbnail: boolean);
begin
  fCoverRecRw.BeginWrite;
  try
  	UnloadCoverRec(cr, deleteThumbnail);
    Dispose(cr);
  finally
    fCoverRecRw.EndWrite
  end
end;

function TMainForm.CanLoadCoverThumbnail(cr: PCoverRec): boolean;
begin
	fCoverRecRW.BeginRead;
  try
  	try
			result := (length(cr.ThumbCacheFilename) > 0) and FileExists(CoverThumbsDir + cr.ThumbCacheFilename)
    except
	  	result := false;
    end
  finally
  	fCoverRecRW.EndRead
  end
end;

function TMainForm.LoadCoverThumbnail(cr: PCoverRec): boolean;
var
	jpg: TJpegImage;
  b: boolean;
begin
	fCoverRecRW.BeginRead;
  try
	  b := ((cr.State = NotLoaded) or (cr.State = RequestLoad)) and not (crfInvalidateThumb in cr.Flags) and CanLoadCoverThumbnail(cr);
	finally
  	fCoverRecRW.EndRead;
  end;

	if b then
  begin
  	try
	  	jpg := TJPEGImage.Create;
	    jpg.LoadFromFile(CoverThumbsDir + cr.ThumbCacheFilename);
    except
    	result := false;
      exit
    end;

  	fCoverRecRW.BeginWrite;
    try
	    cr.State := Loading;
	  	if assigned(cr.Image) then
	    	cr.Image.Free;
	  	cr.Image := jpg;
      cr.ThumbnailWidth := jpg.Width;
      cr.ThumbnailHeight := jpg.Height;
	    cr.State := ImageLoaded;
	    Exclude(cr.Flags, crfThumbnailChanged)
    finally
    	fCoverRecRW.EndWrite;
    end;

    result := true
  end
  else
  	result := false
end;

{procedure TMainForm.FixCoverImgsList;
var
	i, j: integer;
  cr: PCoverRec;
begin
	fCoverImgsRW.AcquireWriter;
  fCoverRecRW.AcquireWriter;
  try
		for i:=0 to fCoverImgs.Count-1 do
	  begin
	  	cr := fCoverImgs.items[i];
	    if ((cr.SourceType = coverSource_id3v2TagIndex3) or (cr.SourceType = coverSource_id3v2TagIndex0)) and not assigned(cr.SourceRec) then
				cr.SourceRec := FindInReclist(cr.imageFilename)
	  end
	finally
  	fCoverImgsRW.ReleaseWriter;
    fCoverRecRW.ReleaseWriter;
  end
end;   }

procedure TMainForm.CoverLoadThreadExecute(Sender: TObject; Thread: TBMDExecuteThread; var Data: Pointer);

function LoadFromTag(cr: PCoverRec; bm: TBitmap32): Boolean;
var
  FStr: TFileStream;
	id3v2: TMyID3Controller;
  i: Integer;
  mstr: TStream;
  jpgImg: TJPEGImage;
  pngImg: TPngObject;
  picFrm: TJvID3PictureFrame;
begin
	result := false;
	try
  	if assigned(cr.SourceRec) and GetFileAccess(GetFTextP(cr.SourceRec, FFilename), true, false) then
    begin
      id3v2 := TMyID3Controller.Create(nil);
      try
        FStr := TFilestream.Create(getFtextP(cr.SourceRec, fFilename), fmOpenReadWrite or fmShareDenyNone);
        id3v2.LoadFromStream(FStr);
        for i:=0 to id3v2.Frames.count-1 do
        begin
          if id3v2.Frames[i].FrameId = fiPicture then
          begin
            picFrm := TJvID3PictureFrame(Id3v2.Frames[i]);
            if ((picFrm.PictureType = ptCoverFront) and (cr.SourceType = coverSource_id3v2TagIndex3)) or ((picFrm.PictureType=ptOther) and (cr.SourceType = coverSource_id3v2TagIndex0)) then
            begin
              mstr := TMemorystream.Create;
              try
                picFrm.SaveToStream(mstr);
                mstr.Position := 0;
                if (Q_SameText(picfrm.MIMEType, 'image/jpg') or Q_SameText(picfrm.MIMEType, 'image/jpeg')) then
                begin
                  jpgImg := TJpegImage.Create;
                  jpgImg.LoadFromStream(mstr);
                  bm.Assign(jpgImg);
                  jpgImg.Free;
                  result := true;
                  exit
                end
                else
                if Q_SameText(picfrm.MIMEType, 'image/png') then
                begin
                  pngImg := TPngObject.Create;
                  pngimg.LoadFromStream(mstr);
                  bm.Assign(pngImg);
                  pngImg.Free;
                  result := true;
                  exit
                end;
              finally
                mstr.Free
              end
          end
          end
          end
			finally
      	FreeAndnil(id3v2);
        FreeAndNil(Fstr);
      end
    end
  except
  end
end;

function Bitmap32ToJpeg(bm32: TBitmap32): TJpegImage;
var
	bm: TBitmap;
begin
	bm := TBitmap.Create;
  bm.Assign(bm32);

  result := TJpegImage.Create;
  result.CompressionQuality := 90;
  result.Assign(bm);
  bm.Free;
  result.Compress
end;
var
	i, coverToLoadIndex: integer;
  loadPriority, maxLoadPriority: cardinal;
  cr: PCoverRec;
  bm1, bm2: TBitmap32;
  jpg: TJpegImage;
  state: TCoverRecState;
  picLoaded: boolean;
begin
	while not Thread.Terminated and not quitting do
  begin
  	while not Thread.Terminated do
    begin
    	coverToLoadIndex := -1;
      maxLoadPriority := 0;

      fCoverImgsRW.BeginRead;
	    try
	      //Find cover with highest priority
	      for i:=0 to fCoverImgs.Count-1 do
	      begin
          cr := PCoverRec(fCoverImgs.List^[i]);

          fCoverRecRW.BeginRead;
          state := cr.State;
          loadPriority := cr.LoadPriority;
          fCoverRecRW.EndRead;

          if (State = RequestLoad) and (loadPriority >= maxLoadPriority) then
          begin
            coverToLoadIndex := i;
            maxLoadPriority := loadPriority
          end
        end;

        //Read cover with highest priority
        if coverToLoadIndex >= 0 then
          cr := PCoverRec(fCoverImgs.List^[coverToLoadIndex])
        else
        	cr := nil;
      finally
      	fCoverImgsRw.EndRead
      end;

      if assigned(cr) then
      begin
      	if LoadCoverThumbnail(cr) then
        begin
        	if not thread.Terminated then
	        	thread.Synchronize(CoverLoaded, cr)	//Signal repaint nescecary
        end
        else
        begin
          fCoverRecRw.BeginRead;

          fCoverRecRW.BeginWrite;	//this is allowed, even though we're in a reader
          cr.State := Loading;
          fCoverRecRW.EndWrite;

          //Load picture
          picLoaded := false;
          try
            bm2 := TBitmap32.Create;
            if cr.SourceType = coverSource_imageFile then
            begin
              if dbs[cr.SourceRec.Location].exists then
              begin
                bm2.LoadFromFile(GetFTextP(cr.SourceRec, FFILEPATH) + cr.ImageFilename);
                picLoaded := true
              end
            end
            else
            begin
              picLoaded := LoadFromTag(cr, bm2);
            end
          except
          end;
          fCoverRecRw.EndRead;

          if picLoaded then
          begin
            try
              //Calc resize factor
              bm1 := TBitmap32.Create;
              if (bm2.Height > 0) and (bm2.Width > 0) then
              begin
                if (bm2.Height / bm2.Width) > (fTreeCoverHeight / fTreeCoverWidth) then
                begin
                  bm1.Height := fTreeCoverHeight;
                  bm1.Width := Round(bm2.Width * bm1.Height / bm2.Height);
                end
                else
                begin
                  bm1.Width := fTreeCoverWidth;
                  bm1.Height := Round(bm2.Height * bm1.Width / bm2.Width);
                end
              end;

              StretchTransfer(bm1, bm1.BoundsRect, bm1.BoundsRect, bm2, bm2.BoundsRect, sfLanczos, dmOpaque);	//sfMitchell - Lanczos er bedst :)
              bm2.Free;
              jpg := Bitmap32ToJpeg(bm1);
              bm1.Free;

              fCoverRecRW.BeginWrite;
              try
                if assigned(cr.Image) then
                  cr.Image.Free;
                cr.Image := jpg;
                cr.ThumbnailWidth := jpg.Width;
                cr.ThumbnailHeight := jpg.Height;
                cr.State := ImageLoaded;
                Include(cr.Flags, crfThumbnailChanged);
                Exclude(cr.Flags, crfInvalidateThumb)
              finally
                fCoverRecRW.EndWrite;
              end;
            except
              fCoverRecRW.BeginWrite;
              try
                cr.State := ErrorLoading
              finally
                fCoverRecRW.EndWrite;
              end;
            end;	//of try
          end
          else           		//PicLoaded = false
          begin
            fCoverRecRW.BeginWrite;
            try
              cr.State := ErrorLoading
            finally
              fCoverRecRW.EndWrite;
            end;
          end;

          if not thread.Terminated then
          begin
            thread.Synchronize(CoverLoaded, cr)
          end
        end;
      end	//of if assigned(cr)
      else
        break;	//break second while not terminated

    end;	//of inner while not terminated

		WaitForSingleObject(WakeCoverThread, INFINITE);
  end;	//of outer while not terminated

  //Signal thread terminated
  CoverLoadThread.Tag := 1
end;

procedure TMainForm.CoverLoaded(Sender: TBMDThread;
  Thread: TBMDExecuteThread; var Data: Pointer);
var
	aNode: PVirtualNode;
begin
	fCoverRecRw.BeginRead;
  try
	  aNode := tree.GetFirstVisible;
	  while aNode <> nil do
	  begin
	    if PTreeRec(tree.GetNodeData(aNode)).CoverRec = Data then
	    begin
	      Exclude(aNode.States, vsHeightMeasured);
	      tree.InvalidateNode(aNode);
        //tree.ValidateNode(aNode, false)
        tree.repaintnode(aNode)
	    end;

	    aNode := tree.GetNextVisible(aNode)
	  end
  finally
  	fCoverRecRw.EndRead
  end;
end;

procedure TMainForm.SetTreeCoverSize(width, height, border: integer);
var
	i: integer;
  cr: PCoverRec;
begin
  fTreeCoverBorder := border;

  //Has size changed?
  if (fTreeCoverWidth <> width) or (fTreeCoverHeight <> height) then
  begin
    fTreeCoverWidth := width;
  	fTreeCoverHeight := height;

    fCoverImgsRW.BeginRead;
    fCoverRecRW.BeginWrite;
    try
	  	for i:=0 to fCoverImgs.Count-1 do
	    begin
	    	cr := fCoverImgs.List^[i];
	      if not ((cr.ThumbnailWidth = width) or (cr.ThumbnailHeight = height)) then
	      	Include(cr.Flags, crfInvalidateThumb)
	    end;
    finally
    	fCoverRecRW.EndWrite;
    	fCoverImgsRW.EndRead
    end;
  end;

  //Invalidate the tree so thumbnails will be reloaded
  tree.invalidate;
end;

{procedure TMainForm.ReadJpegs1Click(Sender: TObject);
var
	i: integer;
  start: dword;
begin
	start := gettickcount;

 // showmessagex(inttostr(gettickcount - start));
	for i:=0 to fCoverImgs.Count-1 do
  	if PCoverRec(fCoverImgs.Items[i]).State = NotLoaded then
    	PCoverRec(fCoverImgs.Items[i]).State := RequestLoad;

  SetEvent(WakeCoverThread)
end;      }

{
procedure TMainForm.xml1Click(Sender: TObject);
procedure WriteField(field: string; value: String; mstr: TStream);
begin
	WriteStringToStream('<' + field + '>' + value + '</' + field + '>' + #13#10, mstr);
end;
var
	mstr: TMemorystream;
  i: integer;
  rec: prec;
begin
	mstr := TMemorystream.Create();

  WriteStringToStream('<Tracks>' + #13#10, mstr);

  for i:=0 to reclist.count-1 do
  begin
		rec := reclist.items[i];
    WriteStringToStream('<Record>' + #13#10, mstr);

    WriteField('Artist',getftextp(rec, FARTIST), mstr);
    WriteField('Title',getftextp(rec, FTITLE), mstr);
    WriteField('Album',getftextp(rec, FAlbum), mstr);
    WriteField('Genre',getftextp(rec, FGENRE), mstr);

    WriteStringToStream('</Record>' + #13#10, mstr);
  end;

  WriteStringToStream('</Tracks>' + #13#10, mstr);

  mstr.SaveToFile('C:\database.xml');

  mstr.free;
end;}
      {
procedure TMainForm.test2Click(Sender: TObject);
var
	start: dword;
  crc, x: cardinal;
  s: String;
	i, j, k :integer;
  rec: PRec;
  lst: TStringlist;
begin
	crc := 0;
	lst := TStringlist.Create;
  lst.Capacity := reclist.count;
  for i:=0 to reclist.count-1 do
  begin
  	rec := reclist.Items[i];
    lst.add(GETFTextP(rec, ffilename));
  end;

  start := Gettickcount;

  for i:=0 to lst.count-1 do
  begin
  	x := MyHash(lst.Strings[i]);
    //x := Q_TextHashKey(lst.Strings[i]);
  	crc := crc xor x
  end;

  showmessagex(inttostr(gettickcount-start) + ' - ' + inttostr(crc));
end;  }

procedure TMainForm.AfterAutoScanThread(Sender: TBMDThread; Thread: TBMDExecuteThread; var Data: Pointer);
begin
	ReleaseRecs(true, true);
  Reclist.Pack
end;

procedure TMainForm.Enqueue3Click(Sender: TObject);
var
	aNode, wNode:PvirtualNode;
	pc:PplConRec;
begin
	wNode := Winplaylist.GetLast;
	aNode := plCon.GetFirstSelected;
  while aNode <> nil do
  begin
  	pc := plCon.GetNodeData(aNode);
    wNode := PlConToWinPlaylist(PC, wNode, amInsertAfter);
    aNode := plCon.GetNextSelected(aNode)
  end;
  WinPlaySave()
end;

procedure TMainForm.Showcovers1Click(Sender: TObject);
begin
	Showcovers1.Checked := not Showcovers1.Checked;
  pref.cbShowCoverInTree.Checked := Showcovers1.Checked;
  tree.ReinitNode(tree.rootnode, true);
  tree.Invalidate
end;

procedure TMainForm.treeGetNodeWidth(Sender: TBaseVirtualTree;
  HintCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  var NodeWidth: Integer);
var
	tr: PTreeRec;
  fnt: TFont;
begin
	tr := Sender.GetNodeData(Node);
  if assigned(tr.CoverRec) and (crfThumbnailVisible in tr.CoverRec.Flags) then
  	NodeWidth := tr.CoverRec.ThumbnailWidth + (2 * pref.treeCoverBorder.Value)
  else

  if tr.Kind = TreeKind_Rating then
  begin
  	fnt := TFont.Create;
  	fnt.name := 'Wingdings';
  	fnt.size := FStarFontSize[2];
    fnt.Style := [fsBold];
  	NodeWidth := GetTextWidth('', fnt);
    fnt.Free
  end
end;

procedure TMainForm.Set1Click(Sender: TObject);
begin
	TreeDropPopup.Tag := 1;
end;

procedure TMainForm.Add1Click(Sender: TObject);
begin
	TreeDropPopup.Tag := 2;
end;

procedure TMainForm.Remove1Click(Sender: TObject);
begin
	TreeDropPopup.Tag := 3;
end;

procedure TMainForm.Cancel1Click(Sender: TObject);
begin
	TreeDropPopup.Tag := 0;
end;

procedure TMainForm.TreeDropPopupPopup(Sender: TObject);
begin
	TreeDropPopup.Tag := 0;
end;

procedure TMainForm.Reloadcover1Click(Sender: TObject);
var
	tr: PTreeRec;
  aNode: PVirtualNode;
begin
  aNode := tree.GetFirstSelected;
  while aNode <> nil do
  begin
  	tr := tree.GetNodeData(aNode);
    if assigned(tr.CoverRec) and (crfThumbnailVisible in tr.CoverRec.Flags) then
      UnloadCoverRec(tr.CoverRec, true);
    aNode := tree.GetNextSelected(aNode)
  end
end;

procedure TMainForm.tabelGetHint(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex;
  var LineBreakStyle: TVTTooltipLineBreakStyle; var HintText: WideString);
begin
	HintText := getHint(GetRec(Node));
  LineBreakStyle := hlbForceMultiLine
end;

procedure TMainForm.treeGetHint(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex;
  var LineBreakStyle: TVTTooltipLineBreakStyle; var HintText: WideString);
Function NodePath(aNode:PVirtualNode):String;
var
	bNode:PVirtualNode;
  s: WideString;
begin
  result := '';
  bNode:=aNode;
  while bNode <> nil do
  begin
    if (bNode.parent = tree.rootnode) and showmedia1.checked then
      result := inttostr(PtreeRec(tree.GetNodeData(bNode))^.Location) + '\' + result
      	else
      begin
        TreeGetText(Tree, bNode, 0, ttStatic, s);
      	result := s + '\' + result
      end;
    bNode := bNode.parent;
    if tree.rootnode = bNode then
    	bNode := nil
  end
end;

Procedure Calc;
var
  i:integer;
  TR : PtreeRec;
  NP,ts : string;
  r:Prec;
  PL : pPLrec;
  PC : pPLcacheRec;
begin
  NP := NodePath(Node);
  TR := tree.GetNodeData(Node);
  case TR.kind of
    TreeKind_Directory, TreeKind_DirectoryRecursive, TreeKind_TrimmedDirectory, TreeKind_TrimmedDirectoryRecursive, TreeKind_Drive, TreeKind_DriveRecursive:
    	begin
        TR.Count := 0;
        TR.TotalTime := 0;
        for i:=0 to reclist.count-1 do
        begin
          r := reclist.List^[i];
          ts := getFTextP(r, fFilePath);//getfilepath(getFtextP(r, fFilename));
          if showmedia1.checked then
          	ts := inttostr(r.location) + '\' + ts;

          if Q_SameText(Q_CopyLeft(ts,length(NP)), NP) then
          begin
            Inc(TR.Count);
            Inc(TR.TotalTime, r.length)
          end
        end
      end;
      TreeKind_Playlist:
      begin
        TR.Count := 0;
        TR.TotalTime := 0;

        PL := TR.PlRecRef;
        UpdatePLcache(PL);
        PC := PL.CacheRef;

        for i:=0 to length(PC.cache)-1 do
        begin
             r := PC.cache[i];
             Inc(TR.Count);
             Inc(TR.TotalTime, r.length)
        end
      end
  end
end;

var     TR : PtreeRec;
        PL : pPLrec;
begin
	HintText := '';
  LineBreakStyle := hlbForceMultiLine;

  TR := tree.GetNodeData(Node);
  if TR.Kind in [TreeKind_GroupParent, TreeKind_Group, TreeKind_GroupSetting] then
    exit;

  if (TR.Count = 0) and (TR.totaltime = 0) then calc;
  //if (TR.Count <> 0) and (TR.totaltime <> 0) then
  begin
    if TR.kind = TreeKind_Playlist then
    begin
      PL := TR.PlRecRef;
      UpdatePLcache(PL);
      HintText := PL.filename + #13;
      if not pPLcacheRec(PL.cacheRef).complete then
      	HintText := HintText + GetText(TXT_NotAllFilesFoundInDB) + #13;
      HintText := HintText + #13 //ekstra linieafstand
    end;
    HintText := HintText + GetText(TXT_TotalPlayingTime, [IntTimeToStr(TR.TotalTime,true,true), inttostr(TR.count)])
  end
end;

procedure TMainForm.timTreeSelectionChangedTimer(Sender: TObject);
begin
	timTreeSelectionChanged.Enabled := false;
  OnTreeSelectionChanged;
end;

procedure TMainForm.WinplaylistGetHint(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex;
  var LineBreakStyle: TVTTooltipLineBreakStyle; var HintText: WideString);
var   PL:PplstRec;
begin
	PL := sender.GetNodeData(Node);
	if assigned(PL.Rec) then
		HintText := GetHint(PL.Rec)
	else
    HintText := GetText(TXT_FilenameLength, [PL.Filename, IntTimeToStr(pl.Seconds*1000 , false, false)])
end;

procedure TMainForm.Selectnone1Click(Sender: TObject);
begin
	Selectnoneshowalldatabases1Click(sender)
end;

procedure TMainForm.test2Click(Sender: TObject);
var
	lst, lst2: TStringlist;
  start: dword;
  aNode: PVirtualNode;
  s: string;
  i:integer;
begin
//	SortCoverImgs

//  showmessagex(inttostr(gettickcount-start))     }
end;

procedure TMainForm.treeChecking(Sender: TBaseVirtualTree;
  Node: PVirtualNode; var NewState: TCheckState; var Allowed: Boolean);
var
	TR: PTreeRec;
  State : TKeyboardState;
begin

	TR := tree.GetNodeData(Node);

  if TR.Kind = TreeKind_Group then
  begin
    //Is Shift pressed?
  	GetKeyboardState(State);
  	if ((State[vk_Shift] and 128) <> 0) then
    begin
      if tree.CheckState[Node] = csMixedNormal then
        newState := csUncheckedNormal
      else
        newState := csMixedNormal
    end
{    case Node.CheckState of
      csUncheckedNormal: NewState := csCheckedNormal;
      csCheckedNormal: NewState := csMixedNormal;
      csMixedNormal: NewState := csUncheckedNormal
    end}
  end
end;


procedure TMainForm.tabelFocusChanged(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex);
begin
  if Assigned(Node) then tabel.ScrollIntoView(Node, false)
end;

procedure TMainForm.WinplaylistFocusChanged(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Column: TColumnIndex);
begin
  if Assigned(Node) then Winplaylist.ScrollIntoView(Node, false)
end;


end.



